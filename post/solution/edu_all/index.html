<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <script type="application/ld+json">

{  
  "@context":"http://schema.org",
  "@type":"Website",
  "@id":"https:\/\/xiaoxiauwu.github.io\/",
  "author": {
    "@type": "Person",
    "name": "XiaoXia",
    
    "image": "https://xiaoxiauwu.github.io/images/avatar.jpg"
    
  },
  "name":"夏のBLOG",
  "description":"",
  "url":"https:\/\/xiaoxiauwu.github.io\/post\/solution\/edu_all\/",
  "keywords":"[tech, C\u002b\u002b, python, study]"
}

</script>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.121.2 with theme Tranquilpeak 0.5.3-BETA">
<meta name="author" content="XiaoXia">
<meta name="keywords" content="tech, C&#43;&#43;, python, study">
<meta name="description" content="">


<meta property="og:description" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="[题解] Codeforces EDU ITMO Academy: pilot course">
<meta name="twitter:title" content="[题解] Codeforces EDU ITMO Academy: pilot course">
<meta property="og:url" content="https://xiaoxiauwu.github.io/post/solution/edu_all/">
<meta property="twitter:url" content="https://xiaoxiauwu.github.io/post/solution/edu_all/">
<meta property="og:site_name" content="夏のBLOG">
<meta property="og:description" content="">
<meta name="twitter:description" content="">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2025-02-10T20:27:55">
  
  
    <meta property="article:modified_time" content="2025-02-10T20:27:55">
  
  
  
    
      <meta property="article:section" content="题解">
    
      <meta property="article:section" content="ACM">
    
  
  
    
      <meta property="article:tag" content="题解">
    
      <meta property="article:tag" content="CF">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://xiaoxiauwu.github.io/images/avatar.jpg">
  <meta property="twitter:image" content="https://xiaoxiauwu.github.io/images/avatar.jpg">




  <meta property="og:image" content="https://xiaoxiauwu.github.io/images/cover.jpg">
  <meta property="twitter:image" content="https://xiaoxiauwu.github.io/images/cover.jpg">


  <meta property="og:image" content="https://xiaoxiauwu.github.io/images/cover.jpg">
  <meta property="twitter:image" content="https://xiaoxiauwu.github.io/images/cover.jpg">


    <title>[题解] Codeforces EDU ITMO Academy: pilot course</title>

    <link rel="icon" href="https://xiaoxiauwu.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://xiaoxiauwu.github.io/post/solution/edu_all/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    
    
    <link rel="stylesheet" href="https://xiaoxiauwu.github.io/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css" />
    
    
      
        <link rel="stylesheet"  href="https://xiaoxiauwu.github.io/css/codeblock.css">
      
    

    
      
    
    


<script src="https://pagead2.googlesyndication.com/pagead/managed/js/adsense/m202401110101/show_ads_impl_fy2021.js" id="google_shimpl"></script>
<script>
      MathJax = {
         tex: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            processEscapes: true,
            tags: 'ams',
         },
      };
   </script>
<script type="text/javascript" async="" src="https://wuli.wiki/MathJax3/es5/tex-mml-chtml.js"></script>

<script async src="https://xiaoxiauwu.github.io/js/busuanzi.pure.js"></script>
  <meta name="referrer" content="no-referrer-when-downgrade"></head>


<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
<script src="https://xiaoxiauwu.github.io/js/cp.js"></script>
<link rel="stylesheet" type="text/css" href="https://xiaoxiauwu.github.io/css/copy.css" />
  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://xiaoxiauwu.github.io/" aria-label="Go to homepage">夏のBLOG</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://xiaoxiauwu.github.io/#about" aria-label="Open the link: /#about">
    
    
    
      
        <img class="header-picture" src="https://xiaoxiauwu.github.io/images/avatar.jpg" alt="Author&#39;s picture" />
      
    
    </a>
  


<div  class="meta-item">&nbsp·&nbsp
  <span id="busuanzi_container_page_pv">本文阅读量<span id="busuanzi_value_page_pv"></span>次</span>
</div>

</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://xiaoxiauwu.github.io/#about" aria-label="Read more about the author">
          <img class="sidebar-profile-picture" src="https://xiaoxiauwu.github.io/images/avatar.jpg" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">XiaoXia</h4>
        
          <h5 class="sidebar-profile-bio">憧憬着未来却虚度着当下，到头来自己也只是一片空虚吧<strong>LIVE IN THE MOMENT</strong></h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://xiaoxiauwu.github.io/" title="Home">
    
      <i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://xiaoxiauwu.github.io/categories" title="Categories">
    
      <i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://xiaoxiauwu.github.io/tags" title="Tags">
    
      <i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://xiaoxiauwu.github.io/archives" title="Archives">
    
      <i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://xiaoxiauwu.github.io/#about" title="About">
    
      <i class="sidebar-button-icon fas fa-lg fa-question" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/Xiaoxiauwu" target="_blank" rel="noopener" title="GitHub">
    
      <i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.totorocatcat.top" target="_blank" rel="noopener" title="Totoroの小窝">
    
      <i class="sidebar-button-icon fas fa-lg fa-link" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Totoroの小窝</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      
  <div class="post-header-cover
              text-center
              post-header-cover--full"
       style="background-image:url('/images/cover.jpg')"
       data-behavior="5">
    
      <div class="post-header main-content-wrap text-center">
  
    <h1 class="post-title">
      [题解] Codeforces EDU ITMO Academy: pilot course
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time datetime="2025-02-10T20:27:55&#43;08:00">
        
  February 10, 2025

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="https://xiaoxiauwu.github.io/categories/%e9%a2%98%e8%a7%a3">题解</a>, 
    
      <a class="category-link" href="https://xiaoxiauwu.github.io/categories/acm">ACM</a>
    
  

  </div>

</div>
    
  </div>


      <div id="main" data-behavior="5"
        class="hasCover
               hasCoverMetaIn
               hasCoverCaption">
        <article class="post" id="top">
          
            <span class="post-header-cover-caption caption">关于 Codeforces 的 EDU 板块中的所有题的题解</span>
          
          
          <div class="post-content markdown">
            <div class="main-content-wrap">
              <!-- raw HTML omitted -->
<p><em>注，你需要将Codeforces右上角处的语言设置切换成俄语，才能看到完整版的题单，推荐配合 Codeforces Better 翻译插件刷</em></p>
<h1 id="z-function">Z-Function</h1>
<p><em>注意参考代码中的zFunction定义，有的z[0]=n，有的z[0]=n</em></p>
<h2 id="step-1">Step 1</h2>
<h3 id="a-наидлиннейший-палиндромный-префикс---1the-idnaean-palindry-prefix---1httpscodeforcescomeducourse2lesson31practicecontest272260problema"><a href="https://codeforces.com/edu/course/2/lesson/3/1/practice/contest/272260/problem/A">A. Наидлиннейший палиндромный префикс - 1（The Idnaean Palindry Prefix - 1）</a></h3>
<h4 id="题意">题意</h4>
<p>给你一个字符串，要求你找出最长回文前缀的长度，$n \le 2000$。</p>
<h4 id="参考思路">参考思路</h4>
<p>直接将原字符串反转，拼接到原字符串后面，跑一遍 Z-Function，再从 $i = n$ 向 $i &lt; 2n$ 遍历，判断第一次出现 $z[i] \ge 2n - i$ 的下标位置即可，复杂度 $O(n)$。</p>
<h4 id="参考代码">参考代码</h4>
<pre><code class="language-cpp">auto zFunction(const std::string &amp;s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    z[0] = n;
    return z;
}

void solve() {
    std::string s;
    std::cin &gt;&gt; s;

    std::string t(s.rbegin(), s.rend());
    int n = s.size();
    s += t;

    auto z = zFunction(s);
    int ans = 1;
    for (int i = 1; i &lt;= n; i++) {
        if (z[2 * n - i] == i) ans = i;
    }

    std::cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="b-префиксный-и-суффиксные-подстроки---1prefix-and-suffix-substrates---1httpscodeforcescomeducourse2lesson31practicecontest272260problemb"><a href="https://codeforces.com/edu/course/2/lesson/3/1/practice/contest/272260/problem/B">B. Префиксный и суффиксные подстроки - 1(Prefix and suffix substrates - 1)</a></h3>
<h4 id="题意-1">题意</h4>
<p>给你一个字符串，求该字符串有多少子串，要么是前缀，要么是后缀（同时满足前缀后缀则不统计）。</p>
<h4 id="参考思路-1">参考思路</h4>
<p>考虑 $n^2$ 枚举子串左右端点，可以用 Z-Function 实现 $O(1)$ 判断前缀（即 $z[i] \ge len$）；同理，将字符串反转后跑 Z-Function 可以 $O(1)$ 判断子串是否是字符串的后缀。</p>
<h4 id="参考代码-1">参考代码</h4>
<pre><code class="language-cpp">auto zFunction(const std::string &amp;s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    z[0] = n;
    return z;
}

void solve() {
    std::string s;
    std::cin &gt;&gt; s;

    int n = s.size();

    auto z = zFunction(s);
    auto rz = zFunction(std::string(s.rbegin(), s.rend()));

    int cnt = 0;

    for (int i = 0; i &lt; n; i++) {//枚举左端点
        for (int j = i; j &lt; n; j++) {//枚举右端点
            int len = (j - i + 1);
            if ((z[i] &gt;= len) ^ (rz[n - 1 - j] &gt;= len)) {
                cnt++;
            }
        }
    }

    std::cout &lt;&lt; cnt &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="c-поиск-подстроки-в-строке-с-джокерами-в-образцеsearch-for-substrings-in-a-string-with-jokers-in-samplehttpscodeforcescomeducourse2lesson31practicecontest272260problemc"><a href="https://codeforces.com/edu/course/2/lesson/3/1/practice/contest/272260/problem/C">C. Поиск подстроки в строке с джокерами в образце(Search for substrings in a string with jokers in sample)</a></h3>
<h4 id="题意-2">题意</h4>
<p>给定文本 $t$（$|t| \le 50000$） 和模式 $p$（$|p| \le 100$）。文本由小写拉丁字母组成。模式由小写拉丁字母组成，并且可能包含 $0$ 个或更多个特殊字符 &lsquo;?&rsquo;(通配符)。通配符是模式中的一个特殊字符，它可以被视为与文本中的任何字符相等。</p>
<p>在文本中输出所有模式的出现位置。找出文本中所有这样的索引 $i$ ，使得从文本索引 $i$ 开始存在模式的出现位置。</p>
<h4 id="参考思路-2">参考思路</h4>
<p>考虑用直觉爆改 Z-Function，将 Z-Function 判断字符相等的条件改成：</p>
<pre><code class="language-cpp">(s[i + z[i]] == s[z[i]] || s[z[i]] == '?')
</code></pre>
<p>再将模式串拼到文本串前面，跑 Z-Funciton 后，$O(n)$ 在文本串枚举 $i$ 判断 $z[i] == |p|$ 即可</p>
<p><em>这种爆改Z-Function的复杂度，疑似是 O(nm) 的，如果原文本和模式串都有通配符，可以这样改：（经 Luogu P4173 验证，喜提 TLE）</em></p>
<pre><code class="language-cpp">(s[i + z[i]] == s[z[i]] || (z[i] &lt; n_ &amp;&amp; s[z[i]] == '*') || (i + z[i] &gt;= n_ &amp;&amp; s[i + z[i]] == '*'))
</code></pre>
<h4 id="参考代码-2">参考代码</h4>
<pre><code class="language-cpp">auto zFunction(const std::string &amp;s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; (s[i + z[i]] == s[z[i]] || s[z[i]] == '?'))
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    z[0] = n;
    return z;
}

void solve() {
    std::string s, t;
    std::cin &gt;&gt; s &gt;&gt; t;

    int n = s.size();
    int m = t.size();

    s = t + s;
    auto z = zFunction(s);

    std::vector&lt;int&gt; ans;

    for (int i = m; i &lt; n + m; i++) {
        if (z[i] &gt;= m) ans.push_back(i - m);
    }

    std::cout &lt;&lt; ans.size() &lt;&lt; &quot;\n&quot;;
    for (auto &amp;i : ans) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    std::cout &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="d-количество-хороших-подстрок---1number-of-good-substrates---1httpscodeforcescomeducourse2lesson31practicecontest272260problemd"><a href="https://codeforces.com/edu/course/2/lesson/3/1/practice/contest/272260/problem/D">D. Количество хороших подстрок - 1(Number of good substrates - 1)</a></h3>
<h4 id="题意-3">题意</h4>
<p>给定两个字符串 $s$ 和 $t$ 。如果字符串 $s[i \dots j]$ 的一个子字符串不包含字符串 $t$ 作为子字符串，则称该子字符串为“好”子字符串。即使内容相同，但位置不同的子字符串在 $s$ 中也应被视为不同的子字符串。换句话说，你需要找到满足以下条件的索引对 $(i,j)$ ( $i \le j$ ) 的数量：子字符串 $s[i \dots j]$ 不包含 $t$ 。</p>
<h4 id="参考思路-3">参考思路</h4>
<p>算贡献题，用字符串拼接跑 Z-Function 的方法预处理出所有 t 在 s 中的匹配位置，然后统计贡献即可。</p>
<p>初始化答案为 $ans = n(n - 1) / 2$
考虑每个匹配位置对答案的贡献，设匹配位置的左右端点为 $l, r$，则对答案的贡献为 $ans -= l * (n - r)$，然后画图理解一下不同匹配位置之间是否会互相影响，以及如何抵消掉改影响即可。</p>
<p>时间复杂度：$O(n)$</p>
<h4 id="参考代码-3">参考代码</h4>
<pre><code class="language-cpp">auto zFunction(const std::string &amp;s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    z[0] = n;
    return z;
}

void solve() {
    std::string s, t;
    std::cin &gt;&gt; s &gt;&gt; t;

    int n = s.size();
    int m = t.size();

    auto z = zFunction(t + s);

    std::vector&lt;int&gt; match;
    
    for (int i = m; i + m - 1 &lt; n + m; i++) {
        if (z[i] &gt;= m) match.push_back(i - m);
    }

    i64 ans = 1ll * n * (n + 1) / 2;

    std::vector&lt;i64&gt; r(match.size());
    
    //重点是这里的贡献处理，可以自己画个图理解一下怎么抵消的贡献
    for (int i = 0; i &lt; match.size(); i++) {
        int r_ = n - (match[i] + m - 1);
        for (int j = i; j &gt;= std::max(0, i - 1); j--) {
            ans -= (match[j] + 1) * r_;
            r_ = -r_;
        }
    }

    std::cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h2 id="step-2">Step 2</h2>
<h3 id="a-z-функция-простая-версияz-function-simple-versionhttpscodeforcescomeducourse2lesson32practicecontest272261problema"><a href="https://codeforces.com/edu/course/2/lesson/3/2/practice/contest/272261/problem/A">A. Z-функция (простая версия)(Z-function (simple version))</a></h3>
<p>n 方实现 Z-Function， 板子题，不讲</p>
<h3 id="b-z-функция-строки-греяz-function-line-of-grayhttpscodeforcescomeducourse2lesson32practicecontest272261problemb"><a href="https://codeforces.com/edu/course/2/lesson/3/2/practice/contest/272261/problem/B">B. Z-функция строки Грея(Z-function line of Gray)</a></h3>
<h4 id="题意-4">题意</h4>
<p>格雷码字符串序列 $g_1, g_2, \dots$ 如下所示：</p>
<ul>
<li>$g_1$ = “a”</li>
<li>$g_2$ = “aba”</li>
<li>$g_3$ = “abacaba”</li>
<li>$g_4$ = “abacabadabacaba”</li>
<li>&hellip;</li>
<li>$g_i$ = $g_{i-1} + c_i + g_{i-1}$ , 其中 $c_i$ 是字母表中的第 $i$ 个字符</li>
<li>&hellip;</li>
</ul>
<p>需要注意的是，格雷码的长度增长非常快(第 $i$ 行的长度为 $2^i - 1$)，但它们具有规律的分形结构。</p>
<p>格雷码经常被用来分析字符串算法的运作。</p>
<p>在这个任务中，你需要根据给定的格雷码字符串索引 $k$ 和数字 $j$ ，输出 $z_j$ - 在索引 $j$ 处的字符串 $g_k$ 的 z 函数值。</p>
<h4 id="参考思路-4">参考思路</h4>
<p>打表找规律，然后写个递归即可。</p>
<p>当 $k = 4$ 时，Z-Function打表结果如下：</p>
<pre><code>0 1 0 3 0 1 0 7 0 1 0 3 0 1 0
</code></pre>
<p>结论是，区间长度按照 $1, 3, 7, &hellip;$ 的形式递增，递归向下搜，如果 $j$ 位于区间中点，那么搜索结束，直接输出区间长度除2，否则将区间切成两块更新 j 为到区间左端点的距离，继续往下递归即可。</p>
<h4 id="参考代码-4">参考代码</h4>
<pre><code class="language-cpp">int dfs(int n, int i) {
    if ((n + 1) / 2 == i) return n / 2;
    return dfs(n / 2, i % ((n + 1) / 2));
}

void solve() {
    int k, j;
    std::cin &gt;&gt; k &gt;&gt; j;

    if (j == 0) {
        std::cout &lt;&lt; 0 &lt;&lt; &quot;\n&quot;;
        return;
    }

    std::cout &lt;&lt; dfs((1 &lt;&lt; k) - 1, j) &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="c-строка-по-z-функцииline-by-z-functionhttpscodeforcescomeducourse2lesson32practicecontest272261problemc"><a href="https://codeforces.com/edu/course/2/lesson/3/2/practice/contest/272261/problem/C">C. Строка по z-функции(Line by z-function)</a></h3>
<h4 id="题意-5">题意</h4>
<p>给定一个长度为 $n$ ( $1 \le n \le 50$ ) 的整数数组 $z$ ，数组中的元素取值范围为 $0$ 到 $50$ 。请判断是否存在一个字符串 $s$ ，其 z 函数值为 $z$ 。如果存在，请输出任意一个这样的字符串。字符串 $s$ 可以使用大小写英文字母。</p>
<h4 id="参考思路-5">参考思路</h4>
<p>先做点特判，比如 $z[0] == 0$ 且 $z[i] \le (n - i)$。</p>
<p>然后暴力初始化原串为 $n$ 个不同的字符，最后按照 Z-Function 定义暴力 $O(n^2)$ 更新原字符串。对处理出的字符串跑一遍 Z Function 验证一下即可。</p>
<h4 id="参考代码-5">参考代码</h4>
<pre><code class="language-cpp">//预处理
std::vector&lt;char&gt; mp;
for (char c = 'a'; c &lt;= 'z'; c++) {
    mp.push_back(c);
}
for (char c = 'A'; c &lt;= 'Z'; c++) {
    mp.push_back(c);
}

void solve() {
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; z(n);
    for (auto &amp;i : z) std::cin &gt;&gt; i;

    if (z[0] != 0) {
        std::cout &lt;&lt; &quot;!\n&quot;;
        return;
    }

    for (int i = 1; i &lt; n; i++) {
        if (z[i] &gt; (n - i)) {
            std::cout &lt;&lt; &quot;!\n&quot;;
            return;
        }
    }

    std::string ans(n, 'a');
    for (int i = 0; i &lt; n; i++) {
        ans[i] = mp[i];
    }

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; z[i]; j++) {
            ans[i + j] = ans[j];
        }
    }

    auto z_ = zFunction(ans);

    if (z == z_) {
        std::cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    } else {
        std::cout &lt;&lt; &quot;!\n&quot;;
    }
}
</code></pre>
<h2 id="step-3">Step 3</h2>
<h3 id="a-z-функцияz-functionhttpscodeforcescomeducourse2lesson33practicecontest272263problema"><a href="https://codeforces.com/edu/course/2/lesson/3/3/practice/contest/272263/problem/A">A. Z-функция(Z-function)</a></h3>
<p>Z-Function 板子题，不讲</p>
<h2 id="step-4">Step 4</h2>
<h3 id="a-минимальный-период-строкиminimum-line-periodhttpscodeforcescomeducourse2lesson34practicecontest272262problema"><a href="https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/A">A. Минимальный период строки(Minimum line period)</a></h3>
<h4 id="题意-6">题意</h4>
<p>用字符串的 z 函数来解决这个问题。有很多方法可以解决这个问题，但作为使用 z 函数的练习，请尝试提出并实现这样一个解决方案。</p>
<p>在这个问题中，如果重复无数次的字符串 $p$ 的前缀是 $s$ ，那么字符串 $p$ 就叫做字符串 $s$ 的周期。换句话说，如果 $pp \dots p \dots$ 以 $s$ 开头。</p>
<p>您的任务是找到这样一个字符串 $p$ ，它是给定字符串 $s$ 的最短周期。例如， $s$ =abcab 的最短周期是 $p$ =abc。</p>
<h4 id="参考思路-6">参考思路</h4>
<p>z-Function 板子题，跑一遍 zFunction 后，从前往后枚举 $i$，找到第一次出现 $z[i] == n - i$ 的位置，截断并输出字符串即可，如果均找不到，输出整个字符串。</p>
<h4 id="参考代码-6">参考代码</h4>
<pre><code class="language-cpp">std::vector&lt;int&gt; zFunction(const std::string &amp;s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    z[0] = n;
    return z;
}

void solve() {
    std::string s;
    std::cin &gt;&gt; s;

    auto z = zFunction(s);
    int n = s.size();
    for (int i = 1; i &lt; n; i++) {
        if (z[i] == n - i) {
            std::cout &lt;&lt; s.substr(0, i) &lt;&lt; &quot;\n&quot;;
            return;
        }
    }

    std::cout &lt;&lt; s &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="b-циклические-сдвигиcyclical-shiftshttpscodeforcescomeducourse2lesson34practicecontest272262problemb"><a href="https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/B">B. Циклические сдвиги(Cyclical shifts)</a></h3>
<h4 id="题意-7">题意</h4>
<p>用字符串的 z 函数来解决这个问题。有很多方法可以解决这个问题，但作为使用 z 函数的练习，请尝试提出并实现这样一个解决方案。</p>
<p>给出长度为 $n$ 的字符串 $s$ 。它的循环左移值 $k$ ( $0 \le k &lt; n$ ) 称为形式为 $s_{k}s_{k+1} \dots s_{n-1}s_{0}s_{1} \dots s_{k-1}$ 的字符串 $t$ 。</p>
<p>下面给出两个长度相同的字符串 $s$ 和 $t$ 。我们需要检查 $t$ 是否是 $s$ 的循环移位。如果是，请根据上述定义打印相应的 $k$ 。</p>
<h4 id="参考思路-7">参考思路</h4>
<p>考虑字符串拼接：$s + t + t$，然后对拼接后的字符串跑一遍 z-Function，最后暴力从 $n$ 到 $2 * n$ 枚举 $i$，判断 是否出现过 $z[i] \ge n$ 即可。复杂度 $O(n)$</p>
<h4 id="参考代码-7">参考代码</h4>
<pre><code class="language-cpp">std::vector&lt;int&gt; zFunction(const std::string &amp;s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    z[0] = n;
    return z;
}

void solve() {
    std::string s, t;
    std::cin &gt;&gt; s &gt;&gt; t;

    int n = s.size();
    t = s + t + t;
    auto z = zFunction(t);

    for (int i = n; i &lt; n + n; i++) {
        if (z[i] &gt;= n) {
            std::cout &lt;&lt; (2 * n - i) % n &lt;&lt; &quot;\n&quot;;
            return;
        }
    }

    std::cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="c-вхождения-префиксовentry-of-prefixeshttpscodeforcescomeducourse2lesson34practicecontest272262problemc"><a href="https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/C">C. Вхождения префиксов(Entry of prefixes)</a></h3>
<h4 id="题意-8">题意</h4>
<p>用字符串的 z 函数来解决这个问题。有很多方法可以解决这个问题，但作为使用 z 函数的练习，请尝试提出并实现这样一个解决方案。</p>
<p>给出字符串 s。从 1 到 |s| 的每个 i 求其长度为 i 的前缀在字符串中出现的次数。</p>
<h4 id="参考思路-8">参考思路</h4>
<p>对原字符串跑一遍 z Function，然后枚举 $z[i]$，维护一个差分数组 pre[0]++，pre[z[i]]&ndash;，最后前缀和计数即可。复杂度 $O(n)$</p>
<h4 id="参考代码-8">参考代码</h4>
<pre><code class="language-cpp">std::vector&lt;int&gt; zFunction(const std::string &amp;s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    z[0] = n;
    return z;
}

void solve() {
    std::string s;
    std::cin &gt;&gt; s;

    int n = s.size();

    std::vector&lt;int&gt; pre(n + 1);

    for (auto &amp;i : zFunction(s)) {
        pre[0]++; pre[i]--;
    }

    std::partial_sum(pre.begin(), pre.end(), pre.begin());

    for (int i = 0; i &lt; n; i++) std::cout &lt;&lt; pre[i] &lt;&lt; &quot; &quot;;
    std::cout &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="d-палиндромный-префиксpalinthic-prefixhttpscodeforcescomeducourse2lesson34practicecontest272262problemd"><a href="https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/D">D. Палиндромный префикс(Palinthic prefix)</a></h3>
<h4 id="题意-9">题意</h4>
<p>用字符串的 z 函数来解决这个问题。有很多方法可以解决这个问题，但作为使用 z 函数的练习，请尝试提出并实现这样一个解决方案。</p>
<p>给出字符串 $s$ 。求其最长前缀的长度，它是一个回文。</p>
<h4 id="参考思路-9">参考思路</h4>
<p>考虑如下字符串拼接：s 和 自身反串拼接，然后跑一遍 zFunction，枚举下标更新最长答案即可。</p>
<h4 id="参考代码-9">参考代码</h4>
<pre><code class="language-cpp">auto zFunction(const std::string &amp;s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    z[0] = n;
    return z;
}

void solve() {
    std::string s;
    std::cin &gt;&gt; s;

    std::string t(s.rbegin(), s.rend());
    int n = s.size();
    s += t;

    auto z = zFunction(s);
    int ans = 1;
    for (int i = 1; i &lt;= n; i++) {
        if (z[2 * n - i] == i) ans = i;
    }

    std::cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="e-странная-операцияstrange-operationhttpscodeforcescomeducourse2lesson34practicecontest272262probleme"><a href="https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/E">E. Странная операция(Strange operation)</a></h3>
<h4 id="题意-10">题意</h4>
<p>对于给定的字符串 $s = s_{1} s_{2} \dots s_{n}$ 来说，有效的操作包括以下步骤：</p>
<ul>
<li>从 $0$ 到 $n$ 之间(包括首尾)选择一个整数 $k$ ；</li>
<li>删除前 $k$ 个字符，但以相反的顺序将它们添加到字符串的末尾：即 $s$ 的形式为 $s_{k+1}\dots s_{n}~s_{k}~s_{k-1}~\dots s_{1}$ 。</li>
</ul>
<p>有两个字符串 $s$ 和 $t$ 。检查是否有一种操作能使 $s$ 等于 $t$ 。操作只能进行一次。</p>
<h4 id="参考思路-10">参考思路</h4>
<p>先预处理判断字符串长度是否相等。</p>
<p>考虑字符串拼接：r = t + s，然后跑一遍 Z-Function，从中间开始向后枚举下标，在第一次出现 $r[n + i] != r[n - 1 - i]$ 前 判断是否存在匹配：$z[n + i] == n - i$ 即可。</p>
<h4 id="参考代码-10">参考代码</h4>
<pre><code class="language-cpp">auto zFunction(const std::string &amp;s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    z[0] = n;
    return z;
}

void solve() {
    std::string s, t;
    std::cin &gt;&gt; s &gt;&gt; t;

    if (s.size() != t.size()) {
        std::cout &lt;&lt; &quot;No&quot;;
        return;
    }

    int n = s.size();

    auto r = t + s;
    auto z = zFunction(r);

    for (int i = 0; i &lt; n; i++) {
        if (z[n + i] == n - i) {
            std::cout &lt;&lt; &quot;Yes\n&quot; &lt;&lt; i;
            return; 
        }

        if (r[n + i] != r[n - 1 - i]) {
            std::cout &lt;&lt; &quot;No&quot;;
            return;
        }
    }
}
</code></pre>
<h3 id="f-кратчайшая-надстрокаthe-shortest-superstructurehttpscodeforcescomeducourse2lesson34practicecontest272262problemf"><a href="https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/F">F. Кратчайшая надстрока(The shortest superstructure)</a></h3>
<h4 id="题意-11">题意</h4>
<p>用字符串的 z 函数来解决这个问题。有很多方法可以解决这个问题，但作为使用 z 函数的练习，请尝试提出并实现这样一个解决方案。</p>
<p>给出两个字符串 $s$ 和 $t$ 。输出包含 $s$ 和 $t$ 两个子串的最短字符串 $r$ 。</p>
<h4 id="参考思路-11">参考思路</h4>
<p>分别考虑 s + t 和 t + s，分别跑一遍 zFunction，由于正反操作一样，不妨先考虑 s + t，先判断 s 是否 直接出现在 t串中，若出现，则直接返回 t；否则从拼接位置开始向后遍历，判断第一次出现 $z[i] == n + m - i$ 时，直接返回 $t + s.substr(z[i])$ 即可；否则直接返回 t + s。对t + s，操作相同，所以封装一个函数，分便对两种拼接跑一遍答案，比较长度并输出即可。</p>
<p>直接看代码可能好理解一点</p>
<h4 id="参考代码-11">参考代码</h4>
<pre><code class="language-cpp">auto zFunction(const std::string &amp;s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    z[0] = n;
    return z;
}

void solve() {
    std::string s, t;
    std::cin &gt;&gt; s &gt;&gt; t;

    auto work = [&amp;](std::string a, std::string b) -&gt; std::string {
        int n = a.size();
        int m = b.size();
        auto s = a + b;
        auto z = zFunction(s);

        for (int i = n; i &lt; n + m; i++) {
            if (z[i] &gt;= n) {
                return b;
            }
        }

        for (int i = n; i &lt; n + m; i++) {
            if (z[i] == n + m - i) {
                return b + a.substr(z[i]);
            }
        }

        return b + a;
    };

    auto ans1 = work(s, t);
    auto ans2 = work(t, s);

    std::cout &lt;&lt; (ans1.size() &lt; ans2.size() ? ans1 : ans2) &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="g-кубикиcubequetshttpscodeforcescomeducourse2lesson34practicecontest272262problemg"><a href="https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/G">G. Кубики(Cubequets)</a></h3>
<h4 id="题意-12">题意</h4>
<p>用字符串的 z 函数来解决这个问题。有很多方法可以解决这个问题，但作为使用 z 函数的练习，请尝试提出并实现这样一个解决方案。</p>
<p>幽灵 Petya 喜欢玩他的方块。他喜欢把它们摆成一排，看着自己的作品。不过，最近他的朋友们决定和 Petya 开个玩笑，在他的游戏室里放了一面镜子。毕竟，每个人都知道镜子里是照不出鬼的！但是立方体可以。</p>
<p>现在，彼佳看到了 $n$ 个彩色方块，但他不知道哪些是真的，哪些只是镜子里的倒影。帮助彼佳！找出 Petya 可以拥有多少个立方体。Petya 看到了镜子中所有立方体的倒影，以及立方体在他面前的部分。有些立方体可能在 Petya 的后面，但他看不到。</p>
<p><img src="https://espresso.codeforces.com/debda0a7ae9e5168be4c9ab9eea61a6f67a3fc97.png" alt=""></p>
<h4 id="参考思路-12">参考思路</h4>
<p>研究一下样例会发现，这题实际上等价于求所有偶数长度的前缀回文串。考虑字符串拼接：s + 自身反串，然后跑一遍 Z-Function，最后枚举下标找回文串即可</p>
<h4 id="参考代码-12">参考代码</h4>
<pre><code class="language-cpp">auto zFunction(const auto&amp; s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    z[0] = n;
    return z;
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;int&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    auto a_ = a;
    a_.reserve(2 * n);
    std::reverse(a.begin(), a.end());
    for (auto &amp;i : a) a_.push_back(i);

    std::vector&lt;int&gt; ans;
    ans.reserve(n);

    auto z = zFunction(a_);
    for (int i = n; i &lt; 2 * n; i++) {
        if (z[i] % 2 == 0 &amp;&amp; z[i] == 2 * n - i) {
            ans.push_back(n - z[i] / 2);
        }
    }

    ans.push_back(n);

    for (auto &amp;i : ans) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
}
</code></pre>
<h3 id="h-сумма-длин-различных-подстрокthe-amount-of-lengths-of-different-substringshttpscodeforcescomeducourse2lesson34practicecontest272262problemh"><a href="https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/H">H. Сумма длин различных подстрок(The amount of lengths of different substrings)</a></h3>
<h4 id="题意-13">题意</h4>
<p>用字符串的 z 函数来解决这个问题。有很多方法可以解决这个问题，但作为使用 z 函数的练习，请尝试提出并实现这样一个解决方案。</p>
<p>给出字符串 $s$。输出该字符串所有可能的不同子串的总长度。</p>
<h4 id="参考思路-13">参考思路</h4>
<p>先考虑所有位置的字符均不相等的字符串的贡献是多少：$ans = \sum_{i = 1}^n\sum_{j = i}^nj - i = \sum_{i = 1}^{n} \frac{i(i + 1)}{2}$</p>
<p>再考虑如果出现子串相同的情况，那么如何抵消重复的贡献。</p>
<p>不难发现，我们可以利用 SA数组 的思想，先将字符串所有的后缀提出来，排序后暴力求字典序相邻后缀的lcp，最后令 $ans = ans - \sum|lcp_i|(|lcp_i| + 1) / 2$ 即可。</p>
<p>（感觉，似乎用不上 Z-Function，如果直接上 SA数组，可以做到$O(n)$ 的复杂度）</p>
<p>复杂度：$O(n^2)$</p>
<h4 id="参考代码-13">参考代码</h4>
<pre><code class="language-cpp">auto zFunction(const auto&amp; s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    //z[0] = n;
    return z;
}

i64 sum(i64 x) {
    return x * (x + 1) / 2;
}

void solve() {
    std::string s;
    std::cin &gt;&gt; s;

    int n = s.size();

    std::vector&lt;i64&gt; pre(n + 1);
    for (int i = 1; i &lt;= n; i++) {
        pre[i] = sum(i);
    }

    std::partial_sum(pre.begin(), pre.end(), pre.begin());

    i64 ans = pre[n];

    std::vector&lt;std::string&gt; t;
    for (int i = 0; i &lt; n; i++) {
        t.push_back(s.substr(i));
    }

    std::sort(t.begin(), t.end());

    for (int i = 1; i &lt; n; i++) {
        auto z = zFunction(t[i - 1] + t[i]);
        ans -= sum(std::min&lt;int&gt;(t[i - 1].size(), z[t[i - 1].size()]));
    }

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="i-неточный-поискinaccurate-searchhttpscodeforcescomeducourse2lesson34practicecontest272262problemi"><a href="https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/I">I. Неточный поиск(Inaccurate search)</a></h3>
<h4 id="题意-14">题意</h4>
<p>使用字符串的z函数来解决这个问题。有很多方法可以解决这个问题，但作为z函数的练习，请尝试设计并实现这样的解决方案。</p>
<p>给出文本 $t = t_{1}~t_{2}~\dots~t_{|t|}$ 和样本 $p = p_{1}~p_{2}~\dots~p_{|p|}$ 。此外，还设置了参数 $k$ 。</p>
<p>如果 $t[d~\dots~d + |p| - 1] = p$ 对 $d$ 是正确的，那么 $t$ 和 $d$ 有一个精确的条目 $p$ 。</p>
<p>对于索引 $d$ ，在 $t[d~\dots~d + |p| - 1]$ 子字符串中有一个 $f$ 字符的窗口，在这个窗口中可以更改 $0$ 或更多字符，这样(但窗口长度保持不变)子字符串 $t[d~\dots~d + |p| - 1]$ 等于 $p$ ，同时 $f \le k$ ，在这种情况下，样本输入不准确。很明显，确切的输入是一个不准确的私人案例。</p>
<p>例如，如果 $k = 3$ ， $t$ = &quot; abacabadabacaba “和 $p$ = ” baxayad &ldquo;，那么索引 $2$ 就有一个不准确的条目(注意，在这个问题中，所有的索引都是从 $1$ 开始编号的)。</p>
<p>您的任务是查找文本 $t$ 中样本 $p$ 的所有不准确输入。</p>
<h4 id="参考思路-14">参考思路</h4>
<p>先特判字符串长度，$|s| &lt; |t|$ 则无解；再特判 $k &gt; |t|$，则任意位置均可匹配。</p>
<p>考虑字符串拼接 : t + s 和 t反转 + s反转，分别跑一遍 Z-Function 得到 z 和 rz 数组，最后双指针匹配即可。复杂度 $O(n + m)$</p>
<p><em>直接看代码实现更好理解一点</em></p>
<h4 id="参考代码-14">参考代码</h4>
<pre><code class="language-cpp">auto zFunction(const auto&amp; s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    //z[0] = n;
    return z;
}

void solve() {
    std::string s, t;
    std::cin &gt;&gt; s &gt;&gt; t;
    int k;
    std::cin &gt;&gt; k;

    if (s.size() &lt; t.size()) {
        std::cout &lt;&lt; 0 &lt;&lt; &quot;\n&quot;;
        return;
    }

    if (k &gt;= t.size()) {
        std::cout &lt;&lt; s.size() - t.size() + 1 &lt;&lt; &quot;\n&quot;;
        for (int i = 0; i &lt;= s.size() - t.size(); i++) {
            std::cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;;
        }
        return;
    }

    std::vector&lt;int&gt; ans;

    auto z = zFunction(t + s);
    auto rz = zFunction(std::string(t.rbegin(), t.rend()) + std::string(s.rbegin(), s.rend()));

    int i = 0, j = s.size() - t.size();
    while (t.size() + i &lt;= s.size()) {
        if (z[t.size() + i] + rz[t.size() + j] + k &gt;= t.size()) {
            ans.push_back(i + 1);
        }
        i++; j--;
    }

    std::cout &lt;&lt; ans.size() &lt;&lt; &quot;\n&quot;;
    for (auto &amp;i : ans) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
}
</code></pre>
<h3 id="j-циклические-суффиксыcyclical-suffixeshttpscodeforcescomeducourse2lesson34practicecontest272262problemj"><a href="https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/J">J. Циклические суффиксы(Cyclical suffixes)</a></h3>
<h4 id="题意-15">题意</h4>
<p>用字符串的 z 函数来解决这个问题。有很多方法可以解决这个问题，但作为使用 z 函数的练习，请尝试提出并实现这样一个解决方案。</p>
<p>考虑字母表 $\Sigma$ 上的字符串 $s = s_1 s_2 s_3 \dots s_{n - 1} s_n$ 。让我们把 $s$ 字符串的 $m$ 阶循环扩展称为由 $m$ 个字符组成的 $s_1 s_2 s_3 &hellip; s_{n - 1} s_n s_1 s_2 &hellip;$ 形式的字符串；这意味着我们将 $s$ 字符串追加到自身，直到得到所需的长度，然后取长度前缀 $m$ 。</p>
<p>我们将循环字符串 $\tilde s$ 称为字符串 $s$ 的无限循环扩展。</p>
<p>让我们考虑循环字符串 $\tilde s$ 的后缀。显然，最多有 $|s|$ 个不同的后缀： $(n + 1)$ (第一个后缀匹配第一个后缀)， $(n + 2)$ (第二个后缀匹配第二个后缀)，以此类推。此外，不同的后缀可能更少。例如，如果 $S = {abab}$ ，循环字符串 $\tilde s$ 的前四个后缀是：</p>
<ul>
<li>$\tilde s_1 = {ababababab} &hellip;$</li>
<li>$\tilde s_2 = {bababababa} &hellip;$</li>
<li>$\tilde s_3 = {ababababab} &hellip;$</li>
<li>$\tilde s_4 = {bababababa} &hellip;$</li>
</ul>
<p>这里只有两个不同的后缀，而 $|s| = 4$ .</p>
<p>让我们对 $\tilde s$ 的前 $|s|$ 个后缀按词性排序。如果两个后缀相匹配，我们将把索引较小的后缀放在前面。现在，我们对以下问题感兴趣：字符串 $\tilde s$ 本身在这个列表中处于什么位置？</p>
<p>例如，考虑字符串 $S = {cabcab}$ ：</p>
<ol>
<li>$\tilde s_2 = {abcabcabca} &hellip;$</li>
<li>$\tilde s_5 = {abcabcabca} &hellip;$</li>
<li>$\tilde s_3 = {bcabcabcab} &hellip;$</li>
<li>$\tilde s_6 = {bcabcabcab} &hellip;$</li>
<li>$\tilde s_1 = {cabcabcabc} &hellip;$</li>
<li>$\tilde s_4 = {cabcabcabc} &hellip;$</li>
</ol>
<p>这里循环字符串 $\tilde s = \tilde S_1$ 位于第五位。</p>
<p>给您的是字符串 $s$ 。您的任务是找出循环字符串 $\tilde s$ 在所述顺序中的位置。</p>
<h4 id="参考思路-15">参考思路</h4>
<p>先对原串求一遍Z-Function，然后枚举z[i]，跳lcp（即z[i]，也就是后缀 i 和后缀 0的lcp）做字符比较即可，复杂度 $O(n)$。</p>
<p><em>直接看代码可能会更好理解</em></p>
<h4 id="参考代码-15">参考代码</h4>
<pre><code class="language-cpp">auto zFunction(const auto&amp; s) {
    int n = s.size();
    std::vector&lt;int&gt; z(n);
    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
        if (i &lt; r)
            z[i] = std::min(z[i - l], r - i);
        while (i + z[i] &lt; n &amp;&amp; s[i + z[i]] == s[z[i]])
            z[i]++;
        if (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    z[0] = n;
    return z;
}

void solve() {
    std::string s;
    std::cin &gt;&gt; s;

    int n = s.size();

    s += s;
    auto z = zFunction(s);

    int cnt = 1;
    for (int i = 0; i &lt; n; i++) {
        cnt += (z[i] == 2 * n - i ? false : (s[z[i]] &gt; s[i + z[i]]));
    }

    std::cout &lt;&lt; cnt;
}
</code></pre>
<h1 id="suffix-array">Suffix array</h1>
<h2 id="step-1-1">Step 1</h2>
<h3 id="a-suffix-array---1httpscodeforcescomeducourse2lesson21practicecontest269100problema"><a href="https://codeforces.com/edu/course/2/lesson/2/1/practice/contest/269100/problem/A">A. Suffix Array - 1</a></h3>
<p>SA数组 板子题，不讲</p>
<p>但由于 SA 码量略大，为不影响阅读，我先放个板子在这吧，后面的代码中的 <strong>SA</strong> 均指此板子。</p>
<pre><code class="language-cpp">struct SA {
    int n;
    std::vector&lt;int&gt; sa, rk, lc;
    std::vector&lt;std::vector&lt;int&gt;&gt; st;

    SA(std::string s) : n(s.size()), sa(n), rk(n), lc(n), st(std::__lg(n) + 1, std::vector&lt;int&gt;(n + 1)) {
        std::iota(sa.begin(), sa.end(), 0);
        std::sort(sa.begin(), sa.end(),
            [&amp;](int a, int b) {
                return s[a] &lt; s[b];
            });
        rk[sa[0]] = 0;
        for (int i = 1; i &lt; n; i++) {
            rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);
        }
        int k = 1;
        std::vector&lt;int&gt; tmp, cnt(n);
        tmp.reserve(n);
        while (rk[sa[n - 1]] &lt; n - 1) {
            tmp.clear();
            for (int i = 0; i &lt; k; i++) {
                tmp.push_back(n - k + i);
            }
            for (auto i : sa) {
                if (i &gt;= k) {
                    tmp.push_back(i - k);
                }
            }
            std::fill(cnt.begin(), cnt.end(), 0);
            for (int i = 0; i &lt; n; i++) {
                cnt[rk[i]]++;
            }
            for (int i = 1; i &lt; n; i++) {
                cnt[i] += cnt[i - 1];
            }
            for (int i = n - 1; i &gt;= 0; i--) {
                sa[--cnt[rk[tmp[i]]]] = tmp[i];
            }
            std::swap(rk, tmp);
            rk[sa[0]] = 0;
            for (int i = 1; i &lt; n; i++) {
                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] &lt; tmp[sa[i]] || sa[i - 1] + k == n || tmp[sa[i - 1] + k] &lt; tmp[sa[i] + k]);
            }
            k *= 2;
        }

        for (int i = 0, j = 0; i &lt; n; i++) {
            if (rk[i] == 0) {
                j = 0;
            } else {
                for (j -= j &gt; 0; i + j &lt; n &amp;&amp; sa[rk[i] - 1] + j &lt; n &amp;&amp; s[i + j] == s[sa[rk[i] - 1] + j]; ) {
                    j++;
                }
                lc[rk[i]] = j;
            }
        }

        st[0] = lc;
        for (int j = 0; j &lt; std::__lg(n); j++) {
            for (int i = 0, m = n - (1 &lt;&lt; j + 1); i &lt;= m; i++) {
                st[j + 1][i] = std::min(st[j][i], st[j][i + (1 &lt;&lt; j)]);
            }
        }
    }

    int lcp(int x, int y) {
        if (x == y) return n - x;
        x = rk[x]; y = rk[y];
        if (x &gt; y) std::swap(x, y);
        ++x;
        int z = std::__lg(y - x + 1);
        return std::min(st[z][x], st[z][y - (1 &lt;&lt; z) + 1]);
    }
};
</code></pre>
<h2 id="step-2-1">Step 2</h2>
<h3 id="a-suffix-array---2httpscodeforcescomeducourse2lesson22practicecontest269103problema"><a href="https://codeforces.com/edu/course/2/lesson/2/2/practice/contest/269103/problem/A">A. Suffix Array - 2</a></h3>
<p>SA数组板子题，不讲</p>
<h2 id="step-3-1">Step 3</h2>
<h3 id="a-substring-searchhttpscodeforcescomeducourse2lesson23practicecontest269118problema"><a href="https://codeforces.com/edu/course/2/lesson/2/3/practice/contest/269118/problem/A">A. Substring Search</a></h3>
<h4 id="题意-16">题意</h4>
<p>给定一个字符串 $t$ 和 $n$ 查询，每个查询都是一个字符串 $s_i$ 。对于每个请求，你都需要确定字符串 $s_i$ 是否作为子串出现在 $t$ 中。</p>
<h4 id="参考思路-16">参考思路</h4>
<p>对原始串 t 求SA数组，然后每次询问在sa数组上二分出询问串的 rank，最后判断询问串是否存在即可。复杂度 $O(\sum|s|\log|t|)$</p>
<h4 id="参考代码-16">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    std::string s;
    std::cin &gt;&gt; s;

    int n = s.size();

    SA sa(s);

    int q;
    std::cin &gt;&gt; q;
    while (q--) {
        std::string p;
        std::cin &gt;&gt; p;

        if (p.size() &gt; s.size()) {
           std::cout &lt;&lt; &quot;No\n&quot;;
           continue;
        }

        auto check_low = [&amp;](int j) -&gt; bool {
            for (int i = 0; i &lt; std::min&lt;int&gt;(n - j, p.size()); i++) {
                if (p[i] != s[j + i]) {
                    return s[j + i] &lt; p[i];
                }
            }
            return n - j &lt;= p.size();
        };

        int l = 0, r = n - 1;
        while (l &lt;= r) {
            int mid = (l + r) / 2;
            if (mid &gt;= n || mid &lt; 0) break;

            if (check_low(sa.sa[mid])) {//s.substr(sa.sa[mid]) &lt;= p
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }

        auto ck = [&amp;](int i) -&gt; bool {
            if (i &gt;= n || i &lt; 0) {
                return 0;
            }

            auto t = s.substr(sa.sa[i]);
            if (t.size() &lt; p.size() || t.substr(0, p.size()) != p) {
                return 0;
            } else {
                return 1;
            }            
        };

        bool ans = 0;
        for (int i = l - 1; i &lt;= l; i++) ans |= ck(i);

        std::cout &lt;&lt; (ans ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="b-counting-substringshttpscodeforcescomeducourse2lesson23practicecontest269118problemb"><a href="https://codeforces.com/edu/course/2/lesson/2/3/practice/contest/269118/problem/B">B. Counting Substrings</a></h3>
<h4 id="题意-17">题意</h4>
<p>给定一个字符串 $t$ 和 $n$ 查询，每个查询都是一个字符串 $s_i$ 。对于每个查询，你需要计算字符串 $s_i$ 作为子串出现在 $t$ 中的次数。</p>
<h4 id="参考思路-17">参考思路</h4>
<p>我们直接在sa数组上分别二分出，第一个字典序大于询问串的位置 $i$，以及第一个字典序小于等于询问串的位置 $j$，那么答案就是 $i - j + 1$（差不多这个思路，具体细节自己品）</p>
<h4 id="参考代码-17">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    std::string s;
    std::cin &gt;&gt; s;  

    int n = s.size();

    SA sa(s);

    int q;
    std::cin &gt;&gt; q;
    while (q--) {
        std::string p;
        std::cin &gt;&gt; p;

        if (p.size() &gt; s.size()) {
           std::cout &lt;&lt; &quot;0\n&quot;;
           continue;
        }

        auto check_lower = [&amp;](int j) -&gt; bool {
            for (int i = 0; i &lt; std::min&lt;int&gt;(n - j, p.size()); i++) {
                if (p[i] != s[j + i]) {
                    return s[j + i] &gt; p[i];
                }
            }
            return n - j &gt;= p.size();
        };

        auto check_upper = [&amp;](int j) -&gt; bool {
            for (int i = 0; i &lt; std::min&lt;int&gt;(n - j, p.size()); i++) {
                if (p[i] != s[j + i]) {
                    return s[j + i] &lt; p[i];
                }
            }
            return n - j &lt; p.size();
        };

        auto get_lower = [&amp;]() -&gt; int {
            int l = 0, r = n - 1;
            while (l &lt;= r) {
                int mid = (l + r) / 2;
                if (mid &gt;= n || mid &lt; 0) break;

                if (check_lower(sa.sa[mid])) {//s.substr(sa.sa[mid]) &gt;= p
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }

            return r + 1;
        };

        auto get_upper = [&amp;]() -&gt; int {
            int l = 0, r = n - 1;
            while (l &lt;= r) {
                int mid = (l + r) / 2;
                if (mid &gt;= n || mid &lt; 0) break;

                if (check_upper(sa.sa[mid])) {//s.substr(sa.sa[mid]) &lt;= p
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }

            return l - 1;
        };

        p.back()++;
        int up = get_upper();
        p.back()--;
        int lo = get_lower();

        std::cout &lt;&lt; up - lo + 1 &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h2 id="step-4-1">Step 4</h2>
<h3 id="a-suffix-array-and-lcphttpscodeforcescomeducourse2lesson24practicecontest269119problema"><a href="https://codeforces.com/edu/course/2/lesson/2/4/practice/contest/269119/problem/A">A. Suffix Array and LCP</a></h3>
<h4 id="题意-18">题意</h4>
<p>为给定的字符串 $s$ 建立一个后缀数组，为每两个相邻的后缀找出最长公共前缀的长度。</p>
<h4 id="参考思路-18">参考思路</h4>
<p>SA数组板子题，前面的板子里面的 lc 数组即为所求（下标从 1 开始）。</p>
<h2 id="step-5">Step 5</h2>
<h3 id="a-number-of-different-substringshttpscodeforcescomeducourse2lesson25practicecontest269656problema"><a href="https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/A">A. Number of Different Substrings</a></h3>
<h4 id="题意-19">题意</h4>
<p>计算给定字符串 $s$ 的不同子串的个数。</p>
<h4 id="参考思路-19">参考思路</h4>
<p>考虑求出SA数组中的lc数组。然后枚举 i，统计 $(n - sa[i]) - lc[i]$ 即可。</p>
<h4 id="参考代码-18">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    std::string s;
    std::cin &gt;&gt; s;
    SA sa(s);

    int n = s.size();

    i64 ans = 0;
    for (int i = 0; i &lt; n; i++) {
        ans += (n - sa.sa[i]) - sa.lc[i];
    }

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="b-longest-common-substringhttpscodeforcescomeducourse2lesson25practicecontest269656problemb"><a href="https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/B">B. Longest Common Substring</a></h3>
<h4 id="题意-20">题意</h4>
<p>找出两个给定字符串 $s$ 和 $t$ 的最长公共子串。</p>
<h4 id="参考思路-20">参考思路</h4>
<p>考虑字符串拼接：$r = s + &lsquo;#&rsquo; + t$，对拼接后的字符串求 SA数组，初始化 $ans$ 为空，最后从 $1$ 到 $n + m + 1$ 枚举下标，当 $lc[i] &gt; |ans|$ ，且 $sa[i - 1]$ 和 $sa[i]$ 分别属于不同串时（即一个属于 s，一个属于 t）更新答案即可。复杂度 $O(n + m)$</p>
<h4 id="参考代码-19">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    std::string s, t;
    std::cin &gt;&gt; s &gt;&gt; t;

    int n = s.size();
    int m = t.size();

    auto z = s;
    z += '#';
    z += t;

    SA sa(z);

    int mx = 0;
    std::string ans;

    auto get_len = [&amp;](int i) -&gt; int {
        return n + 1 + m - sa.sa[i];
    };

    for (int i = 1; i &lt;= n + m; i++) {
        if (sa.lc[i] &gt; ans.size() &amp;&amp; 
            (get_len(i) &gt; m &amp;&amp; get_len(i - 1) &lt;= m || 
             get_len(i) &lt;= m &amp;&amp; get_len(i - 1) &gt; m)
        ) {
            ans = z.substr(sa.sa[i], sa.lc[i]);
        }
    }

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="c-sorting-substringshttpscodeforcescomeducourse2lesson25practicecontest269656problemc"><a href="https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/C">C. Sorting Substrings</a></h3>
<h4 id="题意-21">题意</h4>
<p>给定字符串 $s$ 及其一组子串。子串由一对数字 $l_i,r_i$ 定义，即子串左端的位置和右端的位置。您需要按词典顺序对子串进行排序。如果子串等同于单词，则使用词对本身作为额外的排序键（即首先按 $l$ 进行比较，然后按 $r$ ）。</p>
<h4 id="参考思路-21">参考思路</h4>
<p>考虑利用 SA数组 重载 sort 的 cmp 函数，利用 SA数组 快速求两后缀的 lcp的功能，快速跳过两后缀相同的部分，直接比较两后缀第一次出现不同的位置，即可实现 $O(1)$ 比较两子串字典序。复杂度 $O(|s|\log|s|)$</p>
<h4 id="参考代码-20">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    std::string s;
    std::cin &gt;&gt; s;
    
    int n = s.size();
    
    SA sa(s);
    
    int m;
    std::cin &gt;&gt; m;
    std::vector&lt;std::pair&lt;int, int&gt;&gt; a(m);
    for (auto &amp;[l, r] : a) {
        std::cin &gt;&gt; l &gt;&gt; r;
        l--; r--;
    }
    
    std::sort(a.begin(), a.end(), [&amp;](const auto&amp; i, const auto&amp; j) {
        int lcp = sa.lcp(i.first, j.first);
        if (lcp &gt;= std::min(i.second - i.first + 1, j.second - j.first + 1)
        ) {
            if (i.second - i.first + 1 &lt; j.second - j.first + 1) return true;
            if (i.second - i.first + 1 == j.second - j.first + 1) {
                return i.first &lt; j.first;
            }
            return false;
        }
        return s[i.first + lcp] &lt; s[j.first + lcp];
    });
    
    for (auto &amp;[l, r] : a) {
        std::cout &lt;&lt; l + 1 &lt;&lt; &quot; &quot; &lt;&lt; r + 1 &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="d-bordershttpscodeforcescomeducourse2lesson25practicecontest269656problemd"><a href="https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/D">D. Borders</a></h3>
<h4 id="题意-22">题意</h4>
<p>如果字符串 $t$ 同时是字符串 $s$ 的后缀和前缀，那么它就是字符串 $s$ 的 <strong>border</strong>。例如，字符串 $abbabba$ 有三个 border： $abba$ 、 $a$ 和空字符串。</p>
<p>给定字符串 $s$ ，计算其所有子串的 border 总数。</p>
<h4 id="参考思路-22">参考思路</h4>
<p>不难发现，任取两不同后缀 $i$，$j$，求出 $lcp$ 后，可以得到 $|lcp|$ 个不同子串，分别以 $s.substr(i, 1)，s.substr(i, 2)，&hellip;，s.substr(i, |lcp|)$ 为border，而不重地枚举出所有 $i$，$j$ 对（$i &lt; j$），求 $lcp$，所求得的所有 border 恰好能遍历 s 的所有子串的所有 border。所以答案就是，$\sum_{i = 1}^{n - 1}\sum_{j = i + 1}^nlcp(i, j) = \sum_{i = 1}^{n - 1}\sum_{j = i + 1}^n\min(lc[i + 1], lc[i + 2],&hellip;,lc[j])$</p>
<p>考虑如何降低复杂度，由于区间min具有单调性，我们可以根据 lc 的值，构建小根堆的笛卡尔树，然后在笛卡尔树上 dfs 时，维护左右区间大小，累加贡献 $lsiz[now] * rsiz[now] * lc[now]$ 即可，时间复杂度 $O(n)$。</p>
<h4 id="参考代码-21">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    std::string s;
    std::cin &gt;&gt; s;

    int n = s.size();

    SA sa(s);

    std::vector&lt;int&gt; a;
    for (int i = 1; i &lt; n; i++) a.push_back(sa.lc[i]);

    std::vector&lt;int&gt; lc(n - 1, -1), rc(n - 1, -1);
    std::vector&lt;int&gt; stk;
    for (int i = 0; i &lt; n - 1; i++) {
        while (stk.size() &amp;&amp; a[i] &lt; a[stk.back()]) {
            rc[stk.back()] = lc[i];
            lc[i] = stk.back();
            stk.pop_back();
        }
        stk.push_back(i);
    }
    while (stk.size() &gt; 1) {
        int x = stk.back();
        stk.pop_back();
        rc[stk.back()] = x;
    }

    i64 ans = 1ll * n * (n + 1) / 2;

    std::vector&lt;int&gt; lm(n - 1), rm(n - 1);
    auto dfs = [&amp;](auto&amp;&amp; self, int now) -&gt; void {
        lm[now] = rm[now] = now;
        if (lc[now] != -1) {
            self(self, lc[now]);
            lm[now] = std::min(lm[now], lm[lc[now]]);
            rm[now] = std::max(rm[now], rm[lc[now]]);
        }
        if (rc[now] != -1) {
            self(self, rc[now]);
            lm[now] = std::min(lm[now], lm[rc[now]]);
            rm[now] = std::max(rm[now], rm[rc[now]]);
        }

        ans += 1ll * (now - lm[now] + 1) * (rm[now] - now + 1) * a[now];
    };
    if (n - 1) dfs(dfs, stk.back());

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="e-refrainhttpscodeforcescomeducourse2lesson25practicecontest269656probleme"><a href="https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/E">E. Refrain</a></h3>
<h4 id="题意-23">题意</h4>
<p>考虑一个由 $n$ 个整数组成的数组，从 $1$ 到 $m$ 。如果数组中连续元素的长度与出现次数的乘积为最大值，则称该数组的一个子序列为反演。</p>
<p>给定一个数组，你的任务是找出它的反演。</p>
<h4 id="参考思路-23">参考思路</h4>
<p>考虑将原数组当成字符串，求出原数组的 SA数组，不难发现，对sa数组中任意两不同后缀 $i$，$j$，从 $i$ 到 $j$ 的每个“子串”，前 $min(lc[i + 1], lc[i + 2], &hellip;, lc[j])$ 个元素均一一对应相等。</p>
<p>于是，我们可以求原数组的 SA数组，然后对 lc数组构建小根堆的笛卡尔树。最后在笛卡尔树上跑 dfs，当 $|ans| &lt; (lsiz[now] + rsiz[now] + 1) * lc[now]$ 时更新答案即可，时间复杂度：$O(n)$。</p>
<h4 id="参考代码-22">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    SA sa(a);

    i64 ans = n;
    int beg = 0, lcp = n;

    std::vector&lt;int&gt; b;
    for (int i = 1; i &lt; n; i++) b.push_back(sa.lc[i]);

    std::vector&lt;int&gt; lc(n - 1, -1), rc(n - 1, -1);
    std::vector&lt;int&gt; stk;
    for (int i = 0; i &lt; n - 1; i++) {
        while (stk.size() &amp;&amp; b[i] &lt; b[stk.back()]) {
            rc[stk.back()] = lc[i];
            lc[i] = stk.back();
            stk.pop_back();
        }
        stk.push_back(i);
    }
    while (stk.size() &gt; 1) {
        int x = stk.back();
        stk.pop_back();
        rc[stk.back()] = x;
    }

    std::vector&lt;int&gt; lm(n - 1), rm(n - 1);
    auto dfs = [&amp;](auto&amp;&amp; self, int now) -&gt; void {
        lm[now] = rm[now] = now;
        if (lc[now] != -1) {
            self(self, lc[now]);
            lm[now] = std::min(lm[now], lm[lc[now]]);
            rm[now] = std::max(rm[now], rm[lc[now]]);
        }
        if (rc[now] != -1) {
            self(self, rc[now]);
            lm[now] = std::min(lm[now], lm[rc[now]]);
            rm[now] = std::max(rm[now], rm[rc[now]]);
        }

        if (ans &lt; 1ll * b[now] * (rm[now] - lm[now] + 2)) {
            ans = 1ll * b[now] * (rm[now] - lm[now] + 2);

            beg = sa.sa[now];
            lcp = b[now];
        }
    };
    if (n - 1) dfs(dfs, stk.back());

    std::cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    std::cout &lt;&lt; lcp &lt;&lt; &quot;\n&quot;;
    for (int i = beg; i &lt; beg + lcp; i++) {
        std::cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    }
}
</code></pre>
<h3 id="f-periodic-substringhttpscodeforcescomeducourse2lesson25practicecontest269656problemf"><a href="https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/F">F. Periodic Substring</a></h3>
<h4 id="题意-24">题意</h4>
<p>给定字符串 $s$ 。求最大整数 $k$ ，使得字符串 $s$ 中有一个非空子串是 $k$ 个相同字符串的拼接。</p>
<h4 id="参考思路-24">参考思路</h4>
<p>先考虑暴力怎么做，自然我们可以想到枚举周期起点，枚举周期长度暴力check，但时间复杂度是 $O(n^3)$ 的。</p>
<p>对着样例具体分析，比方说 $aabaaabaaabaaabaab$，答案是 $4$，可以发现，$i = 0$ 号下标开始的后缀和 $j = 4$ 号下标开始的后缀，其 $lcp$ 长度是 $12$，而 $|lcp| / (j - i) + 1$ 就是答案 $4$。若我们枚举下标为 $i = 2$ 和 $j = 3$，算出来的为 $1$，比真正答案小。</p>
<p>由上述分析可知，答案即为 $\max_{i = 1}^{n - 1}\max_{j = i + 1}^n\min(lc[i + 1], lc[i + 2], &hellip;, lc[j]) / (j - i) + 1$。</p>
<p>考虑对 lc数组 构建笛卡尔树，我们知道，为了使得答案最大化， $i$ 和 $j$ 间的距离要尽可能小，所以在笛卡尔树上跑dfs时，可以进行启发式合并，维护每个节点左右子树的下标集合，然后在合并时更新答案 $ans = max(ans, lc[now] / (now - 左子树中离 now 最近的下标 + 1)，lc[now] / (右子树中离 now 最近的下标 - now + 1))$ 即可。</p>
<p>时间复杂度：$O(|s|\log|s|)$</p>
<h4 id="参考代码-23">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    std::string s;
    std::cin &gt;&gt; s;

    int n = s.size();
    
    if (n == 1) {
    	std::cout &lt;&lt; 1;
        return;
    }

    SA sa(s);

    int ans = 1;

    std::vector&lt;int&gt; b;
    for (int i = 1; i &lt; n; i++) b.push_back(sa.lc[i]);

    std::vector&lt;int&gt; lc(n - 1, -1), rc(n - 1, -1);
    std::vector&lt;int&gt; stk;
    for (int i = 0; i &lt; n - 1; i++) {
        while (stk.size() &amp;&amp; b[i] &lt; b[stk.back()]) {
            rc[stk.back()] = lc[i];
            lc[i] = stk.back();
            stk.pop_back();
        }
        stk.push_back(i);
    }
    while (stk.size() &gt; 1) {
        int x = stk.back();
        stk.pop_back();
        rc[stk.back()] = x;
    }

    std::vector&lt;std::set&lt;int&gt;&gt; idx(n - 1);
    auto insert = [&amp;](int i, int index, int val) {
        if (idx[i].size() == 0) idx[i].insert(index);
        else {
            auto [it, ok] = idx[i].insert(index);
            if (ok) {
                if (*it != *idx[i].begin()) {
                    ans = std::max(ans, val / (*it - *std::prev(it)) + 1);
                }
                if (*it != *idx[i].rbegin()) {
                    ans = std::max(ans, val / (*std::next(it) - *it) + 1);
                }
            }
        }
    };
    
    auto dfs = [&amp;](auto&amp;&amp; self, int now) -&gt; void {//维护所有出现过的下标，如果出现过，那么跳过
        if (lc[now] != -1) self(self, lc[now]);
        if (rc[now] != -1) self(self, rc[now]);
        
        if (lc[now] != -1 &amp;&amp; rc[now] != -1) {
        	if (idx[lc[now]].size() &gt; idx[rc[now]].size()) {
            	std::swap(idx[lc[now]], idx[rc[now]]);
        	}
        	std::swap(idx[now], idx[rc[now]]);
        	for (auto &amp;index : idx[lc[now]]) {
            	insert(now, index, b[now]);
        	}
        } else if (lc[now] != -1) {
        	std::swap(idx[now], idx[lc[now]]);
        } else if (rc[now] != -1) {
        	std::swap(idx[now], idx[rc[now]]);
        }
        
        insert(now, sa.sa[now], b[now]);
        insert(now, sa.sa[now + 1], b[now]);
    };
    
    dfs(dfs, stk[0]);

    std::cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h1 id="segment-tree-part-1">Segment Tree, part 1</h1>
<h2 id="step-1-2">Step 1</h2>
<h3 id="a-segment-tree-for-the-sumhttpscodeforcescomeducourse2lesson41practicecontest273169problema"><a href="https://codeforces.com/edu/course/2/lesson/4/1/practice/contest/273169/problem/A">A. Segment Tree for the Sum</a></h3>
<h4 id="题意-25">题意</h4>
<p>维护单点修改，区间求和的线段树。</p>
<h4 id="参考思路-25">参考思路</h4>
<p>板子题，没有思路可言。</p>
<h4 id="参考代码-24">参考代码</h4>
<pre><code class="language-cpp">template&lt;class Info&gt;//    SGT template (from jiangly)
struct SGT {
    int n;//    size
    std::vector&lt;Info&gt; info;//    the info vector
    SGT() : n(0) {}//    default initialize
    SGT(int n_, Info v_ = Info()) {//    initialize with v
        init(n_, v_);
    }
    template&lt;class T&gt;
    SGT(std::vector&lt;T&gt; init_) {//    initialize with a vector
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {//    initialize with v
        init(std::vector(n_, v_));
    }
    template&lt;class T&gt;
    void init(std::vector&lt;T&gt; init_) {//    initialize with a vector
        n = init_.size();
        info.assign(4 &lt;&lt; std::__lg(n), Info());
        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {//    pull up        the way of update
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void modify(int p, int l, int r, int x, const Info &amp;v) {//    [original] SGT point modify
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x &lt; m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &amp;v) {//    [practice] SGT point modify
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {//    [original] SGT range query
        if (l &gt;= y || r &lt;= x) {
            return Info();
        }
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {//    [practice] SGT range query
        return rangeQuery(1, 0, n, l, r);
    }
};

struct Info {
    i64 sum = 0;
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    return Info{(a.sum + b.sum)};
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;Info&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i.sum;

    SGT&lt;Info&gt; sgt(a);

    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int p, x;
            std::cin &gt;&gt; p &gt;&gt; x;

            sgt.modify(p, Info{x});
        } else {
            int l, r;
            std::cin &gt;&gt; l &gt;&gt; r;
            std::cout &lt;&lt; sgt.rangeQuery(l, r).sum &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="b-segment-tree-for-the-minimumhttpscodeforcescomeducourse2lesson41practicecontest273169problemb"><a href="https://codeforces.com/edu/course/2/lesson/4/1/practice/contest/273169/problem/B">B. Segment Tree for the Minimum</a></h3>
<h4 id="题意-26">题意</h4>
<p>维护单点修改，区间查询最小值的线段树。</p>
<h4 id="参考思路-26">参考思路</h4>
<p>将线段树默认值初始化为无穷大，然后区间合并的函数改成 $\min(a, b)$即可。</p>
<h4 id="参考代码-25">参考代码</h4>
<pre><code class="language-cpp">template&lt;class Info&gt;//    SGT template (from jiangly)
struct SGT {
    int n;//    size
    std::vector&lt;Info&gt; info;//    the info vector
    SGT() : n(0) {}//    default initialize
    SGT(int n_, Info v_ = Info()) {//    initialize with v
        init(n_, v_);
    }
    template&lt;class T&gt;
    SGT(std::vector&lt;T&gt; init_) {//    initialize with a vector
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {//    initialize with v
        init(std::vector(n_, v_));
    }
    template&lt;class T&gt;
    void init(std::vector&lt;T&gt; init_) {//    initialize with a vector
        n = init_.size();
        info.assign(4 &lt;&lt; std::__lg(n), Info());
        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {//    pull up        the way of update
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void modify(int p, int l, int r, int x, const Info &amp;v) {//    [original] SGT point modify
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x &lt; m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &amp;v) {//    [practice] SGT point modify
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {//    [original] SGT range query
        if (l &gt;= y || r &lt;= x) {
            return Info();
        }
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {//    [practice] SGT range query
        return rangeQuery(1, 0, n, l, r);
    }
};

struct Info {
    i64 sum = 1e9;
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    return Info{std::min(a.sum, b.sum)};
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;Info&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i.sum;

    SGT&lt;Info&gt; sgt(a);

    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int p, x;
            std::cin &gt;&gt; p &gt;&gt; x;

            sgt.modify(p, Info{x});
        } else {
            int l, r;
            std::cin &gt;&gt; l &gt;&gt; r;
            std::cout &lt;&lt; sgt.rangeQuery(l, r).sum &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="c-number-of-minimums-on-a-segmenthttpscodeforcescomeducourse2lesson41practicecontest273169problemc"><a href="https://codeforces.com/edu/course/2/lesson/4/1/practice/contest/273169/problem/C">C. Number of Minimums on a Segment</a></h3>
<h4 id="题意-27">题意</h4>
<p>维护单点修改，区间查询最小数，以及最小数的数量的线段树。</p>
<h4 id="参考思路-27">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {
    i64 mi = 1e9;//初始化区间min为inf
    i64 cnt = 0;//初始化min的数量为空
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    Info c;
    if (a.mi &lt; b.mi) return a;
    if (a.mi &gt; b.mi) return b;
    return Info{a.mi, a.cnt + b.cnt};
}
</code></pre>
<h4 id="参考代码-26">参考代码</h4>
<pre><code class="language-cpp">template&lt;class Info&gt;//    SGT template (from jiangly)
struct SGT {
    int n;//    size
    std::vector&lt;Info&gt; info;//    the info vector
    SGT() : n(0) {}//    default initialize
    SGT(int n_, Info v_ = Info()) {//    initialize with v
        init(n_, v_);
    }
    template&lt;class T&gt;
    SGT(std::vector&lt;T&gt; init_) {//    initialize with a vector
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {//    initialize with v
        init(std::vector(n_, v_));
    }
    template&lt;class T&gt;
    void init(std::vector&lt;T&gt; init_) {//    initialize with a vector
        n = init_.size();
        info.assign(4 &lt;&lt; std::__lg(n), Info());
        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {//    pull up        the way of update
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void modify(int p, int l, int r, int x, const Info &amp;v) {//    [original] SGT point modify
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x &lt; m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &amp;v) {//    [practice] SGT point modify
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {//    [original] SGT range query
        if (l &gt;= y || r &lt;= x) {
            return Info();
        }
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {//    [practice] SGT range query
        return rangeQuery(1, 0, n, l, r);
    }
};

struct Info {
    i64 mi = 1e9;
    i64 cnt = 0;
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    Info c;
    if (a.mi &lt; b.mi) return a;
    if (a.mi &gt; b.mi) return b;
    return Info{a.mi, a.cnt + b.cnt};
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;Info&gt; a(n);
    for (auto &amp;i : a) (std::cin &gt;&gt; i.mi), i.cnt = 1;

    SGT&lt;Info&gt; sgt(a);

    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int p, x;
            std::cin &gt;&gt; p &gt;&gt; x;

            sgt.modify(p, Info{x, 1});
        } else {
            int l, r;
            std::cin &gt;&gt; l &gt;&gt; r;

            auto z = sgt.rangeQuery(l, r);

            std::cout &lt;&lt; z.mi &lt;&lt; &quot; &quot; &lt;&lt; z.cnt &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h2 id="step-2-2">Step 2</h2>
<h3 id="a-segment-with-the-maximum-sumhttpscodeforcescomeducourse2lesson42practicecontest273278problema"><a href="https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/A">A. Segment with the Maximum Sum</a></h3>
<h4 id="题意-28">题意</h4>
<p>询问区间最大子段和。</p>
<h4 id="参考思路-28">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {
    i64 L = 0;
    i64 R = 0;
    i64 mx = 0;
    i64 sum = 0;
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    Info c;
    c.mx = std::max({a.mx, b.mx, a.R + b.L});
    c.L = std::max(a.L, a.sum + b.L);
    c.R = std::max(b.R, b.sum + a.R);
    c.sum = a.sum + b.sum;
    return c;
}
</code></pre>
<h4 id="参考代码-27">参考代码</h4>
<pre><code class="language-cpp">template&lt;class Info&gt;//    SGT template (from jiangly)
struct SGT {
    int n;//    size
    std::vector&lt;Info&gt; info;//    the info vector
    SGT() : n(0) {}//    default initialize
    SGT(int n_, Info v_ = Info()) {//    initialize with v
        init(n_, v_);
    }
    template&lt;class T&gt;
    SGT(std::vector&lt;T&gt; init_) {//    initialize with a vector
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {//    initialize with v
        init(std::vector(n_, v_));
    }
    template&lt;class T&gt;
    void init(std::vector&lt;T&gt; init_) {//    initialize with a vector
        n = init_.size();
        info.assign(4 &lt;&lt; std::__lg(n), Info());
        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {//    pull up        the way of update
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void modify(int p, int l, int r, int x, const Info &amp;v) {//    [original] SGT point modify
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x &lt; m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &amp;v) {//    [practice] SGT point modify
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {//    [original] SGT range query
        if (l &gt;= y || r &lt;= x) {
            return Info();
        }
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {//    [practice] SGT range query
        return rangeQuery(1, 0, n, l, r);
    }
};

struct Info {
    i64 L = 0;
    i64 R = 0;
    i64 mx = 0;
    i64 sum = 0;
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    Info c;
    c.mx = std::max({a.mx, b.mx, a.R + b.L});
    c.L = std::max(a.L, a.sum + b.L);
    c.R = std::max(b.R, b.sum + a.R);
    c.sum = a.sum + b.sum;
    return c;
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    
    std::vector&lt;Info&gt; a(n);
    for (auto &amp;i : a) {
        std::cin &gt;&gt; i.sum;
        i.L = i.R = i.mx = std::max(0ll, i.sum);
    }

    SGT&lt;Info&gt; sgt(a);

    std::cout &lt;&lt; sgt.rangeQuery(0, n).mx &lt;&lt; &quot;\n&quot;;
    while (m--) {
        int p, x;
        std::cin &gt;&gt; p &gt;&gt; x;

        Info z;
        z.sum = x;
        z.L = z.R = z.mx = std::max(0, x);
        sgt.modify(p, z);

        std::cout &lt;&lt; sgt.rangeQuery(0, n).mx &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="b-k-th-onehttpscodeforcescomeducourse2lesson42practicecontest273278problemb"><a href="https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/B">B. K-th one</a></h3>
<h4 id="题意-29">题意</h4>
<p>给定一个01数组，实现单点值取反，区间查询第 k个1的下标的数据结构。</p>
<h4 id="参考思路-29">参考思路</h4>
<p>考虑维护一个单点修改，区间求和的线段树，对于每次查询，二分出最小的下标 $p$，使得 $\sum_{i = 0}^p a[i] = k$ 即可。复杂度 $O(nlog^2n)$</p>
<h4 id="参考代码-28">参考代码</h4>
<p>偷懒没写线段树，用的树状数组，知道怎么做就行。</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct BIT {
    std::vector&lt;T&gt; a;
    int n;
    BIT(int n_) {//下标从1开始
        a.clear();
        a.resize(n_ + 1);
        n = n_;
    }
    BIT() {}
    BIT(const BIT&amp; bit) {//[可选] 复制bit（很少用）
        n = bit.n;
        a = bit.a;
    }
    T getsum(int x) {//获取[1, x]的和        O(logn)
        T s = T();
        while (x) {
            s = s + a[x];
            x -= (x &amp;- x);
        }
        return s;
    }
    void modify(int x, T val) {//单点增加x处的值    O(logn)
        while (x &lt;= n) {
            a[x] = a[x] + val;
            x += (x &amp;- x);
        }
    }
};

void solve() {
    int n, m;

    std::cin &gt;&gt; n &gt;&gt; m;
    BIT&lt;int&gt; bit(n);

    std::vector&lt;int&gt; a(n);
    for (int i = 0; i &lt; n; i++) {
        int x;
        std::cin &gt;&gt; x;
        bit.modify(i + 1, x);

        a[i] = x;
    }

    while (m--) {
        int op, p;
        std::cin &gt;&gt; op &gt;&gt; p;

        if (op == 1) {
            bit.modify(p + 1, -a[p]);
            a[p] = 1 - a[p];
            bit.modify(p + 1, a[p]);
        } else {
            int l = 1, r = n;
            while (l &lt;= r) {
                int mid = (l + r) / 2;
                if (bit.getsum(mid) &gt;= p + 1) r = mid - 1;
                else l = mid + 1;
            }

            std::cout &lt;&lt; r &lt;&lt; &quot;\n&quot;;
        } 
    }
}
</code></pre>
<h3 id="c-first-element-at-least-xhttpscodeforcescomeducourse2lesson42practicecontest273278problemc"><a href="https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/C">C. First element at least X</a></h3>
<h4 id="题意-30">题意</h4>
<p>维护单点修改，查询最小的，使得 $a[j] \ge x$ 的下标 $j$。</p>
<h4 id="参考思路-30">参考思路</h4>
<p>考虑维护区间max，然后进行线段树上二分即可。</p>
<h4 id="参考代码-29">参考代码</h4>
<pre><code class="language-cpp">template&lt;class Info&gt;//    SGT template (from jiangly)
struct SGT {
    int n;//    size
    std::vector&lt;Info&gt; info;//    the info vector
    SGT() : n(0) {}//    default initialize
    SGT(int n_, Info v_ = Info()) {//    initialize with v
        init(n_, v_);
    }
    template&lt;class T&gt;
    SGT(std::vector&lt;T&gt; init_) {//    initialize with a vector
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {//    initialize with v
        init(std::vector(n_, v_));
    }
    template&lt;class T&gt;
    void init(std::vector&lt;T&gt; init_) {//    initialize with a vector
        n = init_.size();
        info.assign(4 &lt;&lt; std::__lg(n), Info());
        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {//    pull up        the way of update
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void modify(int p, int l, int r, int x, const Info &amp;v) {//    [original] SGT point modify
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x &lt; m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &amp;v) {//    [practice] SGT point modify
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {//    [original] SGT range query
        if (l &gt;= y || r &lt;= x) {
            return Info();
        }
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {//    [practice] SGT range query
        return rangeQuery(1, 0, n, l, r);
    }
    
    template&lt;class F&gt;
    int findFirst(int p, int l, int r, int x, int y, F &amp;&amp;pred) {//    [original] range find first
        if (l &gt;= y || r &lt;= x) {
            return -1;
        }
        if (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        int res = findFirst(2 * p, l, m, x, y, pred);
        if (res == -1) {
            res = findFirst(2 * p + 1, m, r, x, y, pred);
        }
        return res;
    }
    template&lt;class F&gt;
    int findFirst(int l, int r, F &amp;&amp;pred) {//    [practice] range find first
        return findFirst(1, 0, n, l, r, pred);
    }
    template&lt;class F&gt;
    int findLast(int p, int l, int r, int x, int y, F &amp;&amp;pred) {//    [original] range find last
        if (l &gt;= y || r &lt;= x) {
            return -1;
        }
        if (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        int res = findLast(2 * p + 1, m, r, x, y, pred);
        if (res == -1) {
            res = findLast(2 * p, l, m, x, y, pred);
        }
        return res;
    }
    template&lt;class F&gt;
    int findLast(int l, int r, F &amp;&amp;pred) {//    [practice] range find last
        return findLast(1, 0, n, l, r, pred);
    }
};

struct Info {
    int mx = -1;
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    return Info{std::max(a.mx, b.mx)};
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    
    std::vector&lt;Info&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i.mx;

    SGT&lt;Info&gt; sgt(a);

    while (m--) {
        int op;
        std::cin &gt;&gt; op;
        
        if (op == 1) {
            int p, x;
            std::cin &gt;&gt; p &gt;&gt; x;

            sgt.modify(p, Info{x});
        } else {
            int v;
            std::cin &gt;&gt; v;

            int z = sgt.findFirst(0, n,
                [&amp;](auto p) {
                    return p.mx &gt;= v;
                }
            );

            std::cout &lt;&lt; z &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="d-first-element-at-least-x---2httpscodeforcescomeducourse2lesson42practicecontest273278problemd"><a href="https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/D">D. First element at least X - 2</a></h3>
<h4 id="题意-31">题意</h4>
<p>维护单点修改，区间查询最小的，使得 $a[j] \ge x$ 的下标 $j$。</p>
<h4 id="参考思路-31">参考思路</h4>
<p>和上题没区别，维护区间max，进行线段树上二分即可。</p>
<h4 id="参考代码-30">参考代码</h4>
<pre><code class="language-cpp">template&lt;class Info&gt;//    SGT template (from jiangly)
struct SGT {
    int n;//    size
    std::vector&lt;Info&gt; info;//    the info vector
    SGT() : n(0) {}//    default initialize
    SGT(int n_, Info v_ = Info()) {//    initialize with v
        init(n_, v_);
    }
    template&lt;class T&gt;
    SGT(std::vector&lt;T&gt; init_) {//    initialize with a vector
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {//    initialize with v
        init(std::vector(n_, v_));
    }
    template&lt;class T&gt;
    void init(std::vector&lt;T&gt; init_) {//    initialize with a vector
        n = init_.size();
        info.assign(4 &lt;&lt; std::__lg(n), Info());
        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {//    pull up        the way of update
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void modify(int p, int l, int r, int x, const Info &amp;v) {//    [original] SGT point modify
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x &lt; m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &amp;v) {//    [practice] SGT point modify
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {//    [original] SGT range query
        if (l &gt;= y || r &lt;= x) {
            return Info();
        }
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {//    [practice] SGT range query
        return rangeQuery(1, 0, n, l, r);
    }
    
    template&lt;class F&gt;
    int findFirst(int p, int l, int r, int x, int y, F &amp;&amp;pred) {//    [original] range find first
        if (l &gt;= y || r &lt;= x) {
            return -1;
        }
        if (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        int res = findFirst(2 * p, l, m, x, y, pred);
        if (res == -1) {
            res = findFirst(2 * p + 1, m, r, x, y, pred);
        }
        return res;
    }
    template&lt;class F&gt;
    int findFirst(int l, int r, F &amp;&amp;pred) {//    [practice] range find first
        return findFirst(1, 0, n, l, r, pred);
    }
    template&lt;class F&gt;
    int findLast(int p, int l, int r, int x, int y, F &amp;&amp;pred) {//    [original] range find last
        if (l &gt;= y || r &lt;= x) {
            return -1;
        }
        if (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        int res = findLast(2 * p + 1, m, r, x, y, pred);
        if (res == -1) {
            res = findLast(2 * p, l, m, x, y, pred);
        }
        return res;
    }
    template&lt;class F&gt;
    int findLast(int l, int r, F &amp;&amp;pred) {//    [practice] range find last
        return findLast(1, 0, n, l, r, pred);
    }
};

struct Info {
    int mx = -1;
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    return Info{std::max(a.mx, b.mx)};
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    
    std::vector&lt;Info&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i.mx;

    SGT&lt;Info&gt; sgt(a);

    while (m--) {
        int op;
        std::cin &gt;&gt; op;
        
        if (op == 1) {
            int p, x;
            std::cin &gt;&gt; p &gt;&gt; x;

            sgt.modify(p, Info{x});
        } else {
            int v, l;
            std::cin &gt;&gt; v &gt;&gt; l;

            int z = sgt.findFirst(l, n,
                [&amp;](auto p) {
                    return p.mx &gt;= v;
                }
            );

            std::cout &lt;&lt; z &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h2 id="step-3-2">Step 3</h2>
<h3 id="a-inversionshttpscodeforcescomeducourse2lesson43practicecontest274545problema"><a href="https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/A">A. Inversions</a></h3>
<h4 id="题意-32">题意</h4>
<p>给定由 $n$ 个元素组成的排列 $p_i$ ，求每个 $i$，使得 $j &lt; i$ 和 $p_j &gt; p_i$ 的 $j$ 的个数.</p>
<h4 id="参考思路-32">参考思路</h4>
<p>维护一个单点修改，区间查询和的数据结构，然后从小到大枚举每个数在原数组中的出现位置，询问 $[1, i]$ 的和，再修改 $a[i] = 1$ 即可，时间复杂度 $O(n\logn)$</p>
<h4 id="参考代码-31">参考代码</h4>
<p>用的树状数组，用线段树也能实现相同的操作。</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct BIT {
    std::vector&lt;T&gt; a;
    int n;
    BIT(int n_) {//下标从1开始
        a.clear();
        a.resize(n_ + 1);
        n = n_;
    }
    BIT() {}
    BIT(const BIT&amp; bit) {//[可选] 复制bit（很少用）
        n = bit.n;
        a = bit.a;
    }
    T getsum(int x) {//获取[1, x]的和        O(logn)
        T s = 0;
        while (x) {
            s += a[x];
            x -= (x &amp;- x);
        }
        return s;
    }
    void modify(int x, T val) {//单点增加x处的值    O(logn)
        while (x &lt;= n) {
            a[x] += val;
            x += (x &amp;- x);
        }
    }
};

void solve() {
    int n;
    std::cin &gt;&gt; n;

    BIT&lt;int&gt; bit(n);

    for (int i = 1; i &lt;= n; i++) {
        int x;
        std::cin &gt;&gt; x;

        std::cout &lt;&lt; bit.getsum(n) - bit.getsum(x) &lt;&lt; &quot; &quot;;

        bit.modify(x, 1);
    }
}
</code></pre>
<h3 id="b-inversions-2httpscodeforcescomeducourse2lesson43practicecontest274545problemb"><a href="https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/B">B. Inversions 2</a></h3>
<h4 id="题意-33">题意</h4>
<p>这道题是上一道题的反转版。有一个由 $n$ 个元素组成的排列 $p_i$ ，我们写下了每个 $i$ 的数字 $a_i$ 、 $j &lt; i$ 和 $p_j &gt; p_i$ 的数字 $j$ 。恢复给定的 $a_i$ 的原始排列。</p>
<h4 id="参考思路-33">参考思路</h4>
<p>线段树维护一个01数组，实现单点修改，区间求和的操作。初始化数组全为 1，然后倒着遍历数组 a，每次查询 区间 $[1, n]$ 中，第一个使得 $\sum_{j = 1}^p = a[i]$ 的下标 p，保存到ans数组里（倒序保存），并更新 $a[p] = 0$。最后输出 ans 即可。</p>
<h4 id="参考代码-32">参考代码</h4>
<p>这里我没写线段树 / 树状数组，用 pbds 偷鸡过了，想练线段树可以自己按相同逻辑实现。</p>
<pre><code class="language-cpp">#include &lt;ext/pb_ds/assoc_container.hpp&gt;
#include &lt;ext/pb_ds/tree_policy.hpp&gt;

namespace pb = __gnu_pbds;

template &lt;class T, class Cmp = std::less&lt;T&gt;&gt;
using RBT =
    pb::tree&lt;T, pb::null_type, Cmp, pb::rb_tree_tag,
             pb::tree_order_statistics_node_update&gt;;

/**
 * order_of_key(x) -&gt; 查询有多少元素比x小
 * find_by_order(x) -&gt; 查询第x个元素的迭代器
 */

void solve() {
    int n;
    std::cin &gt;&gt; n;

    std::vector&lt;int&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    std::vector&lt;int&gt; ans;

    RBT&lt;int, std::greater&lt;int&gt;&gt; s;

    for (int i = 1; i &lt;= n; i++) {
        s.insert(i);
    }

    for (int i = n - 1; i &gt;= 0; i--) {
        int x = *s.find_by_order(a[i]);
        s.erase(x);
        ans.push_back(x);
    }

    for (int i = n - 1; i &gt;= 0; i--) {
        std::cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
    }
}
</code></pre>
<h3 id="c-nested-segmentshttpscodeforcescomeducourse2lesson43practicecontest274545problemc"><a href="https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/C">C. Nested Segments</a></h3>
<h4 id="题意-34">题意</h4>
<p>给定一个由 $2n$ 个数字组成的数组，其中从 1 到 $n$ 的每个数字都正好出现两次。如果数字 $y$ 的出现次数都在数字 $x$ 的出现次数之间，我们就说 $y$ 嵌套在 $x$ 中。求每个线段 $i$ 内部嵌套了多少个线段。</p>
<h4 id="参考思路-34">参考思路</h4>
<p>考虑将所有相同的数字对提取出来，按照 {第一次出现的下标，第二次出现的下标，具体数字} 保存。再按照第一次出现的下标排序。维护一个单点修改，区间求和的数据结构，初始化数组a为0。从大到小枚举 {l, r, p}，查询 $[l, r]$ 作为 $ans[p]$ 的答案，并更新 $a[p]$ 为 $1$。最后输出答案即可。</p>
<h4 id="参考代码-33">参考代码</h4>
<p>没用线段树，想用自己写。</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct BIT {
    std::vector&lt;T&gt; a;
    int n;
    BIT(int n_) {//下标从1开始
        a.clear();
        a.resize(n_ + 1);
        n = n_;
    }
    BIT() {}
    BIT(const BIT&amp; bit) {//[可选] 复制bit（很少用）
        n = bit.n;
        a = bit.a;
    }
    T getsum(int x) {//获取[1, x]的和        O(logn)
        T s = 0;
        while (x) {
            s += a[x];
            x -= (x &amp;- x);
        }
        return s;
    }
    void modify(int x, T val) {//单点增加x处的值    O(logn)
        while (x &lt;= n) {
            a[x] += val;
            x += (x &amp;- x);
        }
    }
};

void solve() {
    int n;
    std::cin &gt;&gt; n;

    std::map&lt;int, std::vector&lt;int&gt;&gt; pos;
    for (int i = 1; i &lt;= 2 * n; i++) {
        int x;
        std::cin &gt;&gt; x;

        pos[x].push_back(i);
    }

    BIT&lt;int&gt; bit(2 * n);

    std::vector&lt;int&gt; ans(n);

    std::vector&lt;std::array&lt;int, 3&gt;&gt; p;
    for (auto &amp;[k, v] : pos) {
        p.push_back({v[0], v[1], k});
    }

    std::sort(p.begin(), p.end());

    for (int i = n - 1; i &gt;= 0; i--) {
        ans[p[i][2] - 1] = (bit.getsum(p[i][1]) - bit.getsum(p[i][0]));
        bit.modify(p[i][1], 1);
    }

    for (auto &amp;i : ans) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
}
</code></pre>
<h3 id="d-intersecting-segmentshttpscodeforcescomeducourse2lesson43practicecontest274545problemd"><a href="https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/D">D. Intersecting Segments</a></h3>
<h4 id="题意-35">题意</h4>
<p>给定一个由 $2n$ 个数字组成的数组，其中从 1 到 $n$ 的每个数字都恰好出现两次。如果数字 $y$ 在数字 $x$ 出现的次数之间恰好出现一次，我们就说线段 $y$ 与线段 $x$ 相交。求每条线段 $i$ 与多少条线段相交。</p>
<h4 id="参考思路-35">参考思路</h4>
<p>和上题类似，采用合适的顺序枚举，分别维护每个线段的左相交和右相交线段数量即可。具体看代码吧。</p>
<h4 id="参考代码-34">参考代码</h4>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct BIT {
    std::vector&lt;T&gt; a;
    int n;
    BIT(int n_) {//下标从1开始
        a.clear();
        a.resize(n_ + 1);
        n = n_;
    }
    BIT() {}
    BIT(const BIT&amp; bit) {//[可选] 复制bit（很少用）
        n = bit.n;
        a = bit.a;
    }
    T getsum(int x) {//获取[1, x]的和        O(logn)
        T s = 0;
        while (x) {
            s += a[x];
            x -= (x &amp;- x);
        }
        return s;
    }
    void modify(int x, T val) {//单点增加x处的值    O(logn)
        while (x &lt;= n) {
            a[x] += val;
            x += (x &amp;- x);
        }
    }
};

void solve() {
    int n;
    std::cin &gt;&gt; n;

    std::map&lt;int, std::vector&lt;int&gt;&gt; pos;
    for (int i = 1; i &lt;= 2 * n; i++) {
        int x;
        std::cin &gt;&gt; x;

        pos[x].push_back(i);
    }

    BIT&lt;int&gt; bit(2 * n);

    std::vector&lt;int&gt; lin(n), rin(n);//相含数组

    std::vector&lt;std::array&lt;int, 3&gt;&gt; p;
    for (auto &amp;[k, v] : pos) {
        p.push_back({v[0], v[1], k});
    }

    std::sort(p.begin(), p.end());

    for (int i = 0; i &lt; n; i++) {
        lin[p[i][2] - 1] = (bit.getsum(p[i][1]) - bit.getsum(p[i][0]));
        bit.modify(p[i][1], 1);
    }

    bit = BIT&lt;int&gt;(2 * n);

    std::sort(p.begin(), p.end(), [](auto a, auto b) {
        return a[1] &lt; b[1];
    });

    for (int i = n - 1; i &gt;= 0; i--) {
        rin[p[i][2] - 1] = (bit.getsum(p[i][1]) - bit.getsum(p[i][0]));
        bit.modify(p[i][0], 1);
    }

    for (int i = 0; i &lt; n; i++) {
        std::cout &lt;&lt; lin[i] + rin[i] &lt;&lt; &quot; &quot;;
    }
}
</code></pre>
<h3 id="e-addition-to-segmenthttpscodeforcescomeducourse2lesson43practicecontest274545probleme"><a href="https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/E">E. Addition to Segment</a></h3>
<h4 id="题意-36">题意</h4>
<p>维护区间加，单点查询的数据结构。</p>
<h4 id="参考思路-36">参考思路</h4>
<p>考虑用单点修改，区间求和的数据结构，维护一个差分数组，每次修改时，只需要修改区间端点即可，查询时直接查询 $[1, p]$ 的和，即为答案。</p>
<h4 id="参考代码-35">参考代码</h4>
<p>没写线段树，想练线段树自己写</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct BIT {
    std::vector&lt;T&gt; a;
    int n;
    BIT(int n_) {//下标从1开始
        a.clear();
        a.resize(n_ + 1);
        n = n_;
    }
    BIT() {}
    BIT(const BIT&amp; bit) {//[可选] 复制bit（很少用）
        n = bit.n;
        a = bit.a;
    }
    T getsum(int x) {//获取[1, x]的和        O(logn)
        T s = 0;
        while (x) {
            s += a[x];
            x -= (x &amp;- x);
        }
        return s;
    }
    void modify(int x, T val) {//单点增加x处的值    O(logn)
        while (x &lt;= n) {
            a[x] += val;
            x += (x &amp;- x);
        }
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    BIT&lt;i64&gt; bit(n + 1);

    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int l, r, v;
            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; v;

            bit.modify(l + 1, v);
            bit.modify(r + 1, -v);
        } else {
            int p;
            std::cin &gt;&gt; p;

            std::cout &lt;&lt; bit.getsum(p + 1) &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h2 id="step-4-2">Step 4</h2>
<h3 id="a-sign-alternationhttpscodeforcescomeducourse2lesson44practicecontest274684problema"><a href="https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/A">A. Sign alternation</a></h3>
<h4 id="题意-37">题意</h4>
<p>执行由 $n$ 元素 $a_1, a_2 &hellip; a_n$ 组成的数据结构，并进行以下操作：</p>
<ul>
<li>为元素 $a_i$ 赋值 $j$ ；</li>
<li>在 $l$ 到 $r$ （含）（ $a_l - a_{l+1} + a_{l + 2} - &hellip; \pm a_{r}$ ）的范围内查找交替符号和。</li>
</ul>
<h4 id="参考思路-37">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {
    i64 sum = 0;
    int siz = 0;
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    Info c;
    if (a.siz &amp; 1) {
        c.sum = a.sum - b.sum;
    } else {
        c.sum = a.sum + b.sum;
    }

    c.siz = a.siz + b.siz;
    return c;
}
</code></pre>
<p><em>当然，还有一种方法是，开两个线段树，分别对奇偶位置维护区间和。</em></p>
<h4 id="参考代码-36">参考代码</h4>
<pre><code class="language-cpp">template&lt;class Info&gt;//    SGT template (from jiangly)
struct SGT {
    int n;//    size
    std::vector&lt;Info&gt; info;//    the info vector
    SGT() : n(0) {}//    default initialize
    SGT(int n_, Info v_ = Info()) {//    initialize with v
        init(n_, v_);
    }
    template&lt;class T&gt;
    SGT(std::vector&lt;T&gt; init_) {//    initialize with a vector
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {//    initialize with v
        init(std::vector(n_, v_));
    }
    template&lt;class T&gt;
    void init(std::vector&lt;T&gt; init_) {//    initialize with a vector
        n = init_.size();
        info.assign(4 &lt;&lt; std::__lg(n), Info());
        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {//    pull up        the way of update
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void modify(int p, int l, int r, int x, const Info &amp;v) {//    [original] SGT point modify
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x &lt; m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &amp;v) {//    [practice] SGT point modify
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {//    [original] SGT range query
        if (l &gt;= y || r &lt;= x) {
            return Info();
        }
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {//    [practice] SGT range query
        return rangeQuery(1, 0, n, l, r);
    }
};

struct Info {
    i64 sum = 0;
    int siz = 0;
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    Info c;
    if (a.siz &amp; 1) {
        c.sum = a.sum - b.sum;
    } else {
        c.sum = a.sum + b.sum;
    }

    c.siz = a.siz + b.siz;
    return c;
}

void solve() {
    int n;
    std::cin &gt;&gt; n;

    std::vector&lt;Info&gt; a(n);

    for (auto &amp;i : a) (std::cin &gt;&gt; i.sum), i.siz = 1;

    SGT&lt;Info&gt; sgt(a);

    int q;
    std::cin &gt;&gt; q;
    while (q--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 0) {
            int i, j;
            std::cin &gt;&gt; i &gt;&gt; j;

            sgt.modify(i - 1, Info{j, 1});
        } else {
            int l, r;
            std::cin &gt;&gt; l &gt;&gt; r;

            std::cout &lt;&lt; sgt.rangeQuery(l - 1, r).sum &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="b-cryptographyhttpscodeforcescomeducourse2lesson44practicecontest274684problemb"><a href="https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/B">B. Cryptography</a></h3>
<h4 id="题意-38">题意</h4>
<p>给定 $n$ 个大小为 $2\times 2$ 的矩阵 $A_1, A_2, &hellip;, A_n$ 。你需要计算几个查询的矩阵 $A_i, A_{i+1}, &hellip;, A_j$ 的乘积。所有计算均以 $r$ 为模来进行。</p>
<h4 id="参考思路-38">参考思路</h4>
<p>矩阵乘积也具有结合律，所以可以用线段树维护。考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {
    i64 a[2][2] = {0};
    Info() {
        for (int i = 0; i &lt; 2; i++) {
            a[i][i] = 1;
        }
    }
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    Info c;
    for (int i = 0; i &lt; 2; i++) c.a[i][i] = 0;

    for (int i = 0; i &lt; 2; i++) {
        for (int j = 0; j &lt; 2; j++) {
            for (int k = 0; k &lt; 2; k++) {
                (c.a[i][j] += (a.a[i][k] * b.a[k][j]) % M) %= M;
            }
        }
    }
    return c;
}
</code></pre>
<h4 id="参考代码-37">参考代码</h4>
<pre><code class="language-cpp">template&lt;class Info&gt;//    SGT template (from jiangly)
struct SGT {
    int n;//    size
    std::vector&lt;Info&gt; info;//    the info vector
    SGT() : n(0) {}//    default initialize
    SGT(int n_, Info v_ = Info()) {//    initialize with v
        init(n_, v_);
    }
    template&lt;class T&gt;
    SGT(std::vector&lt;T&gt; init_) {//    initialize with a vector
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {//    initialize with v
        init(std::vector(n_, v_));
    }
    template&lt;class T&gt;
    void init(std::vector&lt;T&gt; init_) {//    initialize with a vector
        n = init_.size();
        info.assign(4 &lt;&lt; std::__lg(n), Info());
        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {//    pull up        the way of update
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void modify(int p, int l, int r, int x, const Info &amp;v) {//    [original] SGT point modify
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x &lt; m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &amp;v) {//    [practice] SGT point modify
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {//    [original] SGT range query
        if (l &gt;= y || r &lt;= x) {
            return Info();
        }
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {//    [practice] SGT range query
        return rangeQuery(1, 0, n, l, r);
    }
};

int M;

struct Info {
    i64 a[2][2] = {0};
    Info() {
        for (int i = 0; i &lt; 2; i++) {
            a[i][i] = 1;
        }
    }
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    Info c;
    for (int i = 0; i &lt; 2; i++) c.a[i][i] = 0;

    for (int i = 0; i &lt; 2; i++) {
        for (int j = 0; j &lt; 2; j++) {
            for (int k = 0; k &lt; 2; k++) {
                (c.a[i][j] += (a.a[i][k] * b.a[k][j]) % M) %= M;
            }
        }
    }
    return c;
}

void solve() {
    int n, m;
    std::cin &gt;&gt; M &gt;&gt; n &gt;&gt; m;

    std::vector&lt;Info&gt; a(n);

    for (auto &amp;v : a) {
        std::cin &gt;&gt; v.a[0][0] &gt;&gt; v.a[0][1] &gt;&gt; v.a[1][0] &gt;&gt; v.a[1][1];
        v.a[0][0] %= M;
        v.a[0][1] %= M;
        v.a[1][0] %= M;
        v.a[1][1] %= M;
    }

    SGT&lt;Info&gt; sgt(a);

    while (m--) {
        int l, r;
        std::cin &gt;&gt; l &gt;&gt; r;

        auto z = sgt.rangeQuery(l - 1, r);
        std::cout &lt;&lt; z.a[0][0] &lt;&lt; &quot; &quot; &lt;&lt; z.a[0][1] &lt;&lt; &quot;\n&quot;;
        std::cout &lt;&lt; z.a[1][0] &lt;&lt; &quot; &quot; &lt;&lt; z.a[1][1] &lt;&lt; &quot;\n&quot;;
        std::cout &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="c-number-of-inversions-on-segmenthttpscodeforcescomeducourse2lesson44practicecontest274684problemc"><a href="https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/C">C. Number of Inversions on Segment</a></h3>
<h4 id="题意-39">题意</h4>
<p>给定一个由小整数（ $1 \leq a_i \leq 40$ ）组成的数组 $a$ 。你需要建立一个数据结构来处理两种类型的查询：</p>
<ol>
<li>查找段上的逆序对数。</li>
<li>修改数组元素。</li>
</ol>
<h4 id="参考思路-39">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {
    std::vector&lt;int&gt; cnt, pre;
    i64 inv = 0;
    Info() : cnt(41), pre(41) {}
    Info(std::vector&lt;int&gt; &amp;cnt, std::vector&lt;int&gt; &amp;pre, i64 inv) : cnt(cnt), pre(pre), inv(inv) {}
    Info(int x) : cnt(41), pre(41) {
        cnt[x]++;
        for (int i = 1; i &lt;= 40; i++) {
            pre[i] = pre[i - 1] + cnt[i];
        }
    }
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    Info c;

    c.inv = a.inv + b.inv;
    for (int i = 1; i &lt;= 40; i++) {
        c.inv += 1ll * (a.pre[40] - a.pre[i]) * b.cnt[i];
    }

    c.cnt = a.cnt;

    for (int i = 1; i &lt;= 40; i++) {
        c.cnt[i] += b.cnt[i];
        c.pre[i] = c.pre[i - 1] + c.cnt[i];
    }

    return c;
}
</code></pre>
<p>时间复杂度：$O(40 n \log n)$</p>
<h4 id="参考代码-38">参考代码</h4>
<pre><code class="language-cpp">template&lt;class Info&gt;//    SGT template (from jiangly)
struct SGT {
    int n;//    size
    std::vector&lt;Info&gt; info;//    the info vector
    SGT() : n(0) {}//    default initialize
    SGT(int n_, Info v_ = Info()) {//    initialize with v
        init(n_, v_);
    }
    template&lt;class T&gt;
    SGT(std::vector&lt;T&gt; init_) {//    initialize with a vector
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {//    initialize with v
        init(std::vector(n_, v_));
    }
    template&lt;class T&gt;
    void init(std::vector&lt;T&gt; init_) {//    initialize with a vector
        n = init_.size();
        info.assign(4 &lt;&lt; std::__lg(n), Info());
        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {//    pull up        the way of update
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void modify(int p, int l, int r, int x, const Info &amp;v) {//    [original] SGT point modify
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x &lt; m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &amp;v) {//    [practice] SGT point modify
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {//    [original] SGT range query
        if (l &gt;= y || r &lt;= x) {
            return Info();
        }
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {//    [practice] SGT range query
        return rangeQuery(1, 0, n, l, r);
    }
};

struct Info {
    std::vector&lt;int&gt; cnt, pre;
    i64 inv = 0;
    Info() : cnt(41), pre(41) {}
    Info(std::vector&lt;int&gt; &amp;cnt, std::vector&lt;int&gt; &amp;pre, i64 inv) : cnt(cnt), pre(pre), inv(inv) {}
    Info(int x) : cnt(41), pre(41) {
        cnt[x]++;
        for (int i = 1; i &lt;= 40; i++) {
            pre[i] = pre[i - 1] + cnt[i];
        }
    }
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    Info c;

    c.inv = a.inv + b.inv;
    for (int i = 1; i &lt;= 40; i++) {
        c.inv += 1ll * (a.pre[40] - a.pre[i]) * b.cnt[i];
    }

    c.cnt = a.cnt;

    for (int i = 1; i &lt;= 40; i++) {
        c.cnt[i] += b.cnt[i];
        c.pre[i] = c.pre[i - 1] + c.cnt[i];
    }

    return c;
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;Info&gt; a(n);
    for (auto &amp;i : a) {
        int x;
        std::cin &gt;&gt; x;

        i = Info(x);
    }

    SGT&lt;Info&gt; sgt(a);

    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int l, r;
            std::cin &gt;&gt; l &gt;&gt; r;

            std::cout &lt;&lt; sgt.rangeQuery(l - 1, r).inv &lt;&lt; &quot;\n&quot;;
        } else {
            int p, x;
            std::cin &gt;&gt; p &gt;&gt; x;

            sgt.modify(p - 1, Info(x));
        }
    }
}
</code></pre>
<h3 id="d-number-of-different-on-segmenthttpscodeforcescomeducourse2lesson44practicecontest274684problemdlocaleen"><a href="https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/D?locale=en">D. Number of Different on Segment</a></h3>
<h4 id="题意-40">题意</h4>
<p>给定一个由小整数（ $1 \leq a_i \leq 40$ ）组成的数组 $a$ 。你需要建立一个数据结构来处理两种类型的查询：</p>
<ol>
<li>查找段上不同元素的数量、</li>
<li>更改数组中的元素。</li>
</ol>
<h4 id="参考思路-40">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {
    int cnt[41] = {0};
    int sum = 0;
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    Info c;
    
    for (int i = 1; i &lt;= 40; i++) {
        c.cnt[i] = (a.cnt[i] | b.cnt[i]);
        c.sum += c.cnt[i];
    }
    return c;
}
</code></pre>
<p>时间复杂度：$O(40 n \log n)$</p>
<h4 id="参考代码-39">参考代码</h4>
<pre><code class="language-cpp">template&lt;class Info&gt;//    SGT template (from jiangly)
struct SGT {
    int n;//    size
    std::vector&lt;Info&gt; info;//    the info vector
    SGT() : n(0) {}//    default initialize
    SGT(int n_, Info v_ = Info()) {//    initialize with v
        init(n_, v_);
    }
    template&lt;class T&gt;
    SGT(std::vector&lt;T&gt; init_) {//    initialize with a vector
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {//    initialize with v
        init(std::vector(n_, v_));
    }
    template&lt;class T&gt;
    void init(std::vector&lt;T&gt; init_) {//    initialize with a vector
        n = init_.size();
        info.assign(4 &lt;&lt; std::__lg(n), Info());
        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {//    pull up        the way of update
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void modify(int p, int l, int r, int x, const Info &amp;v) {//    [original] SGT point modify
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x &lt; m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &amp;v) {//    [practice] SGT point modify
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {//    [original] SGT range query
        if (l &gt;= y || r &lt;= x) {
            return Info();
        }
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {//    [practice] SGT range query
        return rangeQuery(1, 0, n, l, r);
    }
};

struct Info {
    int cnt[41] = {0};
    int sum = 0;
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    Info c;
    
    for (int i = 1; i &lt;= 40; i++) {
        c.cnt[i] = (a.cnt[i] | b.cnt[i]);
        c.sum += c.cnt[i];
    }

    return c;
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;Info&gt; a(n);
    for (auto &amp;i : a) {
        int x;
        std::cin &gt;&gt; x;
        i.cnt[x]++;
        i.sum++;
    }

    SGT&lt;Info&gt; sgt(a);

    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int l, r;
            std::cin &gt;&gt; l &gt;&gt; r;

            std::cout &lt;&lt; sgt.rangeQuery(l - 1, r).sum &lt;&lt; &quot;\n&quot;;
        } else {
            int p, x;
            std::cin &gt;&gt; p &gt;&gt; x;
            
            Info z;
            z.cnt[x]++;
            z.sum++;
            sgt.modify(p - 1, z);
        }
    }
}
</code></pre>
<h3 id="e-earthquakeshttpscodeforcescomeducourse2lesson44practicecontest274684probleme"><a href="https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/E">E. Earthquakes</a></h3>
<h4 id="题意-41">题意</h4>
<p>一个城市是由 $n$ 个单元组成的序列，编号从 0 到 $n-1$ 。最初，所有单元格都是空的。然后，两种类型中的 $m$ 个事件依次发生：</p>
<ul>
<li>在单元格 $i$ 中正在建造强度为 $h$ 的建筑物（如果该单元格中已有建筑物，则该建筑物将被拆除并被新建筑物取代）、</li>
<li>在 $l$ 到 $r-1$ 的区间内发生了威力为 $p$ 的地震，摧毁了所有强度不超过 $p$ 的建筑物。</li>
</ul>
<p>你的任务是针对每次地震说出它将摧毁多少座建筑物。</p>
<h4 id="参考思路-41">参考思路</h4>
<p>考虑维护一个单点修改，区间查询最小值的线段树。初始化 a 为 inf。每次查询时，不断查询区间中第一个最小值的位置，判断其是否小于等于 $p$，修改为 inf，并计数即可。时间复杂度 $O(n\log n)$</p>
<h4 id="参考代码-40">参考代码</h4>
<pre><code class="language-cpp">constexpr int inf = 1e9 + 1;

//单点修改，区间查询。（可选功能：区间查找满足条件的第一个元素，区间查找满足条件的最后一个元素
template&lt;class Info&gt;//    SGT template (from jiangly)
struct SGT {
    int n;//    size
    std::vector&lt;Info&gt; info;//    the info vector
    SGT() : n(0) {}//    default initialize
    SGT(int n_, Info v_ = Info()) {//    initialize with v
        init(n_, v_);
    }
    template&lt;class T&gt;
    SGT(std::vector&lt;T&gt; init_) {//    initialize with a vector
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {//    initialize with v
        init(std::vector(n_, v_));
    }
    template&lt;class T&gt;
    void init(std::vector&lt;T&gt; init_) {//    initialize with a vector
        n = init_.size();
        info.assign(4 &lt;&lt; std::__lg(n), Info());
        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {//    pull up        the way of update
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void modify(int p, int l, int r, int x, const Info &amp;v) {//    [original] SGT point modify
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x &lt; m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &amp;v) {//    [practice] SGT point modify
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {//    [original] SGT range query
        if (l &gt;= y || r &lt;= x) {
            return Info();
        }
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {//    [practice] SGT range query
        return rangeQuery(1, 0, n, l, r);
    }
    
    template&lt;class F&gt;
    int findFirst(int p, int l, int r, int x, int y, F &amp;&amp;pred) {//    [original] range find first
        if (l &gt;= y || r &lt;= x) {
            return -1;
        }
        if (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        int res = findFirst(2 * p, l, m, x, y, pred);
        if (res == -1) {
            res = findFirst(2 * p + 1, m, r, x, y, pred);
        }
        return res;
    }
    template&lt;class F&gt;
    int findFirst(int l, int r, F &amp;&amp;pred) {//    [practice] range find first
        return findFirst(1, 0, n, l, r, pred);
    }

    //暴力删 min
    int calc(int l, int r, int p) {
        int sum = 0;

        while (rangeQuery(l, r).mi &lt;= p) {
            int i = findFirst(l, r, 
                [&amp;](Info &amp;z) {
                    return z.mi &lt;= p;
                }
            );

            modify(i, Info{inf});
            sum++;
        }

        return sum;
    }
};

struct Info {
    int mi = inf;
};

Info operator+(const Info &amp;a, const Info &amp;b) {
    return Info{std::min(a.mi, b.mi)};
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    SGT&lt;Info&gt; sgt(n);
    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int p, x;
            std::cin &gt;&gt; p &gt;&gt; x;

            sgt.modify(p, Info{x});
        } else {
            int l, r, p;
            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; p;

            std::cout &lt;&lt; sgt.calc(l, r, p) &lt;&lt; &quot;\n&quot;;
        }
    } 
}
</code></pre>
<h1 id="segment-tree-part-2">Segment Tree, part 2</h1>
<h2 id="step-1-3">Step 1</h2>
<h3 id="a-addition-to-segmenthttpscodeforcescomeducourse2lesson51practicecontest279634problema"><a href="https://codeforces.com/edu/course/2/lesson/5/1/practice/contest/279634/problem/A">A. Addition to Segment</a></h3>
<h4 id="题意-42">题意</h4>
<p>有一个由 $n$ 个元素组成的数组，初始填充为零。你需要编写一个数据结构来处理两种类型的查询：</p>
<ul>
<li>在从 $l$ 到 $r-1$ 的数段中添加数字 $v$ 、</li>
<li>查找元素 $i$ 的当前值。</li>
</ul>
<h4 id="参考思路-42">参考思路</h4>
<p>维护一个区间修改，单点查询的线段树即可。</p>
<h4 id="参考代码-41">参考代码</h4>
<p>用的数组数组，想练线段树自己写。</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct BIT {
    std::vector&lt;T&gt; a;
    int n;
    BIT(int n_) {//下标从1开始
        a.clear();
        a.resize(n_ + 1);
        n = n_;
    }
    BIT() {}
    BIT(const BIT&amp; bit) {//[可选] 复制bit（很少用）
        n = bit.n;
        a = bit.a;
    }
    T getsum(int x) {//获取[1, x]的和        O(logn)
        T s = 0;
        while (x) {
            s += a[x];
            x -= (x &amp;- x);
        }
        return s;
    }
    void modify(int x, T val) {//单点增加x处的值    O(logn)
        while (x &lt;= n) {
            a[x] += val;
            x += (x &amp;- x);
        }
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    BIT&lt;i64&gt; bit(n + 1);

    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int l, r, v;
            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; v;

            bit.modify(l + 1, v);
            bit.modify(r + 1, -v);
        } else {
            int p;
            std::cin &gt;&gt; p;

            std::cout &lt;&lt; bit.getsum(p + 1) &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="b-applying-max-to-segmenthttpscodeforcescomeducourse2lesson51practicecontest279634problemb"><a href="https://codeforces.com/edu/course/2/lesson/5/1/practice/contest/279634/problem/B">B. Applying MAX to Segment</a></h3>
<h4 id="题意-43">题意</h4>
<p>有一个由 $n$ 个元素组成的数组，初始填充为零。你需要编写一个数据结构来处理两种类型的查询：</p>
<ul>
<li>对于从 $l$ 到 $r-1$ 的所有 $i$ 执行 $a_i = \max(a_i, v)$ 操作、</li>
<li>查找元素 $i$ 的当前值。</li>
</ul>
<h4 id="参考思路-43">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {//信息
    int mx;
    Info(int mx = 0) : mx(mx) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(std::max(mx, b.mx));
    }
};

struct Tag {//Tag信息
    int v = 0;
    Tag(int v = 0) : v(v) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        return Tag(std::max(v, b.v));
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {//赋值型Tag
    return Info(std::max(a.mx, b.v));
}
</code></pre>
<h4 id="参考代码-42">参考代码</h4>
<pre><code class="language-cpp">template&lt;typename Info, typename Tag&gt;
struct SGT {
    #define lson (p&lt;&lt;1)
    #define rson (p&lt;&lt;1|1)
    std::vector&lt;Info&gt; ans;
    std::vector&lt;Tag&gt; tag;
    int n;
    SGT() : n(0) {}
    SGT(int n, Info v = Info()) {
        init(std::vector&lt;Info&gt;(n, v));
    }
    SGT(std::vector&lt;Info&gt; a) {
        init(a);
    }

    void init(std::vector&lt;Info&gt; a) {
        n = a.size();
        ans.resize(4 &lt;&lt; std::__lg(n));
        tag.resize(4 &lt;&lt; std::__lg(n));
        auto build = [&amp;](auto&amp;&amp; self, int p, int l, int r) -&gt; void {
            if (r - l == 1) {
                ans[p] = a[l];
                return;
            }
            
            int m = (l + r) &gt;&gt; 1;
            self(self, lson, l, m);
            self(self, rson, m, r);

            pushup(p);
        };
        build(build, 1, 0, n);           
    }

    void pushup(int p) {
        ans[p] = ans[lson] + ans[rson];
    }
    
    void pushdown(int p, int l, int r) {
        int m = (l + r) / 2;

        ans[lson] = ans[lson] + tag[p];
        tag[lson] = tag[lson] + tag[p];

        ans[rson] = ans[rson] + tag[p];
        tag[rson] = tag[rson] + tag[p];

        tag[p] = Tag();
    }
    
    void modify(int p, int l, int r, int x, int y, Tag k) {//区间修改
        if (x &lt;= l &amp;&amp; r &lt;= y) {
            ans[p] = ans[p] + k;
            tag[p] = tag[p] + k;
            return;
        }

        pushdown(p, l, r);

        int m = (l + r) &gt;&gt; 1;
        if (x &lt; m) modify(lson, l, m, x, y, k);
        if (y &gt; m) modify(rson, m, r, x, y, k);

        pushup(p);
    }

    void modify(int l, int r, Tag k) {// [可选]
        if (l == r) return;//
        assert(l &lt; r &amp;&amp; l &gt;= 0 &amp;&amp; r &lt;= n);
        modify(1, 0, n, l, r, k);
    }

    Info query(int p, int l, int r, int x, int y) {//区间查询
        if (x &lt;= l &amp;&amp; r &lt;= y) return ans[p];

        Info res;

        pushdown(p, l, r);
        
        int m = (l + r) &gt;&gt; 1;
        if (x &lt; m) res = res + query(lson, l, m, x, y); 
        if (y &gt; m) res = res + query(rson, m, r, x, y); 

        return res;
    }

    Info query(int l, int r) { // [可选]
        if (l == r) return Info();//
        assert(l &lt; r &amp;&amp; l &gt;= 0 &amp;&amp; r &lt;= n);
        return query(1, 0, n, l, r);
    }

    #undef lson
    #undef rson
};

struct Info {//信息
    int mx;
    Info(int mx = 0) : mx(mx) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(std::max(mx, b.mx));
    }
};

struct Tag {//Tag信息
    int v = 0;
    Tag(int v = 0) : v(v) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        return Tag(std::max(v, b.v));
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {//赋值型Tag
    return Info(std::max(a.mx, b.v));
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    SGT&lt;Info, Tag&gt; sgt(n);

    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int l, r, v;

            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; v;

            sgt.modify(l, r, Tag(v));
        } else {
            int p;
            std::cin &gt;&gt; p;

            std::cout &lt;&lt; sgt.query(p, p + 1).mx &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="c-assignment-to-segmenthttpscodeforcescomeducourse2lesson51practicecontest279634problemc"><a href="https://codeforces.com/edu/course/2/lesson/5/1/practice/contest/279634/problem/C">C. Assignment to Segment</a></h3>
<h4 id="题意-44">题意</h4>
<p>有一个由 $n$ 个元素组成的数组，初始填充为零。你需要编写一个数据结构来处理两种类型的查询：</p>
<ul>
<li>为从 $l$ 到 $r-1$ 段上的所有元素赋值 $v$ 、</li>
<li>查找元素 $i$ 的当前值。</li>
</ul>
<h4 id="参考思路-44">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {//信息
    int v;
    Info(int v = 0) : v(v) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(v + b.v);
    }
};

struct Tag {//Tag信息
    int v = -1;
    Tag(int v = -1) : v(v) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        if (b.v == -1) return Tag(v);
        return b;
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {//赋值型Tag
    if (b.v == -1) return a;
    return Info(b.v);
}
</code></pre>
<h4 id="参考代码-43">参考代码</h4>
<pre><code class="language-cpp">template&lt;typename Info, typename Tag&gt;
struct SGT {
    #define lson (p&lt;&lt;1)
    #define rson (p&lt;&lt;1|1)
    std::vector&lt;Info&gt; ans;
    std::vector&lt;Tag&gt; tag;
    int n;
    SGT() : n(0) {}
    SGT(int n, Info v = Info()) {
        init(std::vector&lt;Info&gt;(n, v));
    }
    SGT(std::vector&lt;Info&gt; a) {
        init(a);
    }

    void init(std::vector&lt;Info&gt; a) {
        n = a.size();
        ans.resize(4 &lt;&lt; std::__lg(n));
        tag.resize(4 &lt;&lt; std::__lg(n));
        auto build = [&amp;](auto&amp;&amp; self, int p, int l, int r) -&gt; void {
            if (r - l == 1) {
                ans[p] = a[l];
                return;
            }
            
            int m = (l + r) &gt;&gt; 1;
            self(self, lson, l, m);
            self(self, rson, m, r);

            pushup(p);
        };
        build(build, 1, 0, n);           
    }

    void pushup(int p) {
        ans[p] = ans[lson] + ans[rson];
    }
    
    void pushdown(int p, int l, int r) {
        int m = (l + r) / 2;

        ans[lson] = ans[lson] + tag[p];
        tag[lson] = tag[lson] + tag[p];

        ans[rson] = ans[rson] + tag[p];
        tag[rson] = tag[rson] + tag[p];

        tag[p] = Tag();
    }
    
    void modify(int p, int l, int r, int x, int y, Tag k) {//区间修改
        if (x &lt;= l &amp;&amp; r &lt;= y) {
            ans[p] = ans[p] + k;
            tag[p] = tag[p] + k;
            return;
        }

        pushdown(p, l, r);

        int m = (l + r) &gt;&gt; 1;
        if (x &lt; m) modify(lson, l, m, x, y, k);
        if (y &gt; m) modify(rson, m, r, x, y, k);

        pushup(p);
    }

    void modify(int l, int r, Tag k) {// [可选]
        if (l == r) return;//
        //assert(l &lt; r &amp;&amp; l &gt;= 0 &amp;&amp; r &lt;= n);//可选
        modify(1, 0, n, l, r, k);
    }

    Info query(int p, int l, int r, int x, int y) {//区间查询
        if (x &lt;= l &amp;&amp; r &lt;= y) return ans[p];

        Info res;

        pushdown(p, l, r);
        
        int m = (l + r) &gt;&gt; 1;
        if (x &lt; m) res = res + query(lson, l, m, x, y); 
        if (y &gt; m) res = res + query(rson, m, r, x, y); 

        return res;
    }

    Info query(int l, int r) { // [可选]
        if (l == r) return Info();//
        //assert(l &lt; r &amp;&amp; l &gt;= 0 &amp;&amp; r &lt;= n);//可选
        return query(1, 0, n, l, r);
    }

    #undef lson
    #undef rson

    void show() {
        std::cout &lt;&lt; &quot;=======================\n&quot;;
        for (int i = 0; i &lt; n; i++) {
            std::cout &lt;&lt; query(i, i + 1).v &lt;&lt; &quot; &quot;;
        }
        std::cout &lt;&lt; &quot;\n&quot;;
    }
};

struct Info {//信息
    int v;
    Info(int v = 0) : v(v) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(v + b.v);
    }
};

struct Tag {//Tag信息
    int v = -1;
    Tag(int v = -1) : v(v) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        if (b.v == -1) return Tag(v);
        return b;
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {//赋值型Tag
    if (b.v == -1) return a;
    return Info(b.v);
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    SGT&lt;Info, Tag&gt; sgt(n);
    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int l, r, v;
            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; v;

            sgt.modify(l, r, Tag(v));
        } else {
            int p;
            std::cin &gt;&gt; p ;

            std::cout &lt;&lt; sgt.query(p, p + 1).v &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h2 id="step-2-3">Step 2</h2>
<p>出于码量考虑，该节只给出 Info 和 Tag 的设计，具体实现请自己补充完整。</p>
<h3 id="a-addition-and-minimumhttpscodeforcescomeducourse2lesson52practicecontest279653problema"><a href="https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/A">A. Addition and Minimum</a></h3>
<h4 id="题意-45">题意</h4>
<p>有一个由 $n$ 个元素组成的数组，初始填充为零。你需要编写一个数据结构来处理两种类型的查询：</p>
<ul>
<li>将 $v$ 添加到从 $l$ 到 $r-1$ 的线段上、</li>
<li>查找从 $l$ 到 $r-1$ 的线段上的最小值。</li>
</ul>
<h4 id="参考思路-45">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {//信息
    i64 mi;
    Info(i64 mi = 2e18) : mi(mi) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(std::min(mi, b.mi));
    }
};

struct Tag {//Tag信息
    i64 v;
    Tag(i64 v = 0) : v(v) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        return Tag(v + b.v);
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {
    return Info(a.mi + b.v);
}
</code></pre>
<h3 id="b-multiplication-and-sumhttpscodeforcescomeducourse2lesson52practicecontest279653problemb"><a href="https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/B">B. Multiplication and Sum</a></h3>
<h4 id="题意-46">题意</h4>
<p>有一个由 $n$ 个元素组成的数组，最初填的是 1。你需要编写一个数据结构来处理两种类型的查询：</p>
<ul>
<li>用数字 $v$ 乘从 $l$ 到 $r-1$ 部分的所有元素、</li>
<li>求从 $l$ 到 $r-1$ 的线段上的总和。</li>
</ul>
<p>这两个运算都以 $10^9+7$ 为模来进行。</p>
<h4 id="参考思路-46">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">constexpr int M = 1e9 + 7;

struct Info {//信息
    int sum;
    Info(int sum = 0) : sum(sum) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info((sum + b.sum) % M);
    }
};

struct Tag {//Tag信息
    int v;
    Tag(int v = 1) : v(v) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        return Tag(1ll * v * b.v % M);
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {
    return Info((1ll * a.sum * b.v) % M);
}
</code></pre>
<h3 id="c-bitwise-or-and-andhttpscodeforcescomeducourse2lesson52practicecontest279653problemc"><a href="https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/C">C. Bitwise OR and AND</a></h3>
<h4 id="题意-47">题意</h4>
<p>有一个由 $n$ 个元素组成的数组，初始填充为零。你需要编写一个数据结构来处理两种类型的查询：</p>
<ul>
<li>对从 $l$ 到 $r-1$ 的所有元素执行 $a_i = a_i | v$ （按位 OR）操作</li>
<li>查找从 $l$ 到 $r-1$ 范围内元素的位操作 AND。</li>
</ul>
<h4 id="参考思路-47">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {//信息
    int sum;
    Info(int sum = (1 &lt;&lt; 30) - 1) : sum(sum) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(sum &amp; b.sum);
    }
};

struct Tag {//Tag信息
    int v;
    Tag(int v = 0) : v(v) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        return Tag(v | b.v);
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {
    return Info(a.sum | b.v);
}
</code></pre>
<h3 id="d-addition-and-sumhttpscodeforcescomeducourse2lesson52practicecontest279653problemd"><a href="https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/D">D. Addition and Sum</a></h3>
<h4 id="题意-48">题意</h4>
<p>有一个由 $n$ 个元素组成的数组，初始填充为零。你需要编写一个数据结构来处理两种类型的查询：</p>
<ul>
<li>将 $v$ 添加到从 $l$ 到 $r-1$ 的数据段中、</li>
<li>求从 $l$ 到 $r-1$ 的线段上的和。</li>
</ul>
<h4 id="参考思路-48">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {//信息
    i64 sum;
    int siz;
    Info(i64 sum = 0, int siz = 0) : sum(sum), siz(siz) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(sum + b.sum, siz + b.siz);
    }
};

struct Tag {//Tag信息
    i64 v;
    Tag(i64 v = 0) : v(v) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        return Tag(v + b.v);
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {
    return Info(a.sum + a.siz * b.v, a.siz);
}
</code></pre>
<h3 id="e-assignment-and-minimumhttpscodeforcescomeducourse2lesson52practicecontest279653probleme"><a href="https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/E">E. Assignment and Minimum</a></h3>
<h4 id="题意-49">题意</h4>
<p>有一个由 $n$ 元素组成的数组，初始填充为零。你需要编写一个数据结构来处理两种类型的查询：</p>
<ul>
<li>为从 $l$ 到 $r-1$ 的线段上的所有元素赋值 $v$ 、</li>
<li>查找从 $l$ 到 $r-1$ 的线段上的最小值。</li>
</ul>
<h4 id="参考思路-49">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {//信息
    i64 mi;
    Info(i64 mi = 1e9 + 1) : mi(mi) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(std::min(mi, b.mi));
    }
};

struct Tag {//Tag信息
    i64 v;
    Tag(i64 v = -1) : v(v) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        if (b.v == -1) return Tag(v);
        return b;
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {//赋值型Tag
    if (b.v == -1) return a;
    return Info(b.v);
}
</code></pre>
<h3 id="f-assignment-and-sumhttpscodeforcescomeducourse2lesson52practicecontest279653problemf"><a href="https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/F">F. Assignment and Sum</a></h3>
<h4 id="题意-50">题意</h4>
<p>有一个由 $n$ 个元素组成的数组，初始填充为零。你需要编写一个数据结构来处理两种类型的查询：</p>
<ul>
<li>为从 $l$ 到 $r-1$ 段的所有元素赋值 $v$ 、</li>
<li>求从 $l$ 到 $r-1$ 的线段上的总和。</li>
</ul>
<h4 id="参考思路-50">参考思路</h4>
<pre><code class="language-cpp">struct Info {//信息
    i64 sum;
    int siz;
    Info(i64 sum = 0, int siz = 0) : sum(sum), siz(siz) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(sum + b.sum, siz + b.siz);
    }
};

struct Tag {//Tag信息
    i64 v;
    Tag(i64 v = -1) : v(v) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        if (b.v == -1) return Tag(v);
        return b;
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {//赋值型Tag
    if (b.v == -1) return a;
    return Info(b.v * a.siz, a.siz);
}
</code></pre>
<h2 id="step-3-3">Step 3</h2>
<h3 id="a-assignment-and-maximal-segmenthttpscodeforcescomeducourse2lesson53practicecontest280799problema"><a href="https://codeforces.com/edu/course/2/lesson/5/3/practice/contest/280799/problem/A">A. Assignment and Maximal Segment</a></h3>
<h4 id="题意-51">题意</h4>
<p>有一个由 $n$ 个元素组成的数组，初始填充为零。你需要编写一个数据结构来处理两种类型的查询：</p>
<ul>
<li>为从 $l$ 到 $r-1$ 的线段上的所有元素赋值 $v$ 、</li>
<li>找出总和最大的线段。</li>
</ul>
<h4 id="参考思路-51">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {//信息
    i64 ans;
    i64 L, R;
    i64 sum;
    int siz;
    Info(i64 ans = 0, i64 L = 0, i64 R = 0, i64 sum = 0, int siz = 0)
     : ans(ans), L(L), R(R), sum(sum), siz(siz) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        Info c;
        c.ans = std::max({ans, b.ans, R + b.L});
        c.R = std::max(b.R, R + b.sum);
        c.L = std::max(L, sum + b.L);
        c.sum = sum + b.sum;
        c.siz = siz + b.siz;

        return c;
    }
};

struct Tag {//Tag信息
    i64 active;
    int v;

    Tag(i64 active = 0, int v = 0) : active(active), v(v) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        if (b.active == 0) return Tag(active, v);
        return b;
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {//赋值型Tag
    if (b.active == 0) return a;

    Info c;
    c.sum = 1ll * a.siz * b.v;
    c.ans = c.L = c.R = std::max(0ll, c.sum);
    c.siz = a.siz;
    
    return c;
}
</code></pre>
<h4 id="参考代码-44">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    
    SGT&lt;Info, Tag&gt; sgt(n, Info(0 ,0 ,0 ,0, 1));

    while (m--) {
        int l, r, v;
        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; v;

        sgt.modify(l, r, Tag(1, v));

        std::cout &lt;&lt; sgt.query(0, n).ans &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="b-inverse-and-k-th-onehttpscodeforcescomeducourse2lesson53practicecontest280799problemb"><a href="https://codeforces.com/edu/course/2/lesson/5/3/practice/contest/280799/problem/B">B. Inverse and K-th one</a></h3>
<h4 id="题意-52">题意</h4>
<p>有一个 $n$ 布尔数组，初始值为零。您需要编写一个数据结构来处理两种类型的查询：</p>
<ul>
<li>将 $l$ 至 $r-1$ 段中所有元素的值改为相反值、</li>
<li>找到 $k$ /-1的索引。</li>
</ul>
<h4 id="参考思路-52">参考思路</h4>
<p>维护区间反转，区间求和的数据结构，然后二分区间端点即可。</p>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {//信息
    int one;
    int zer;
    Info(int one = 0, int zer = 0) : one(one), zer(zer) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(one + b.one, zer + b.zer);
    }
};

struct Tag {//Tag信息
    int rev;

    Tag(int rev = 0) : rev(rev) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        return Tag(rev ^ b.rev);
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {
    if (!b.rev) return a;

    return Info(a.zer, a.one);
}
</code></pre>
<h4 id="参考代码-45">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    SGT&lt;Info, Tag&gt; sgt(n, Info(0, 1));
    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int l, r;
            std::cin &gt;&gt; l &gt;&gt; r;

            sgt.modify(l, r, Tag(1));
        } else {
            int k;
            std::cin &gt;&gt; k;

            int l = 0, r = n - 1;
            while (l &lt;= r) {
                int mid = (l + r) / 2;

                if (sgt.query(0, mid + 1).one &gt;= k + 1) r = mid - 1;
                else l = mid + 1;
            }

            std::cout &lt;&lt; r + 1 &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="c-addition-and-first-element-at-least-xhttpscodeforcescomeducourse2lesson53practicecontest280799problemc"><a href="https://codeforces.com/edu/course/2/lesson/5/3/practice/contest/280799/problem/C">C. Addition and First element at least X</a></h3>
<h4 id="题意-53">题意</h4>
<p>有一个由 $n$ 个元素组成的数组，初始填充为零。你需要编写一个数据结构来处理两种类型的查询：</p>
<ul>
<li>将 $v$ 添加到从 $l$ 到 $r-1$ 的线段上的所有元素、</li>
<li>找出最小索引 $j$ ，使得 $j \ge l$ 和 $a[j] \ge x$ .</li>
</ul>
<h4 id="参考思路-53">参考思路</h4>
<p>维护区间加，区间求最大值的线段树，询问时进行线段树上二分即可。</p>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {//信息
    i64 mx;
    Info(i64 mx = 0) : mx(mx) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(std::max(mx, b.mx));
    }
};

struct Tag {//Tag信息
    i64 v;
    Tag(i64 v = 0) : v(v) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        return Tag(v + b.v);
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {
    return Info(a.mx + b.v);
}
</code></pre>
<h4 id="参考代码-46">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    SGT&lt;Info, Tag&gt; sgt(n, Info(0));

    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int l, r, v;
            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; v;

            sgt.modify(l, r, Tag(v));
        } else {
            int x, l;
            std::cin &gt;&gt; x &gt;&gt; l;

            std::cout &lt;&lt; sgt.findFirst(l, n, 
                [&amp;](Info &amp;p) {
                    return p.mx &gt;= x;
                }
            ) &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h2 id="step-4-3">Step 4</h2>
<h3 id="a-assignment-addition-and-sumhttpscodeforcescomeducourse2lesson54practicecontest280801problema"><a href="https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/A">A. Assignment, Addition, and Sum</a></h3>
<h4 id="题意-54">题意</h4>
<p>有一个由 $n$ 个元素组成的数组，初始填充为零。你需要编写一个数据结构来处理三种类型的查询：</p>
<ul>
<li>为从 $l$ 到 $r-1$ 段上的所有元素赋值 $v$ 、</li>
<li>将 $v$ 添加到从 $l$ 到 $r-1$ 线段上的所有元素、</li>
<li>求从 $l$ 到 $r-1$ 的线段上的和。</li>
</ul>
<h4 id="参考思路-54">参考思路</h4>
<p>维护多个Tag的线段树。</p>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {//信息
    i64 sum;
    int siz;
    Info(i64 sum = 0, int siz = 0) : sum(sum), siz(siz) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(sum + b.sum, siz + b.siz);
    }
};

struct Tag {//Tag信息
    i64 add;
    i64 chg;
    Tag(i64 add = 0, i64 chg = -1) : add(add), chg(chg) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        if (b.chg != -1) return b;

        if (chg == -1) return Tag(add + b.add, -1);
        return Tag(0, chg + b.add);
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {//赋值型Tag
    if (b.chg == -1) return Info(a.sum + a.siz * b.add, a.siz);
    return Info(a.siz * b.chg, a.siz);
}
</code></pre>
<h4 id="参考代码-47">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    SGT&lt;Info, Tag&gt; sgt(n, Info(0, 1));

    while (m--) {
        int op, l, r;
        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;

        if (op == 1) {
            int v;
            std::cin &gt;&gt; v;

            sgt.modify(l, r, Tag(0, v));
        } else if (op == 2) {
            int v;
            std::cin &gt;&gt; v;

            sgt.modify(l, r, Tag(v, -1));
        } else {
            std::cout &lt;&lt; sgt.query(l, r).sum &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="b-add-arithmetic-progression-on-segmenthttpscodeforcescomeducourse2lesson54practicecontest280801problemb"><a href="https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/B">B. Add Arithmetic Progression On Segment</a></h3>
<h4 id="题意-55">题意</h4>
<p>给你一个数组 $x$ ，由等于 $0$ 的 $n$ 个元素和两种类型的 $m$ 个查询组成：</p>
<ul>
<li>为一个数段添加算术级数：查询用四个整数 $l, r, a, d$ 来描述&ndash;每个 $l \le i \le r$ 都要执行 $x_i += a + d \cdot (i - l)$ ；</li>
<li>打印给定元素的当前值。</li>
</ul>
<h4 id="参考思路-55">参考思路</h4>
<p>没法用高度封装性的线段树了，考虑如下信息维护，与 pushdown 和 modify 函数设计：</p>
<pre><code class="language-cpp">std::vector&lt;i64&gt; sum, k, d;

void pushdown(int p, int l, int r) {
    int m = (l + r) / 2;

    //左儿子下传lazy
    sum[lson] += k[p] * (m - l) + d[p] * (m - l) * (m - l - 1) / 2;
    k[lson] += k[p];
    d[lson] += d[p];

    i64 k_ = k[p] + (m - l) * d[p];//首项
    sum[rson] += (k_ + k_ + d[p] * (r - m - 1)) * (r - m) / 2;
    k[rson] += k_;
    d[rson] += d[p];

    k[p] = d[p] = 0;
}

void modify(int p, int l, int r, int x, int y, i64 k_, i64 d_) {//区间修改
    if (x &lt;= l &amp;&amp; r &lt;= y) {
        i64 k__ = k_ + (l - x) * d_;

        sum[p] += k__ * (r - l) + d_ * (r - l) * (r - l - 1) / 2;
        k[p] += k__;
        d[p] += d_;
        return;
    }

    pushdown(p, l, r);

    int m = (l + r) &gt;&gt; 1;
    if (x &lt; m) modify(lson, l, m, x, y, k_, d_);
    if (y &gt; m) modify(rson, m, r, x, y, k_, d_);

    pushup(p);
}
</code></pre>
<h4 id="参考代码-48">参考代码</h4>
<pre><code class="language-cpp">#define lson (p&lt;&lt;1)
#define rson (p&lt;&lt;1|1)
std::vector&lt;i64&gt; sum, k, d;
int n;

void pushup(int p) {
    sum[p] = sum[lson] + sum[rson];
}

template&lt;typename T&gt;
void init(std::vector&lt;T&gt; a) {
    n = a.size();
    sum.resize(4 &lt;&lt; std::__lg(n));
    k.resize(4 &lt;&lt; std::__lg(n));
    d.resize(4 &lt;&lt; std::__lg(n));
}

void pushdown(int p, int l, int r) {
    int m = (l + r) / 2;

    //左儿子下传lazy
    sum[lson] += k[p] * (m - l) + d[p] * (m - l) * (m - l - 1) / 2;
    k[lson] += k[p];
    d[lson] += d[p];

    i64 k_ = k[p] + (m - l) * d[p];//首项
    sum[rson] += (k_ + k_ + d[p] * (r - m - 1)) * (r - m) / 2;
    k[rson] += k_;
    d[rson] += d[p];

    k[p] = d[p] = 0;
}

void modify(int p, int l, int r, int x, int y, i64 k_, i64 d_) {//区间修改
    if (x &lt;= l &amp;&amp; r &lt;= y) {
        i64 k__ = k_ + (l - x) * d_;

        sum[p] += k__ * (r - l) + d_ * (r - l) * (r - l - 1) / 2;
        k[p] += k__;
        d[p] += d_;
        return;
    }

    pushdown(p, l, r);

    int m = (l + r) &gt;&gt; 1;
    if (x &lt; m) modify(lson, l, m, x, y, k_, d_);
    if (y &gt; m) modify(rson, m, r, x, y, k_, d_);

    pushup(p);
}

void modify(int l, int r, i64 k, i64 d) {// [可选]
    if (l == r) return;//
    assert(l &lt; r &amp;&amp; l &gt;= 0 &amp;&amp; r &lt;= n);
    modify(1, 0, n, l, r, k, d);
}

i64 query(int p, int l, int r, int x, int y) {//区间查询
    if (x &lt;= l &amp;&amp; r &lt;= y) return sum[p];

    i64 res = 0;

    pushdown(p, l, r);
    
    int m = (l + r) &gt;&gt; 1;
    if (x &lt; m) res = res + query(lson, l, m, x, y); 
    if (y &gt; m) res = res + query(rson, m, r, x, y); 

    return res;
}

i64 query(int l, int r) { // [可选]
    if (l == r) return 0;//
    assert(l &lt; r &amp;&amp; l &gt;= 0 &amp;&amp; r &lt;= n);
    return query(1, 0, n, l, r);
}

#undef lson
#undef rson

void show() {
    std::cout &lt;&lt; &quot;=======================\n&quot;;
    for (int i = 0; i &lt; n; i++) {
        std::cout &lt;&lt; query(i, i + 1) &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; &quot;\n&quot;;
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    init(std::vector&lt;int&gt;(n, 0));

    while (m--) {
        int op;
        std::cin &gt;&gt; op;

        if (op == 1) {
            int l, r, a, d;
            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; a &gt;&gt; d;

            modify(l - 1, r, a, d);
        } else {
            int p;
            std::cin &gt;&gt; p;
            std::cout &lt;&lt; query(p - 1, p) &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="c-painterhttpscodeforcescomeducourse2lesson54practicecontest280801problemc"><a href="https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/C">C. Painter</a></h3>
<h4 id="题意-56">题意</h4>
<p>意大利抽象艺术家 F. Mandarino 开始对绘制一维黑白画感兴趣。他试图找到画面中黑色部分的最佳位置和数量。为此，他在线条上花费了白段和黑段，在每次操作之后，他都想知道最终画面中黑色段的数量及其总长度。</p>
<p>最初，线条是白色的。您的任务是编写一个程序，在每次操作后输出艺术家感兴趣的数据。</p>
<h4 id="参考思路-56">参考思路</h4>
<pre><code class="language-cpp">struct Info {//信息
    int cnt, sum, siz;
    bool L, R;//黑色段是否挨着左边和右边
    Info(int cnt = 0, int sum = 0, int siz = 0, bool L = 0, bool R = 0) : cnt(cnt), sum(sum), siz(siz), L(L), R(R) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        Info c;
        
        c.L = L;
        c.R = b.R;
        c.cnt = cnt + b.cnt - (R &amp; b.L);
        c.siz = siz + b.siz;
        c.sum = sum + b.sum;

        return c;
    }
};

struct Tag {//Tag信息
    int chg;
    Tag(int chg = -1) : chg(chg) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        if (b.chg != -1) return b;
        return Tag(chg);
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {//赋值型Tag
    if (b.chg == -1) return a;

    return Info(b.chg, a.siz * b.chg, a.siz, b.chg, b.chg);
}
</code></pre>
<h4 id="参考代码-49">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n;
    std::cin &gt;&gt; n;

    SGT&lt;Info, Tag&gt; sgt(1e6, Info(0, 0, 1, 0, 0));
    while (n--) {
        char c;
        int x, l;
        std::cin &gt;&gt; c &gt;&gt; x &gt;&gt; l;

        x += 5e5;

        sgt.modify(x, x + l, Tag(c == 'B'));

        auto z = sgt.query(0, 1e6);
        std::cout &lt;&lt; z.cnt &lt;&lt; &quot; &quot; &lt;&lt; z.sum &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<p>这里提供一种不用线段树的做法（据说就是珂朵莉树？）</p>
<pre><code class="language-cpp">void solve0() {
    int n;
    std::cin &gt;&gt; n;

    auto cmp = [](const auto&amp; a, const auto&amp; b) -&gt; auto {
        return a.second &lt; b.first;
    };
    std::set&lt;std::pair&lt;int, int&gt;, decltype(cmp)&gt; s(cmp);

    i64 cnt = 0;

    auto insert = [&amp;](int l, int r) {
        if (l &gt; r) return;

        auto it = s.find({l - 1, r + 1});
        while (it != s.end()) {
            if (it-&gt;first &gt; r + 1) break;

            auto [ll, rr] = *it;
            it++; s.erase(std::prev(it));

            cnt -= rr - ll + 1;

            l = std::min(l, ll);
            r = std::max(r, rr);
        }

        s.insert({l, r});
        cnt += r - l + 1;
    };

    auto erase = [&amp;](int l, int r) {
        if (l &gt; r) return;

        auto it = s.find({l, r});
        while (it != s.end()) {
            if (it-&gt;first &gt; r) break;

            auto [ll, rr] = *it;
            it++; s.erase(std::prev(it));

            cnt -= rr - ll + 1;

            insert(ll, l - 1);
            insert(r + 1, rr);
        }
    };

    while (n--) {
        char op;
        int l, x;
        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; x;

        int r = l + x - 1;

        if (op == 'W') {
            erase(l, r);
        } else {
            insert(l, r);
        }

        std::cout &lt;&lt; s.size() &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="d-problem-about-weighted-sumhttpscodeforcescomeducourse2lesson54practicecontest280801problemd"><a href="https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/D">D. Problem About Weighted Sum</a></h3>
<h4 id="题意-57">题意</h4>
<p>在这个问题中，你要回答关于给定数组的加权和的查询。从形式上看，你将得到一个长度为 $n$ 的数组 $a[1 \dots n]$ 。你要回答两种类型的查询：</p>
<ul>
<li>分段变化：给定三个整数 $l, r, d$ ，将 $d$ 添加到数组的每个元素 $i$ 中，使得 $l \le i \le r$ 、</li>
<li>计算加权和：给定两个整数 $l, r$ ，计算并打印 $a[l] \cdot 1 + a[l + 1] \cdot 2 + \dots \ a[r] \cdot (r - l + 1)$ 。</li>
</ul>
<h4 id="参考思路-57">参考思路</h4>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {//信息
    i64 sum, wsum;
    int siz;

    Info(i64 sum = 0, i64 wsum = 0, int siz = 0)
     : sum(sum), wsum(wsum), siz(siz) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(
            sum + b.sum,
            wsum + siz * b.sum + b.wsum,
            siz + b.siz
        );
    }
};

struct Tag {//Tag信息
    int d = 0;
    Tag(int d = 0) : d(d) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        return Tag(d + b.d);
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {
    return Info(
        a.sum + a.siz * b.d,
        a.wsum + 1ll * a.siz * (a.siz + 1) / 2 * b.d,
        a.siz
    );
}
</code></pre>
<h4 id="参考代码-50">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;Info&gt; a(n);
    for (auto &amp;v : a) {
        std::cin &gt;&gt; v.sum;
        v.wsum = v.sum;
        v.siz = 1;
    }

    SGT&lt;Info, Tag&gt; sgt(a);

    while (m--) {
        int op, l, r;
        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;

        if (op == 1) {
            int d;
            std::cin &gt;&gt; d;

            sgt.modify(l - 1, r, Tag(d));

        } else {
            std::cout &lt;&lt; sgt.query(l - 1, r).wsum &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="e-wallhttpscodeforcescomeducourse2lesson54practicecontest280801probleme"><a href="https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/E">E. Wall</a></h3>
<h4 id="题意-58">题意</h4>
<p><em>这是 2014 年国际信息学奥林匹克竞赛（IOI）中的一道难题。尝试使用线段树来解决它！</em></p>
<p>建嘉正在用大小相同的砖块堆砌一堵墙。这堵墙由 $n$ 列砖组成，从左到右编号为 $0$ 至 $(n - 1)$ 。这些砖柱可能有不同的高度。柱子的高度就是其中砖块的数量。</p>
<p>建甲砌墙的过程如下。一开始，任何一列都没有砖块。然后，&ldquo;健嘉 &ldquo;会经历 $k$ 个添加或移除砖块的阶段。当所有 $k$ 个阶段都完成后，建造过程结束。在每个阶段中，&ldquo;佳佳 &ldquo;都会得到一系列连续的砖柱和高度 $h$ ，并执行以下步骤：</p>
<ul>
<li>在加砖阶段，&ldquo;佳佳 &ldquo;会在给定范围内的砖块少于 $h$ 的柱子上加砖块，这样这些柱子就正好有 $h$ 块砖块。他不对拥有 $h$ 或更多砖块的列做任何操作。</li>
<li>在删除阶段，贾健从给定范围内有多于 $h$ 块砖的列中删除砖块，使它们正好有 $h$ 块砖。而对于砖块数少于或等于 $h$ 的列，他什么也不做。</li>
</ul>
<p>你的任务是确定墙的最终形状。</p>
<h4 id="参考思路-58">参考思路</h4>
<p>考虑维护一个线段树，Tag 维护区间合法的最小最大值，Info 维护每个点的高度值，如果 Info 代表的值小于 Tag 维护的最小值，那么直接将 Info 代表的值设置为这个最小值；如果 Info 代表的值大于 Tag 维护的最大值，那么直接将 Info 代表的值设置为这个最大值；否则不做操作。</p>
<p>而 Tag 对 Tag 的更新也类似，指需要对原 Tag 的两端分别用新 Tag，按照上述方式，分别“夹”一下即可。</p>
<p>考虑如下维护的信息与信息间的合并设计：</p>
<pre><code class="language-cpp">struct Info {//信息
    i64 v;

    Info(i64 v = 0) : v(v) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return b;
    }
};

struct Tag {//Tag信息
    i64 L, R;

    Tag(i64 L = -1e9, i64 R = 1e9) : L(L), R(R) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        return Tag(std::clamp(L, b.L, b.R), std::clamp(R, b.L, b.R));
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {
    return Info(std::clamp(a.v, b.L, b.R));
}
</code></pre>
<p>其中 clamp 恰好就能实现上述 “夹” 的操作。</p>
<h4 id="参考代码-51">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;Info&gt; a(n, Info(0));

    SGT&lt;Info, Tag&gt; sgt(a);

    while (m--) {
        int op, l, r, h;
        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; h;

        if (op == 1) {//add，将低于 h 的置为 h
            sgt.modify(l, r + 1, Tag(h, 1e9));
        } else {
            sgt.modify(l, r + 1, Tag(-1e9, h));
        }
    }

    for (int i = 0; i &lt; n; i++) {
        std::cout &lt;&lt; sgt.query(i, i + 1).v &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="f-mountainhttpscodeforcescomeducourse2lesson54practicecontest280801problemf"><a href="https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/F">F. Mountain</a></h3>
<h4 id="题意-59">题意</h4>
<p><em>这是 IOI 2005 中的一个问题，也是用线段树解决的</em></p>
<p>山地游乐园开设了一个全新的模拟过山车。模拟轨道由 $n$ 根端对端连接的轨道组成，第一根轨道的起点固定在高程 0 处。操作员 Byteman 可以通过调整若干连续轨道的高程变化来随意重新配置轨道。其他轨道的高程变化不受影响。每次调整轨道时，后面的轨道都会根据需要升高或降低，以连接轨道，同时将起点保持在标高 0 处。</p>
<p>每次启动时，都会以足够的能量将轿厢发射至高度 $h$ 。也就是说，只要轨道的高度不超过 $h$ ，只要没有到达轨道的终点，小车就会继续行驶。</p>
<p>给定当天所有的乘车记录和轨道配置变化，计算每次乘车时小车停止前所经过的轨道数。</p>
<p>模拟器内部将轨道表示为 $n$ 升高变化 $d_i$ 的序列。最初轨道是水平的，即所有 $i$ 都是 $d_i = 0$ 。</p>
<p><img src="https://espresso.codeforces.com/e071095109aa8eb96cdeac803666d7f0281204fb.png" alt=""></p>
<p>在一天中，运行和重新配置是交错进行的。每次重新配置由三个数字组成： $a$ 、 $b$ 和 $D$ 。需要调整的区段包括 $a$ 至 $b$ （含）的轨道。区段中每条轨道的高程变化设置为 $D$ 。</p>
<p><img src="https://espresso.codeforces.com/61c7c5dac72597da11a9dfed548102159b9f819e.png" alt=""></p>
<p>每个轨道都由一个数字 $h$ 指定，即轨道车可以达到的最大高度。</p>
<h4 id="参考思路-59">参考思路</h4>
<p>细节非常多的题，整理完题意后，其实就是让你维护一个差分数组，实现对差分数组进行区间修改，查询第一次 $[1, p]$ 大于 $h$ 的下标 $p$，那么我们按照题意设计 Info 和 Tag 即可。</p>
<p>注意，题目的 $n$ 高达 $10^9$，但是只有最多 $10^5$ 次操作。所以要先进行离散化分块，询问时在检查出的块内二分，这点比较麻烦。</p>
<h4 id="参考代码-52">参考代码</h4>
<pre><code class="language-cpp">#define int i64

constexpr int inf = 1e9 + 1;

struct Info {//信息
    int sum, presummax;

    int siz;

    Info(int sum = 0, int presummax = 0, int siz = 0)
     : sum(sum), presummax(presummax), siz(siz) {}
    Info operator+(const Info&amp; b) const {//信息直接合并方式
        return Info(sum + b.sum, std::max(presummax, sum + b.presummax), siz + b.siz);
    }
};

struct Tag {//Tag信息
    int chg;
    Tag(int chg = -inf) : chg(chg) {}
    Tag operator+(const Tag&amp; b) const {//Tag之间合并关系
        if (b.chg == -inf) return Tag(chg);
        return b;
    }
};

//Tag与Info之间的合并关系
Info operator+(const Info&amp; a, const Tag&amp; b) {//赋值型Tag
    if (b.chg == -inf) return a;

    return Info(a.siz * b.chg, std::max&lt;int&gt;(0, a.siz * b.chg), a.siz);
}

struct OP {
    char op;
    int l, r, d;
    int h;
};


void solve() {
    int n;
    std::cin &gt;&gt; n;

    std::vector&lt;OP&gt; ops;
    std::vector&lt;int&gt; b;
    auto get = [&amp;](int x) -&gt; int {
        return std::lower_bound(b.begin(), b.end(), x) - b.begin();
    };

    char op;
    while (std::cin &gt;&gt; op) {
        if (op == 'E') break;

        if (op == 'I') {
            int l, r, d;
            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;

            b.push_back(l - 1);
            b.push_back(l);
            b.push_back(r);
            b.push_back(r + 1);
            ops.push_back(OP{op, l, r, d, 0});
        } else {
            int h;
            std::cin &gt;&gt; h;

            ops.push_back(OP{op, 0, 0, 0, h});
        }
    }

    b.push_back(0);
    b.push_back(1);
    b.push_back(n + 1);

    std::sort(b.begin(), b.end());
    b.erase(std::unique(b.begin(), b.end()), b.end());
    int m = b.size();

    std::vector&lt;Info&gt; a(m);
    a[m - 1].siz = 1;

    for (int i = 1; i &lt; m - 1; i++) {
        a[i].siz = b[i + 1] - b[i];
    }

    SGT&lt;Info, Tag&gt; sgt(a);

    sgt.modify(m - 1, m, Tag(1e9 + 1));

    for (auto &amp;[op, l, r, v, h] : ops) {
        if (op == 'I') {
            sgt.modify(get(l), get(r + 1), Tag(v));
        } else {
            int l = 1, r = m - 1, ans = m - 1;
            while (l &lt;= r) {
                int mid = (l + r) / 2;

                if (sgt.query(0, mid + 1).presummax &gt; h) r = mid - 1, ans = mid;
                else l = mid + 1;
            }

            auto z = sgt.query(ans, ans + 1);
            int diff = z.sum / z.siz;
            int t = (h - sgt.query(0, ans).sum) / diff;
            int real_ans = sgt.query(0, ans).siz + t;

            std::cout &lt;&lt; real_ans &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h1 id="binary-search">Binary Search</h1>
<h2 id="step-1-4">Step 1</h2>
<h3 id="a-binary-searchhttpscodeforcescomeducourse2lesson61practicecontest283911problema"><a href="https://codeforces.com/edu/course/2/lesson/6/1/practice/contest/283911/problem/A">A. Binary Search</a></h3>
<h4 id="题意-60">题意</h4>
<p>实现二分算法。</p>
<p>输入的第一行包含整数 $n$ 和 $k$ （ $1 \le n$ , $k \le 10^5$ ），即数组的长度和查询次数。第二行包含数组中的 $n$ 个元素，按非递减顺序排序。第三行包含 $k$ 个查询。所有数组元素和查询次数都是整数，每个元素的绝对值都不超过 $10^9$ 。</p>
<h4 id="参考思路-60">参考思路</h4>
<p>板子题。</p>
<h4 id="参考代码-53">参考代码</h4>
<p>想练自己写实现。</p>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::set&lt;int&gt; s;

    while (n--) {
        int x;
        std::cin &gt;&gt; x;
        s.insert(x);
    }

    while (m--) {
        int x;
        std::cin &gt;&gt; x;

        std::cout &lt;&lt; (s.count(x) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="b-closest-to-the-lefthttpscodeforcescomeducourse2lesson61practicecontest283911problemb"><a href="https://codeforces.com/edu/course/2/lesson/6/1/practice/contest/283911/problem/B">B. Closest to the Left</a></h3>
<h4 id="题意-61">题意</h4>
<p>给定一个由 $n$ 个数字（按非递减顺序排列）和 $k$ 个查询组成的数组。请为每个查询打印不大于给定值的数组元素的最大索引。</p>
<h4 id="参考思路-61">参考思路</h4>
<p>二分即可，自己写实现去</p>
<h4 id="参考代码-54">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::set&lt;std::pair&lt;int, int&gt;&gt; s;

    for (int i = 1; i &lt;= n; i++) {
        int x;
        std::cin &gt;&gt; x;

        s.insert({x, i});
    }

    while (m--) {
        int x;
        std::cin &gt;&gt; x;

        auto it = s.lower_bound({x, n + 1});
        if (it == s.begin()) std::cout &lt;&lt; 0 &lt;&lt; &quot;\n&quot;;
        else {
            it--;
            std::cout &lt;&lt; it-&gt;second &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="c-closest-to-the-righthttpscodeforcescomeducourse2lesson61practicecontest283911problemc"><a href="https://codeforces.com/edu/course/2/lesson/6/1/practice/contest/283911/problem/C">C. Closest to the Right</a></h3>
<h4 id="题意-62">题意</h4>
<p>给定一个由 $n$ 个数字（按非递减顺序排列）和 $k$ 个查询组成的数组。请为每个查询打印不小于给定数组元素的最小索引。</p>
<h4 id="参考思路-62">参考思路</h4>
<p>同理，二分即可</p>
<h4 id="参考代码-55">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    
    std::set&lt;std::pair&lt;int, int&gt;&gt; s;

    for (int i = 1; i &lt;= n; i++) {
        int x;
        std::cin &gt;&gt; x;

        s.insert({x, i});
    }

    while (m--) {
        int x;
        std::cin &gt;&gt; x;

        auto it = s.lower_bound({x, 0});

        if (it == s.end()) std::cout &lt;&lt; n + 1 &lt;&lt; &quot;\n&quot;;
        else std::cout &lt;&lt; it-&gt;second &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="d-fast-searchhttpscodeforcescomeducourse2lesson61practicecontest283911problemd"><a href="https://codeforces.com/edu/course/2/lesson/6/1/practice/contest/283911/problem/D">D. Fast search</a></h3>
<h4 id="题意-63">题意</h4>
<p>给你一个由 $n$ 个整数 $a_1, a_2, &hellip;, a_n$ 组成的数组 $a$ 。</p>
<p>你的任务是回答 &ldquo;有多少个数字的值在 $l$ 和 $r$ 之间？</p>
<h4 id="参考思路-63">参考思路</h4>
<p>排序后离散化，前缀和预处理贡献，最后二分左右端点即可。</p>
<h4 id="参考代码-56">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n;
    std::cin &gt;&gt; n;

    std::map&lt;int, int&gt; cnt;
    while (n--) {
        int x;
        std::cin &gt;&gt; x;
        cnt[x]++;
    }

    std::vector&lt;int&gt; b;
    for (auto &amp;[k, v] : cnt) {
        b.push_back(k);
    }
    auto get = [&amp;](int x) -&gt; int {
        return std::lower_bound(b.begin(), b.end(), x) - b.begin();
    };

    std::vector&lt;int&gt; pre(b.size() + 1);
    for (int i = 0; i &lt; b.size(); i++) {
        pre[i + 1] = pre[i] + cnt[b[i]];
    }

    int q;
    std::cin &gt;&gt; q;
    while (q--) {
        int l, r;
        std::cin &gt;&gt; l &gt;&gt; r;

        std::cout &lt;&lt; pre[get(r + 1)] - pre[get(l)] &lt;&lt; &quot; &quot;;
    }
}
</code></pre>
<h2 id="step-2-4">Step 2</h2>
<h3 id="a-packing-rectangleshttpscodeforcescomeducourse2lesson62practicecontest283932problema"><a href="https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/A">A. Packing Rectangles</a></h3>
<h4 id="题意-64">题意</h4>
<p>有 $n$ 个大小相同的长方形：宽为 $w$ ，长为 $h$ 。要求找出一个最小的正方形，将这些矩形填入其中。矩形不能旋转。</p>
<p><img src="https://espresso.codeforces.com/848cbd12b2d10d145d552a6cbb35f3bd244b8bed.png" alt=""></p>
<h4 id="参考思路-64">参考思路</h4>
<p>考虑二分答案，check函数中计算给定边长的正方形，最多能装多少矩形。</p>
<h4 id="参考代码-57">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 w, h, n;
    std::cin &gt;&gt; w &gt;&gt; h &gt;&gt; n;

    if (h &gt; w) std::swap(w, h);

    auto ck = [&amp;](i64 x) -&gt; bool {
        //最密堆积，有没有不用 int128 的代码？不清楚
        return i128((x / w) + (x % h) / w) * (x / h) &gt;= n; 
    };

    i64 l = h, r = n * w, ans = n * w;
    while (l &lt;= r) {
        i64 mid = (l + r) / 2;
        if (ck(mid)) r = mid - 1, ans = mid;
        else l = mid + 1;
    }

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="b-ropeshttpscodeforcescomeducourse2lesson62practicecontest283932problemb"><a href="https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/B">B. Ropes</a></h3>
<h4 id="题意-65">题意</h4>
<p>有 $n$ 根绳子，你需要从中剪出 $k$ 段同样长的绳子。求最大长度。</p>
<h4 id="参考思路-65">参考思路</h4>
<p>考虑二分答案，check函数中枚举所有绳子，累计所有绳子提供的总贡献。</p>
<p>时间复杂度：$O(50n)$
<em>实数二分，最多二分50次就能保证精度了</em></p>
<h4 id="参考代码-58">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;

    std::vector&lt;int&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    auto ck = [&amp;](ld x) -&gt; bool {
        int cnt = 0;
        for (auto &amp;i : a) cnt += int(i / x);

        return cnt &gt;= k;
    };

    ld l = 0, r = 1e7;
    for (int _ = 0; _ &lt; 50; _++) {
        ld mid = (l + r) / 2;
        if (ck(mid)) l = mid;
        else r = mid;
    }

    std::cout &lt;&lt; std::setprecision(7) &lt;&lt; std::fixed &lt;&lt; l;
}
</code></pre>
<h3 id="c-very-easy-taskhttpscodeforcescomeducourse2lesson62practicecontest283932problemc"><a href="https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/C">C. Very Easy Task</a></h3>
<h4 id="题意-66">题意</h4>
<p>今天上午，评委会决定在奥林匹克竞赛题库中再增加一个 &ldquo;非常简单的问题&rdquo;。组委会执行秘书已经打印了一份声明，现在他们需要在奥林匹克竞赛开始前再复印 $n$ 份。他手头有两台复印机，其中一台复印一张需时 $x$ 秒，另一台复印一张需时 $y$ 秒。(可以使用一台复印机，也可以同时使用两台复印机。不仅可以复印原件，还可以复印复印件）。帮助他们找出复印 $n$ 份声明所需的最短时间。</p>
<h4 id="参考思路-66">参考思路</h4>
<p>考虑二分答案，二分函数中判断给定时间内是否能够满足要求即可。注意原件不计入复印件数量。</p>
<h4 id="参考代码-59">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, x ,y;
    std::cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;

    if (x &gt; y) std::swap(x, y);

    auto ck = [&amp;](i64 m) -&gt; bool {
        if (m &lt; x) return 0;

        return 1 + (m - x) / x + (m - x) / y &gt;= n;
    };

    i64 l = 1, r = n * y;
    while (l &lt;= r) {
        i64 mid = (l + r) / 2;
        if (ck(mid)) r = mid - 1;
        else l = mid + 1;
    }

    std::cout &lt;&lt; r + 1;
}
</code></pre>
<h3 id="d-children-holidayhttpscodeforcescomeducourse2lesson62practicecontest283932problemd"><a href="https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/D">D. Children Holiday</a></h3>
<h4 id="题意-67">题意</h4>
<p>儿童节的组织者正在计划为它充气 $$$m$$$ 气球。他们邀请了 $$$n$$$ 助手， $$$i$$$ 助手在 $$$t _ i$$$ 分钟内给气球充气，但是每次在 $$$z _ i$$$ 气球充气后，他就会感到疲劳并休息 $$$y _ i$$$ 分钟。现在这个节日的组织者想知道什么时候之后所有的气球都会被充气，这是助手们最优化的工作，以及每个气球会充多少气。(如果助理已经给气球充气，需要休息，但是他不需要再给气球充气，那么就认为他在最后一个气球充气结束后立即完成了工作，而不是在休息之后)。</p>
<h4 id="参考思路-67">参考思路</h4>
<p>考虑二分答案，二分用时 $T$ 内是否能够完成任务。最后输出答案时注意要控制所有人充气的气球数之和，要刚好等于 $m$。</p>
<h4 id="参考代码-60">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int m, n;
    std::cin &gt;&gt; m &gt;&gt; n;

    std::vector&lt;std::array&lt;int, 3&gt;&gt; a(n);//t, z, y

    for (auto &amp;[t, z, y] : a) std::cin &gt;&gt; t &gt;&gt; z &gt;&gt; y;

    auto ck = [&amp;](int x) -&gt; bool {
        int cnt = 0;
        for (auto &amp;[t, z, y] : a) {
            cnt += (x / (t * z + y)) * z + std::min(z, (x % (t * z + y)) / t);
        }

        return cnt &gt;= m;
    };

    int l = 0, r = 2e9, ans = -1;
    while (l &lt;= r) {
        int mid = (l + r) / 2;

        if (ck(mid)) r = mid - 1, ans = mid;
        else l = mid + 1;
    }

    assert(ans != -1);

    std::cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;

    i64 sum = m;

    int x = ans;
    for (auto &amp;[t, z, y] : a) {
        int tmp = (x / (t * z + y)) * z + std::min(z, (x % (t * z + y)) / t);
        tmp = std::min(tmp, sum);
        sum -= tmp;
        std::cout &lt;&lt; tmp &lt;&lt; &quot; &quot;;
    }
}
</code></pre>
<h3 id="e-equationhttpscodeforcescomeducourse2lesson62practicecontest283932probleme"><a href="https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/E">E. Equation</a></h3>
<h4 id="题意-68">题意</h4>
<p>求一个数 $x$ ，使得 $x^2+\sqrt{x}=c$ .</p>
<h4 id="参考思路-68">参考思路</h4>
<p>一眼函数在定义域上单调递增，直接跑实数二分即可。</p>
<h4 id="参考代码-61">参考代码</h4>
<pre><code class="language-cpp">ld f(ld x) {
    return x * x + std::sqrt(x);
}

void solve() {
    ld c;
    std::cin &gt;&gt; c;

    ld l = 0, r = 1e6;
    for (int _ = 0; _ &lt; 50; _++) {
        ld mid = (l + r) / 2;

        if (f(mid) &gt;= c) r = mid;
        else l = mid;
    }

    std::cout &lt;&lt; std::setprecision(7) &lt;&lt; std::fixed &lt;&lt; l;
}
</code></pre>
<h3 id="f-string-gamehttpscodeforcescomeducourse2lesson62practicecontest283932problemf"><a href="https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/F">F. String Game</a></h3>
<h4 id="题意-69">题意</h4>
<p>Petya 有一个单词 $t$ ，他想用这个单词组成单词 $p$ 。Petya 开始按照一定的顺序删除字母，这被描述为单词 $t$ 中字母指数的排列组合： $a_1 &hellip; a_{|t|}$ .请注意，删除字母后，编号不会改变。</p>
<p>他的哥哥瓦夏担心彼佳会删除过多的字母，因此最终无法得到单词 $p$ 。瓦夏的任务是在某一时刻阻止哥哥，并以这样的方式完成自己的删除，这样得到的单词就是 $p$ 。由于 Petya 喜欢这项活动，Vasya 希望尽可能晚地阻止他。您的任务是在 Vasya 阻止他之前，告诉他 Petya 可以删除多少个字母。</p>
<p>从 $t$ 中删除字母可以得到单词 $p$ 。</p>
<h4 id="参考思路-69">参考思路</h4>
<p>二分答案，二分函数中判断未删除的字符是否能组合出 $p$。</p>
<p>时间复杂度：$O(n\logn)$</p>
<h4 id="参考代码-62">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    std::string s, t;
    std::cin &gt;&gt; s &gt;&gt; t;

    int n = s.size();
    std::vector&lt;int&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    std::vector&lt;int&gt; rmp(n);
    for (int i = 0; i &lt; n; i++) {
        rmp[a[i] - 1] = i;
    }

    auto ck = [&amp;](int x) -&gt; bool {
        int j = 0;
        for (int i = 0; i &lt; n &amp;&amp; j &lt; t.size(); i++) {
            if (rmp[i] &lt; x || t[j] != s[i]) continue;
            j++;
        }

        return j == t.size();
    };

    int l = 0, r = n;
    while (l &lt;= r) {
        int mid = (l + r) / 2;

        if (ck(mid)) l = mid + 1;
        else r = mid - 1;
    }

    std::cout &lt;&lt; l - 1;
}
</code></pre>
<h3 id="g-student-councilshttpscodeforcescomeducourse2lesson62practicecontest283932problemg"><a href="https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/G">G. Student Councils</a></h3>
<h4 id="题意-70">题意</h4>
<p>给定数字 $k$ 。每个学生会必须由 $k$ 名学生组成。重要规则：每个学生会应由来自不同小组的学生组成。也就是说，不能有两个来自同一小组的学生参加同一个学生会。</p>
<p>当然，每个学生参加的理事会不得超过一个（有些学生可能不参加任何理事会）。</p>
<p>给定数组 $a[1..n]$ ，其中 $a[i]$ 是 $i$ -th 组的学生人数。最多可以成立多少个理事会？</p>
<h4 id="参考思路-70">参考思路</h4>
<p>套路题，先 sort 一下，保留前 $k$ 个不选，剩下的都能选，可以证明存在某种贪心策略，保证和前面 $k$ 组拼起来后每行选择了恰好 $k$ 个不同的元素。</p>
<p>然后由于答案具有单调性，可以直接二分答案，判断是否可以成立 $x$ 组即可。</p>
<p><img src="https://s21.ax1x.com/2025/02/17/pEMEF76.png" alt="pEMEF76.png"></p>
<h4 id="参考代码-63">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 k, n;
    std::cin &gt;&gt; k &gt;&gt; n;

    std::vector&lt;i64&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    std::sort(a.rbegin(), a.rend());

    i64 cnt = 0;
    for (i64 i = k; i &lt; n; i++) {
        cnt += a[i];
    }

    auto ck = [&amp;](i64 x) -&gt; bool {
        i64 sum = 0;
        for (i64 i = 0; i &lt; k; i++) {
            sum += std::min(a[i], x);
        }

        return sum + cnt &gt;= x * k;
    };

    i64 l = 0, r = 2e16;
    while (l &lt;= r) {
        i64 mid = (l + r) / 2;

        if (ck(mid)) l = mid + 1;
        else r = mid - 1;
    }

    std::cout &lt;&lt; l - 1;
}
</code></pre>
<h3 id="h-hamburgershttpscodeforcescomeducourse2lesson62practicecontest283932problemh"><a href="https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/H">H. Hamburgers</a></h3>
<h4 id="题意-71">题意</h4>
<p>波利卡普斯非常喜欢吃汉堡包。他尤其喜欢自己亲手做的汉堡包。波利卡普认为，制作汉堡包只需要三种像样的材料：面包、香肠和奶酪。他把自己最喜欢的 &ldquo;波利卡普汉堡包 &ldquo;的配方写成一串字母 &ldquo;B&rdquo;（面包）、&ldquo;S&rdquo;（香肠）和 &ldquo;C&rdquo;（奶酪）。食谱中的配料从下到上依次排列，例如，食谱 &ldquo;BSCBS &ldquo;代表汉堡包，其中的配料从下到上依次为面包、香肠、奶酪、面包和香肠。</p>
<p>波利卡普斯厨房里有 $n_b$ 块面包、 $n_s$ 块香肠和 $n_c$ 块奶酪。此外，附近的商店也有这三种食材，价格分别为 $p_b$ 卢布一个面包、 $p_s$ 个香肠和 $p_c$ 块奶酪。</p>
<p>波利卡普斯有 $r$ 卢布，他准备用它们来购物。他最多可以做多少个汉堡包？你可以假设波利卡普不能掰开或切碎任何一块面包、香肠或奶酪。此外，店里每种材料的数量都是无限的。</p>
<h4 id="参考思路-71">参考思路</h4>
<p>直接二分答案，二分是否能够做 $x$ 个汉堡，二分函数中统计需要花费的价钱，与 $r$ 比较即可。</p>
<h4 id="参考代码-64">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    std::string s;
    std::cin &gt;&gt; s;

    std::map&lt;char, int&gt; cnt, cost, need;
    std::cin &gt;&gt; cnt['B'] &gt;&gt; cnt['S'] &gt;&gt; cnt['C'];
    std::cin &gt;&gt; cost['B'] &gt;&gt; cost['S'] &gt;&gt; cost['C'];

    for (auto &amp;c : s) need[c]++;

    i64 p;
    std::cin &gt;&gt; p;

    auto ck = [&amp;](i64 x) -&gt; bool {
        i64 cost_ = 0;
        for (auto &amp;[k, v] : cnt) {
            if (v &lt; x * need[k]) {
                cost_ += (x * need[k] - v) * cost[k];
            }
        }

        return cost_ &lt;= p;
    };

    i64 l = 0, r = 1e15;
    while (l &lt;= r) {
        i64 mid = (l + r) / 2;

        if (ck(mid)) l = mid + 1;
        else r = mid - 1;
    }

    std::cout &lt;&lt; l - 1;
}
</code></pre>
<h2 id="step-3-4">Step 3</h2>
<h3 id="a-get-togetherhttpscodeforcescomeducourse2lesson63practicecontest285083problema"><a href="https://codeforces.com/edu/course/2/lesson/6/3/practice/contest/285083/problem/A">A. Get together</a></h3>
<h4 id="题意-72">题意</h4>
<p>有 $n$ 人在一条直线上，他们需要聚集在一点。每个人都知道自己当前的位置 $x_i$ 和速度 $v_i$ 。请帮助他们找出最少能在多长时间内聚集到一点。</p>
<h4 id="参考思路-72">参考思路</h4>
<p>考虑二分答案，二分最少用时，二分函数中检查 $n$ 个人所能抵达的区间交集是否非空即可。</p>
<h4 id="参考代码-65">参考代码</h4>
<pre><code class="language-cpp">constexpr ld eps = 1e-6;

void solve() {
    int n;
    std::cin &gt;&gt; n;

    std::vector&lt;std::pair&lt;i64, i64&gt;&gt; a(n);
    for (auto &amp;[x, v] : a) std::cin &gt;&gt; x &gt;&gt; v;

    auto cmp = [](const auto&amp; a, const auto&amp; b) -&gt; auto {
        return a.second &lt; b.first;
    };

    auto ck = [&amp;](ld t) -&gt; bool {
        std::set&lt;std::pair&lt;ld, ld&gt;, decltype(cmp)&gt; s(cmp);
        
        auto insert = [&amp;](ld l, ld r) {
            if (l + eps &gt;= r) return;

            s.insert({l, r});
        };

        s.insert({a[0].first - a[0].second * t, a[0].first + a[0].second * t});

        for (auto &amp;[x, v] : a) {//restrict
            ld L = x - v * t, R = x + v * t;
            auto it = s.begin();

            while (it != s.end()) {
                auto [l, r] = *it;
                it++;
                s.erase(std::prev(it));

                insert(std::clamp(l, L, R), std::clamp(r, L, R));
            }
        }

        return s.size() &gt; 0;
    };

    ld l = 0, r = 2e10;
    for (int _ = 0; _ &lt; 60; _++) {
        ld mid = (l + r) / 2;
        if (ck(mid)) r = mid;
        else l = mid;
    }

    std::cout &lt;&lt; std::setprecision(7) &lt;&lt; std::fixed &lt;&lt; r;
}
</code></pre>
<h3 id="b-splitting-an-arrayhttpscodeforcescomeducourse2lesson63practicecontest285083problemb"><a href="https://codeforces.com/edu/course/2/lesson/6/3/practice/contest/285083/problem/B">B. Splitting an Array</a></h3>
<h4 id="题意-73">题意</h4>
<p>给定一个由 $n$ 个正整数组成的数组。你的任务是将数组分成 $k$ 段，使各段的最大和尽可能小。</p>
<h4 id="参考思路-73">参考思路</h4>
<p>考虑二分答案，二分判断函数中，将当最大和为 $x$ 时，最多能划分的段数与 $k$ 比较即可。</p>
<h4 id="参考代码-66">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;

    int mx = 0;

    std::vector&lt;int&gt; a(n);
    for (auto &amp;i : a) (std::cin &gt;&gt; i), mx = std::max(mx, i);

    auto ck = [&amp;](i64 x) -&gt; bool {
        int cnt = 1;
        i64 sum = 0;

        for (auto &amp;i : a) {
            if (sum + i &gt; x) {
                cnt++;
                sum = 0;
            }
            sum += i;
        }

        return cnt &lt;= k;
    };

    i64 l = mx, r = 2e18;
    while (l &lt;= r) {
        i64 mid = (l + r) / 2;

        if (ck(mid)) r = mid - 1;
        else l = mid + 1;
    }

    std::cout &lt;&lt; r + 1;
}
</code></pre>
<h3 id="c-cows-in-stallshttpscodeforcescomeducourse2lesson63practicecontest285083problemc"><a href="https://codeforces.com/edu/course/2/lesson/6/3/practice/contest/285083/problem/C">C. Cows in Stalls</a></h3>
<h4 id="题意-74">题意</h4>
<p>牛栏位于一条直线上，您的任务是将奶牛安排到牛栏中，使奶牛之间的距离尽可能小。</p>
<h4 id="参考思路-74">参考思路</h4>
<p>考虑直接二分答案，二分最小距离 $x$，在二分函数中用 lowerbound 二分向后跳，统计满足最小距离大于 $x$ 时，可用的栅栏数。</p>
<h4 id="参考代码-67">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;

    std::vector&lt;int&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    auto ck = [&amp;](int x) -&gt; bool {
        int cnt = 0;
        auto it = a.begin();

        while (it != a.end()) {
            cnt++;

            if (cnt &gt;= k) return 1;
            it = std::lower_bound(a.begin(), a.end(), *it + x);
        }

        return 0;
    };

    int l = 0, r = 1e9;
    while (l &lt;= r) {
        int mid = (l + r) / 2;

        if (ck(mid)) l = mid + 1;
        else r = mid - 1;
    }

    std::cout &lt;&lt; l - 1;
}
</code></pre>
<h3 id="d-minimum-maximum-on-the-pathhttpscodeforcescomeducourse2lesson63practicecontest285083problemd"><a href="https://codeforces.com/edu/course/2/lesson/6/3/practice/contest/285083/problem/D">D. Minimum maximum on the Path</a></h3>
<h4 id="题意-75">题意</h4>
<p>道路网由 $n$ 个路口和 $m$ 条单行道组成，每条道路都从编号较低的路口通向编号较高的路口。每条路都有一个编号。你的任务是找到一条从路口 1 到路口 $n$ 的路径，它最多由 $d$ 条边组成，在这条路径上，各条边对应的数字的最大值都可能是最小值。</p>
<h4 id="参考思路-75">参考思路</h4>
<p>先二分目标路径中最长的边的最小值，在二分函数中跑 01BFS，以边权为 1 跑最短路。再以跑出来的最小值跑一遍最短路，记录转移路径，最后输出记录的路径即可。</p>
<h4 id="参考代码-68">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m, d;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;

    std::vector edg(n, std::vector&lt;std::pair&lt;int, int&gt;&gt;());
    while (m--) {
        int x, y, w;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
        x--; y--;

        edg[x].push_back({y, w});
        //edg[y].push_back({x, w});
    }

    auto ck = [&amp;](int r) -&gt; bool {
        std::vector&lt;int&gt; dis(n, 1e9);

        std::queue&lt;int&gt; q;
        q.push(0);
        dis[0] = 0;
        while (q.size()) {
            auto now = q.front(); q.pop();

            for (auto &amp;[nxt, w] : edg[now]) {
                if (w &gt; r) continue;//超限

                if (dis[nxt] &gt; dis[now] + 1) {
                    dis[nxt] = dis[now] + 1;
                    q.push(nxt);
                }
            }
        }

        return dis[n - 1] &lt;= d;
    };

    int l = 0, r = 1e9;
    while (l &lt;= r) {
        int mid = (l + r) / 2;
        
        if (ck(mid)) r = mid - 1;
        else l = mid + 1;
    }

    if (r + 1 == 1e9 + 1) {
        std::cout &lt;&lt; -1;
        return;
    }

    r++;

    std::vector&lt;int&gt; dis(n, 1e9), fa(n);

    std::queue&lt;int&gt; q;
    q.push(0);
    dis[0] = 0;
    while (q.size()) {
        auto now = q.front(); q.pop();

        for (auto &amp;[nxt, w] : edg[now]) {
            if (w &gt; r) continue;//超限

            if (dis[nxt] &gt; dis[now] + 1) {
                dis[nxt] = dis[now] + 1;
                fa[nxt] = now;
                q.push(nxt);
            }
        }
    }

    std::vector&lt;int&gt; ans;

    int now = n - 1;
    while (now) {
        ans.push_back(now);
        now = fa[now];
    }
    ans.push_back(0);

    std::reverse(ans.begin(), ans.end());

    std::cout &lt;&lt; ans.size() - 1 &lt;&lt; &quot;\n&quot;;

    for (auto &amp;i : ans) std::cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;;
}
</code></pre>
<h2 id="step-4-4">Step 4</h2>
<h3 id="a-maximum-average-segmenthttpscodeforcescomeducourse2lesson64practicecontest285069problema"><a href="https://codeforces.com/edu/course/2/lesson/6/4/practice/contest/285069/problem/A">A. Maximum Average Segment</a></h3>
<h4 id="题意-76">题意</h4>
<p>给定一个数组 $n$ 和一个数字 $d$ 。你的任务是找出一个长度至少为 $d$ 的数段，在这个数段上，各元素的算术平均数尽可能最大。</p>
<h4 id="参考思路-76">参考思路</h4>
<p>考虑二分答案 $x$，于是我们只需要判断是否存在一个长度大于 $d$ 的区间，使得 $\sum_{i = l}^ra[i] &gt;= (r - l)x$，即 $\sum_{i = l}^ra[i] - x &gt;= 0$，问题转化为，在 $a[i] - x$ 数组中找一段长度大于 $d$ 的区间，使得区间贡献和为正。</p>
<p>具体实现可以利用前缀和维护 $pre[j] = \sum_{i = 0}^ja[i] - x$，然后再对前缀和数组 $pre$ 维护前缀 $min$ 数组。</p>
<p>二分出具体答案后，直接构造即可。</p>
<h4 id="参考代码-69">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;

    std::vector&lt;int&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    auto ck = [&amp;](ld x) -&gt; bool {
        std::vector&lt;ld&gt; b(n);
        for (int i = 0; i &lt; n; i++) {
            b[i] = a[i] - x;
        }

        std::vector&lt;ld&gt; pre(n);
        pre[0] = b[0];
        for (int i = 1; i &lt; n; i++) {
            pre[i] = pre[i - 1] + b[i];
        }

        std::vector&lt;ld&gt; g(n);
        g[0] = std::min(0.0l, pre[0]);
        for (int i = 1; i &lt; n; i++) {
            g[i] = std::min(g[i - 1], pre[i]);
        }

        for (int i = k - 1; i &lt; n; i++) {
            if (pre[i] &gt;= (i &gt;= k ? g[i - k] : 0)) {
                return 1;
            }
        }
        return 0;
    };


    ld l = 0, r = 100;
    for (int _ = 0; _ &lt;= 100; _++) {
        ld mid = (l + r) / 2;
        if (ck(mid)) l = mid;
        else r = mid;
    }


    std::vector&lt;ld&gt; b(n);
    for (int i = 0; i &lt; n; i++) {
        b[i] = a[i] - l;
    }

    std::vector&lt;ld&gt; pre(n);
    pre[0] = b[0];
    for (int i = 1; i &lt; n; i++) {
        pre[i] = pre[i - 1] + b[i];
    }

    std::vector&lt;ld&gt; g(n);
    g[0] = std::min(0.0l, pre[0]);
    for (int i = 1; i &lt; n; i++) {
        g[i] = std::min(g[i - 1], pre[i]);
    }

    for (int i = k - 1; i &lt; n; i++) {
        if (pre[i] &gt;= (i &gt;= k ? g[i - k] : 0)) {
            if (i == k - 1) {
                std::cout &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; k;
                return;
            } else {
                for (int j = 0; j &lt;= i - k; j++) {
                    if (pre[j] == g[i - k]) {
                        std::cout &lt;&lt; j + 2 &lt;&lt; &quot; &quot; &lt;&lt; i + 1;
                        return;
                    }
                }
                std::cout &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; i + 1;
                return;
            }
        }
    }

    //std::cout &lt;&lt; l;
}
</code></pre>
<h3 id="b-minimum-average-pathhttpscodeforcescomeducourse2lesson64practicecontest285069problemb"><a href="https://codeforces.com/edu/course/2/lesson/6/4/practice/contest/285069/problem/B">B. Minimum Average Path</a></h3>
<h4 id="题意-77">题意</h4>
<p>道路网由 $n$ 个路口和 $m$ 条单行道组成，每条道路都从编号较低的路口通向编号较高的路口。每条路都有一个编号。你的任务是找到一条从路口 1 到路口 $n$ 的路径，在这条路径上，边缘对应的数字的算术平均值尽可能小。</p>
<h4 id="参考思路-77">参考思路</h4>
<p>和上题类似，考虑二分答案 $r$，二分答案时将边权修改为 $a[i] = w - r$，用树 dp 跑最长路，判 $dis[n - 1] &lt;= 0$ 即可。</p>
<h4 id="参考代码-70">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector redg(n, std::vector&lt;std::pair&lt;int, int&gt;&gt;());
    while (m--) {
        int x, y, w;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
        x--; y--;
        redg[y].push_back({x, w});
    }

    auto ck = [&amp;](ld r) -&gt; bool {
        std::vector&lt;ld&gt; dp(n, 1e9);
        dp[0] = 0;

        for (int i = 1; i &lt; n; i++) {
            for (auto &amp;[from, w] : redg[i]) {
                dp[i] = std::min(dp[i], dp[from] + w - r);
            }
        }

        //std::cout &lt;&lt; r &lt;&lt; &quot;: &quot; &lt;&lt; dp[n - 1] &lt;&lt; &quot;]\n&quot;;

        return dp[n - 1] &lt;= 0;
    };

    ld l = 0, r = 100;
    for (int i = 0; i &lt; 50; i++) {
        ld mid = (l + r) / 2;
        if (ck(mid)) r = mid;
        else l = mid;
    }

    //std::cout &lt;&lt; l;

    std::vector&lt;int&gt; fa(n);
    std::vector&lt;ld&gt; dp(n, 1e9);
    dp[0] = 0;

    for (int i = 1; i &lt; n; i++) {
        for (auto &amp;[from, w] : redg[i]) {
            if (dp[i] &gt; dp[from] + w - r) {
                dp[i] = dp[from] + w - r;
                fa[i] = from;
            }
        }
    }

    std::vector&lt;int&gt; ans;
    int now = n - 1;
    while (now) {
        ans.push_back(now);
        now = fa[now];
    }

    ans.push_back(0);

    std::reverse(ans.begin(), ans.end());

    std::cout &lt;&lt; ans.size() - 1 &lt;&lt; &quot;\n&quot;;

    for (auto &amp;i : ans) std::cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;;
}
</code></pre>
<h3 id="c-pair-selectionhttpscodeforcescomeducourse2lesson64practicecontest285069problemc"><a href="https://codeforces.com/edu/course/2/lesson/6/4/practice/contest/285069/problem/C">C. Pair Selection</a>;</h3>
<h4 id="题意-78">题意</h4>
<p>给定 $n$ 对正整数 $(a_1, b_1), (a_2, b_2), \dots, (a_n, b_n)$ 。请选择其中的 $k$ ( $1 \le k \le n$ ) $i_1, i_2, \dots, i_k$ 使比例 $\frac{a_{i1} + a_{i2} + \dots + a_{ik}}{b_{i1} + b_{i2} + \dots + b_{ik}}$ 最大。</p>
<h4 id="参考思路-78">参考思路</h4>
<p>01分数规划板子题，设 $\frac{a_{i1} + a_{i2} + \dots + a_{ik}}{b_{i1} + b_{i2} + \dots + b_{ik}} = x$，则有 $a_{i1} + a_{i2} + \dots + a_{ik} = (b_{i1} + b_{i2} + \dots + b_{ik})x$，即 $\sum (a_{ij} - b_{ij} x) = 0$。</p>
<p>考虑二分答案，在二分函数中构造数组 $c[i] = a[i] - b[i] * x$，然后排序后选前 $k$ 大，判断和与 $0$ 的大小即可。</p>
<h4 id="参考代码-71">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;std::pair&lt;int, int&gt;&gt; p(n);
    for (auto &amp;[a, b] : p) std::cin &gt;&gt; a &gt;&gt; b;

    auto ck = [&amp;](ld x) -&gt; bool {
        std::vector&lt;ld&gt; z(n);
        for (int i = 0; i &lt; n; i++) {
            z[i] = p[i].first - x * p[i].second;
        }

        std::sort(z.rbegin(), z.rend());

        ld sum = 0;
        for (int i = 0; i &lt; m; i++) {
            sum += z[i];
        }

        return sum &gt;= 0;
    };

    ld l = 0, r = 1e5;
    for (int i = 0; i &lt; 50; i++) {
        ld mid = (l + r) / 2;
        if (ck(mid)) l = mid;
        else r = mid;
    }

    std::cout &lt;&lt; std::setprecision(7) &lt;&lt; std::fixed &lt;&lt; l;
}
</code></pre>
<h2 id="step-5-1">Step 5</h2>
<h3 id="a-k-th-number-in-the-union-of-segmentshttpscodeforcescomeducourse2lesson65practicecontest285084problema"><a href="https://codeforces.com/edu/course/2/lesson/6/5/practice/contest/285084/problem/A">A. K-th Number in the Union of Segments</a></h3>
<h4 id="题意-79">题意</h4>
<p>给定 $n$ 段整数[ $l_1,r_1$ ], [ $l_2,r_2$ ],&hellip;, [ $l_n,r_n$ ]。</p>
<p>让我们把这些数段中的所有数字写成一个数组。如果某个数字包含在一个以上的数段中，那么它在数组中出现的次数一定是它包含的数段的数量。也就是说，数组的长度等于所有数段中数字的总和。</p>
<p>之后，数组被排序。你的任务是找出数组中位于 $k$ 位置（编号从 0 开始）的数字。</p>
<h4 id="参考思路-79">参考思路</h4>
<p>考虑二分答案 $x$，二分函数中遍历数组，收集小于等于 $x$ 的数的数量，将其与 $k$ 比较即可。</p>
<h4 id="参考代码-72">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, k;
    std::cin &gt;&gt; n &gt;&gt; k;

    std::vector&lt;std::pair&lt;i64, i64&gt;&gt; a(n);
    for (auto &amp;[l, r] : a) std::cin &gt;&gt; l &gt;&gt; r;

    auto ck = [&amp;](i64 x) -&gt; bool {
        i64 sum = 0;

        for (auto &amp;[l, r] : a) {
            if (l &gt; x) continue;

            sum += (std::min(r, x) - l + 1); 
        }

        return sum &gt;= k + 1;
    };

    i64 l = -2e9, r = 2e9;
    while (l &lt;= r) {
        i64 mid = (l + r) / 2;
        if (ck(mid)) r = mid - 1;
        else l = mid + 1;
    }

    std::cout &lt;&lt; r + 1;
}
</code></pre>
<h3 id="b-multiplication-tablehttpscodeforcescomeducourse2lesson65practicecontest285084problemb"><a href="https://codeforces.com/edu/course/2/lesson/6/5/practice/contest/285084/problem/B">B. Multiplication Table</a></h3>
<h4 id="题意-80">题意</h4>
<p>彼得编制了一张大小为 $n\times n$ 的乘法表。在 $i$ ÷th行和 $j$ ÷th列中的单元格包含值 $i\cdot j$ 。彼得感兴趣的问题是：表格中哪个数字的升序是 $k$ -th？请帮助彼得回答这个问题。</p>
<h4 id="参考思路-80">参考思路</h4>
<p>和上一题类似，考虑二分答案 $x$，在二分函数中遍历 $n$ 行，收集小于等于 $x$ 的数的数量，与 $k$ 比较即可。</p>
<h4 id="参考代码-73">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, k;
    std::cin &gt;&gt; n &gt;&gt; k;

    auto ck = [&amp;](i64 x) -&gt; bool {
        i64 sum = 0;
        
        for (int i = 1; i &lt;= n; i++) {
            if (i &gt; x) continue;
            sum += (std::min(n, x / i));
        }

        return sum &gt;= k;
    };

    i64 l = 1, r = n * n;
    while (l &lt;= r) {
        i64 mid = (l + r) / 2;
        if (ck(mid)) r = mid - 1;
        else l = mid + 1;
    }

    std::cout &lt;&lt; r + 1;
}
</code></pre>
<h3 id="c-k-th-sumhttpscodeforcescomeducourse2lesson65practicecontest285084problemc"><a href="https://codeforces.com/edu/course/2/lesson/6/5/practice/contest/285084/problem/C">C. K-th Sum</a></h3>
<h4 id="题意-81">题意</h4>
<p>有两个数组 $a$ 和 $b$ ，每个数组都由 $n$ 个整数组成。对于每一对数字 $(i, j): 1\le i, j\le n$ ，写出和 $a_i + b_j$ 。在得到的一组和中，按升序找出 $k$ 个。</p>
<h4 id="参考思路-81">参考思路</h4>
<p>二分套二分，考虑二分答案 $x$，对两个数组排序后，在二分函数中枚举第一个数组，二分第二个数组中有多少个数满足 $a[i] + b[j] \le x$，收集数量后与 $k$ 作比较即可。</p>
<h4 id="参考代码-74">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, k;
    std::cin &gt;&gt; n &gt;&gt; k;

    std::vector&lt;i64&gt; a(n), b = a;
    for (auto &amp;i : a) std::cin &gt;&gt; i; std::sort(a.begin(), a.end());
    for (auto &amp;i : b) std::cin &gt;&gt; i; std::sort(b.begin(), b.end());

    auto ck = [&amp;](i64 x) -&gt; bool {
        i64 sum = 0;

        for (int i = 0; i &lt; n; i++) {
            if (a[i] + b[0] &gt; x) break;

            sum += *std::ranges::partition_point(std::ranges::iota_view(0, n), 
                [&amp;](int j) {
                    return a[i] + b[j] &lt;= x;
                }
            );
        }

        return sum &gt;= k;
    };

    i64 l = 1, r = 2e9;
    while (l &lt;= r) {
        i64 mid = (l + r) / 2;
        if (ck(mid)) r = mid - 1;
        else l = mid + 1;
    }

    std::cout &lt;&lt; r + 1;
}
</code></pre>
<h1 id="disjoint-sets-union">Disjoint Sets Union</h1>
<h2 id="step-1-5">Step 1</h2>
<h3 id="a-disjoint-sets-unionhttpscodeforcescomeducourse2lesson71practicecontest289390problema"><a href="https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/A">A. Disjoint Sets Union</a></h3>
<h4 id="题意-82">题意</h4>
<p>实现并查集数据结构。您必须执行两种类型的查询：</p>
<ul>
<li>union $u$ - 联合分别包含 $u$ 和 $v$ 的两个集合 $v$ - 联合分别包含 $u$ 和 $v$ 的两个集合；</li>
<li>获取 $u$ $v$ - 检查两个元素 $u$ 和 $v$ 是否属于同一个集合。</li>
</ul>
<h4 id="参考思路-82">参考思路</h4>
<p>并查集板子题，不讲思路。</p>
<h4 id="参考代码-75">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        F[find(x)] = find(y);
        return !ok;
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    DSU dsu(n + 1);
    while (m--) {
        std::string s;
        int x, y;
        std::cin &gt;&gt; s &gt;&gt; x &gt;&gt; y;

        if (s[0] == 'u') {
            dsu.join(x, y);
        } else {
            if (dsu.find(x) == dsu.find(y)) {
                std::cout &lt;&lt; &quot;YES\n&quot;;
            } else {
                std::cout &lt;&lt; &quot;NO\n&quot;;
            }
        }
    }
}
</code></pre>
<h3 id="b-disjoint-sets-union-2httpscodeforcescomeducourse2lesson71practicecontest289390problemb"><a href="https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/B">B. Disjoint Sets Union 2</a></h3>
<h4 id="题意-83">题意</h4>
<p>实现并查集数据结构。您必须执行两种类型的查询：</p>
<ul>
<li>union $u$ - 将分别包含 $u$ 和 $v$ 的两个集合联合起来 $v$ - 将分别包含 $u$ 和 $v$ 的两个集合联合起来；</li>
<li>get $v$ - 查找 $v$ 所属的集合，找出该集合的最小元素和最大元素，以及其中元素的总数。</li>
</ul>
<h4 id="参考思路-83">参考思路</h4>
<p>带权并查集板子题，在合并时转移权值即可。</p>
<h4 id="参考代码-76">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F, mi, mx, siz;
    DSU(int n) : F(n), mi(n), mx(n), siz(n, 1) {
        std::iota(F.begin(), F.end(), 0);
        mi = mx = F;
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        int Fx = find(x);
        int Fy = find(y);

        if (Fx != Fy) {
            F[Fx] = Fy;
            mi[Fy] = std::min(mi[Fy], mi[Fx]);
            mx[Fy] = std::max(mx[Fy], mx[Fx]);
            siz[Fy] += siz[Fx];
        }

        return !ok;
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    DSU dsu(n + 1);
    while (m--) {
        std::string op;
        std::cin &gt;&gt; op;

        if (op[0] == 'u') {
            int x, y;
            std::cin &gt;&gt; x &gt;&gt; y;

            dsu.join(x, y);
        } else {
            int p;
            std::cin &gt;&gt; p;

            p = dsu.find(p);
            std::cout &lt;&lt; dsu.mi[p] &lt;&lt; &quot; &quot;;
            std::cout &lt;&lt; dsu.mx[p] &lt;&lt; &quot; &quot;;
            std::cout &lt;&lt; dsu.siz[p] &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="c-experiencehttpscodeforcescomeducourse2lesson71practicecontest289390problemc"><a href="https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/C">C. Experience</a></h3>
<h4 id="题意-84">题意</h4>
<p>在新颖的网络游戏中，玩家像往常一样与怪物战斗并获得经验。为了与怪物战斗，玩家要组成突击队。消灭怪物后，队伍中的所有玩家都会获得相同数量的经验值。游戏的特点是不能拆散队伍，也不能离开队伍。唯一支持的操作是将两个队伍联合在一起。</p>
<p>由于已经有很多人在玩游戏，因此要求您保持玩家的经验值。</p>
<p>输入的第一行包含两个整数 $n$ 和 $m$ ($1\le n,m\le 2·10^5$) ー玩家数量和查询数量。</p>
<p>接下来的 $m$ 行包含查询描述，每行一个。查询可以有三种类型：</p>
<pre><code>join $X$ $Y$ ーー加入球员 X 和 Y 所属的两个队 (如果他们已经在同一个队，没有任何变化)。
add $X$ $V$ ー将 $V$ ($1 \le V \le 100$) 经验点添加到玩家 $X$ 所属的团队中的每个玩家。
get $X$ ーー输出玩家当前的经验点数 $X$ 。最初，每个玩家都有 $0$ 经验值，并且每个玩家都在自己的 $1$ 号队伍中。
</code></pre>
<h4 id="参考思路-84">参考思路</h4>
<p>带权并查集，维护权值加，合并时维护权值转移即可。</p>
<h4 id="参考代码-77">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F, bonus;//diff
    std::vector&lt;int&gt; val;//与bonus无关的val
    std::vector&lt;std::set&lt;int&gt;&gt; s;//启发式合并
    DSU(int n) : F(n), bonus(n, 0), val(n, 0), s(n) {
        std::iota(F.begin(), F.end(), 0);
        for (int i = 0; i &lt; n; i++) {
            s[i].insert(i);
        }
    }
    void add(int x, int v) {
        bonus[find(x)] += v;
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        int Fx = find(x);
        int Fy = find(y);

        if (Fx != Fy) {
            if (s[Fx].size() &gt; s[Fy].size()) std::swap(Fx, Fy);
            F[Fx] = Fy;
            
            for (auto &amp;i : s[Fx]) {
                val[i] += bonus[Fx];
                val[i] -= bonus[Fy];
                s[Fy].insert(i);
            }
        }

        return !ok;
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    DSU dsu(n + 1);
    while (m--) {
        std::string op;
        std::cin &gt;&gt; op;

        if (op[0] == 'a') {
            int p, v;
            std::cin &gt;&gt; p &gt;&gt; v;

            dsu.add(p, v);
        } else if (op[0] == 'j') {
            int x, y;
            std::cin &gt;&gt; x &gt;&gt; y;

            dsu.join(x, y);
        } else {
            int x;
            std::cin &gt;&gt; x;

            std::cout &lt;&lt; dsu.val[x] + dsu.bonus[dsu.find(x)] &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="d-cutting-a-graphhttpscodeforcescomeducourse2lesson71practicecontest289390problemd"><a href="https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/D">D. Cutting a graph</a></h3>
<h4 id="题意-85">题意</h4>
<p>有一个无向图和两种类型的操作序列，其格式如下：</p>
<pre><code>cut $u$ $v$ ーー从图中删除边 $u$ - $v$ ;
ask $u$ $v$ ーー检查顶点 $u$ 和 $v$ 是否在同一个连接元件 (图论)。在应用了所有的操作之后，该图不包含任何边。请查找类型 ask 的每个操作的结果。
</code></pre>
<h4 id="参考思路-85">参考思路</h4>
<p>考虑将输入离线下来，反转输入，将 cut 改成 add，先预处理一遍，将原图中，不出现在操作序列中的所有边，全部加入并查集中，再倒着处理询问即可。</p>
<h4 id="参考代码-78">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        int Fx = find(x);
        int Fy = find(y);

        F[Fx] = Fy;

        return !ok;
    }
};

void solve() {
    int n, m, q;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;

    std::set&lt;std::pair&lt;int, int&gt;&gt; edgs, res;
    
    while (m--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        if (x &gt; y) std::swap(x, y);

        edgs.insert({x, y});
    }

    std::vector&lt;std::array&lt;int, 3&gt;&gt; ask(q);
    for (auto &amp;[t, x, y] : ask) {
        std::string op;
        std::cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;

        if (x &gt; y) std::swap(x, y);
        
        if (op[0] == 'a') {
            t = 0;
        } else {
            t = 1;
            edgs.erase({x, y});
            res.insert({x, y});
        }
    }

    DSU dsu(n + 1);

    for (auto &amp;[x, y] : edgs) {
        dsu.join(x, y);
    }

    std::vector&lt;int&gt; ans;

    for (int i = q - 1; i &gt;= 0; i--) {
        auto &amp;[t, x, y] = ask[i];

        if (t) {
            dsu.join(x, y);
        } else {
            ans.push_back(dsu.find(x) == dsu.find(y));
        }
    }

    std::reverse(ans.begin(), ans.end());

    for (auto &amp;i : ans) std::cout &lt;&lt; (i ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="e-monkeyshttpscodeforcescomeducourse2lesson71practicecontest289390probleme"><a href="https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/E">E. Monkeys</a></h3>
<h4 id="题意-86">题意</h4>
<p>有 $n$ 猴子挂在一棵很高的树上。猴子的数量从 $1$ 到 $n$ 。第一只猴子 (领头的) 用尾巴吊在一根结实的树枝上。每只猴子都可以用自己的手抓住另一只猴子的尾巴，或者用自己的尾巴挂住另一只猴子。现在所有的猴子都直接或间接地挂在领头的猴子身上，而且没有倒下。猴子的一只手最多只能抓住一条尾巴 (或挂在一条尾巴上) ，但是任意数量的手可以抓住或挂在一条尾巴上。</p>
<p>每一秒，从零开始，其中一只猴子放开一只手，结构就会改变。此外，还可能发生一只或多只猴子开始跌倒的情况。这棵树非常高，所以需要一段时间才能倒下，猴子们在这段时间里继续松开双手。</p>
<p>您被给予初始配置和手释放的时间表。你要写一个程序，计算每只猴子开始倒下的时间。</p>
<h4 id="参考思路-86">参考思路</h4>
<p>题意很迷，实际上手和尾巴可以等价，每个节点最多有 $3$ 条边，我们只需要维护每只猴子与 0 号猴子不在同一连通块（断开连接）的时间点即可。</p>
<p>建完图后，按时间顺序跑一遍生成树，最后倒着跑并查集加边即可，每只猴子第一次与 0 号猴子所处的联通块连通的时间，即为断开连接的时间。</p>
<h4 id="参考代码-79">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        int Fx = find(x);
        int Fy = find(y);

        if (Fx != Fy) {
            if (Fx &lt; Fy) std::swap(Fx, Fy);//让下标大的合并到小的
            F[Fx] = Fy;
        }

        return !ok;
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;int&gt; L(n + 1), R(n + 1);

    std::multiset&lt;std::pair&lt;int, int&gt;&gt; edgs;
    auto add = [&amp;](int x, int y) {
        if (x &gt; y) edgs.insert({y, x});
        else edgs.insert({x, y});
    };

    auto remove = [&amp;](int x, int y) {
        if (x == -1 || y == -1) return;

        if (x &gt; y) edgs.extract({y, x});
        else edgs.extract({x, y});
    };

    for (int i = 1; i &lt;= n; i++) {
        std::cin &gt;&gt; L[i] &gt;&gt; R[i];

        if (L[i] != -1) add(L[i], i);
        if (R[i] != -1) add(R[i], i);
    }

    std::vector&lt;std::pair&lt;int, int&gt;&gt; event(m);
    for (auto &amp;[x, y] : event) {
        int p, t;
        std::cin &gt;&gt; p &gt;&gt; t;

        if (t == 1) {
            if (p &gt; L[p]) x = L[p], y = p;
            else x = p, y = L[p];

            remove(p, L[p]);
        } else {
            if (p &gt; R[p]) x = R[p], y = p;
            else x = p, y = R[p];

            remove(p, R[p]);
        }
    }

    //时间顺序生成树
    std::vector edg(n + 1, std::vector&lt;int&gt;());
    std::vector&lt;int&gt; fall(n + 1, -1);

    DSU dsu(n + 1);
    dsu.join(0, 1);

    auto JOIN = [&amp;](int x, int y, int t) {
        int fx = dsu.find(x);
        int fy = dsu.find(y);

        if (fx != fy) {
            dsu.join(fx, fy);

            if (fx &gt; fy) std::swap(fx, fy);

            edg[fx].push_back(fy);

            if (fx == 0) {
                fall[fy] = t;
            }
        }
    };

    edg[0].push_back(1);

    for (auto &amp;[x, y] : edgs) {
        JOIN(x, y, -1);
    }

    for (int i = m - 1; i &gt;= 0; i--) {
        JOIN(event[i].first, event[i].second, i);
    }

    auto dfs = [&amp;](auto&amp;&amp; self, int now, int from) -&gt; void {
        for (auto &amp;nxt : edg[now]) {
            if (nxt == from) continue;
            fall[nxt] = std::max(fall[nxt], fall[now]);
            self(self, nxt, now);
        }
    };
    dfs(dfs, 0, -1);

    for (int i = 1; i &lt;= n; i++) std::cout &lt;&lt; fall[i] &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h2 id="step-2-5">Step 2</h2>
<h3 id="a-people-are-leavinghttpscodeforcescomeducourse2lesson72practicecontest289391problema"><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/A">A. People are leaving</a></h3>
<h4 id="题意-87">题意</h4>
<p>$n$ 人站在 $1$ 至 $n$ 位置。您必须执行两种类型的查询：</p>
<ul>
<li>&ldquo;- $x$ &quot; - 位于 $x$ 位置的人离开；</li>
<li>&ldquo;? $x$ &ldquo;&ndash;找到右边最近的还站着的人。</li>
</ul>
<h4 id="参考思路-87">参考思路</h4>
<p>考虑建立一个 n + 1 大小的并查集，每次进行第一个操作时，直接合并 $x$ 和 $x + 1$（注意让下标大的当联通块的祖先）；查询时查询 $x$ 处的祖先即可。</p>
<p><em>当然你用 set 维护也行，不过有点慢</em></p>
<h4 id="参考代码-80">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        int Fx = find(x);
        int Fy = find(y);

        if (Fx != Fy) {
            if (Fx &gt; Fy) std::swap(Fx, Fy);//让下标小的合并到大的
            F[Fx] = Fy;
        }

        return !ok;
    }
};

void solve() {//312ms
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    DSU dsu(n + 2);

    while (m--) {
        char op;
        int x;
        std::cin &gt;&gt; op &gt;&gt; x;

        if (op == '?') {
            int z = dsu.find(x);
            std::cout &lt;&lt; (z == n + 1 ? -1 : z) &lt;&lt; &quot;\n&quot;;
        } else {
            dsu.join(x, x + 1);
        }
    }
}
</code></pre>
<h3 id="b-parkinghttpscodeforcescomeducourse2lesson72practicecontest289391problemb"><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/B">B. Parking</a></h3>
<h4 id="题意-88">题意</h4>
<p>从 $1$ 到 $n$ 的环形停车场上有 $n$ 个车位。有 $n$ 辆车想按自然顺序停放。 $i$ 辆汽车想停在 $p_i$ 个车位上。如果汽车开到一个车位，而她的车位已被占用，那么它就会循环行驶，停在第一个空车位上。</p>
<h4 id="参考思路-88">参考思路</h4>
<p>和上题类似，用并查集维护右边第一个没有被占用的车位，输入的同时查询结果，输出后再合并。注意要将 $n$ 号位置连接到 $1$ 号位置上。</p>
<h4 id="参考代码-81">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {//x -&gt; y
        bool ok = (find(x) == find(y));
        int Fx = find(x);
        int Fy = find(y);

        if (Fx != Fy) {
            F[Fx] = Fy;
        }

        return !ok;
    }
};

void solve() {
    int n;
    std::cin &gt;&gt; n;

    DSU dsu(n);

    for (int i = 0; i &lt; n; i++) {
        int p;
        std::cin &gt;&gt; p;
        p--;

        int z = dsu.find(p);
        std::cout &lt;&lt; z + 1 &lt;&lt; &quot; &quot;;
        dsu.join(z, (z + 1) % n);
    }
}
</code></pre>
<h3 id="c-restructuring-companyhttpscodeforcescomeducourse2lesson72practicecontest289391problemc"><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/C">C. Restructuring Company</a></h3>
<h4 id="题意-89">题意</h4>
<p>即使是最成功的公司也会经历危机时期，这时你必须做出艰难的决定一一重组、废弃和合并部门、解雇员工以及做其他令人不快的事情。让我们来看看下面的公司模式。</p>
<p>大型软件公司有 $n$ 名员工。每个人都隶属于某个部门。最初，每个人都在自己的部门负责自己的项目(因此，每个公司最初由 $n$ 个部门组成，每个部门有一个人)。</p>
<p>然而，严酷的时代已经来临，公司管理层不得不聘请一位危机管理者来重建工作流程，以提高效率。让我们用 $team(person)$ 代表一个团队， $person$ 在其中工作。危机管理者可以做出两种决策：</p>
<pre><code>将部门 $team(x)$ 和 $team(y)$ 合并为一个大部门，其中包含 $team(x)$ 和 $team(y)$ 的所有员工，其中 $x$ 和 $y$ ($1 \le x, y \le n$)--是公司某些员工中两个人的编号。如果 $team(x)$ 与 $team(y)$ 匹配，则不会发生任何操作。
合并部门 $team(x), team(x + 1), ..., team(y)$ ，其中 $x$ 和 $y$ ($1 \le x \le y \le n$) - 是公司两名员工的编号。
</code></pre>
<p>危机管理者有时会怀疑员工 $x$ 和 $y$ ($1 \le x, y \le n$) 是否在同一部门工作。</p>
<p>请帮助危机处理经理并回答他的所有疑问。</p>
<h4 id="参考思路-89">参考思路</h4>
<p>用两个并查集，一个处理单点修改，一个处理区间修改。处理区间修改时，暴力向后跳，次数最多是 $n$ 次，跳的同时合并单点修改的并查集中对应的联通块。查询时查询单点修改所管理的联通块即可。</p>
<h4 id="参考代码-82">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {//x -&gt; y
        bool ok = (find(x) == find(y));
        int Fx = find(x);
        int Fy = find(y);

        if (Fx != Fy) {
            F[Fx] = Fy;
        }

        return !ok;
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    DSU dsua(n + 1), dsub(n + 1);

    while (m--) {
        int op, x, y;
        std::cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;

        if (op == 1) {
            dsua.join(x, y);
        } else if (op == 2) {
            int now = dsub.find(x);

            while (now &lt;= y) {
                dsub.join(now, y);
                dsua.join(now, y);
                now++;

                if (now &gt; n) break;

                now = dsub.find(now);
            }
        } else {
            int fx = dsua.find(x);
            int fy = dsua.find(y);

            std::cout &lt;&lt; (fx == fy ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="d-bosseshttpscodeforcescomeducourse2lesson72practicecontest289391problemd"><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/D">D. Bosses</a></h3>
<h4 id="题意-90">题意</h4>
<p>一家公司有 $n$ 名员工，在当前时刻，没有人是其他人的下属。也就是说，每个员工都是自己的老板。如果一个人不是其他人的下属，我们就称他为老板。</p>
<p>您需要处理两类查询：</p>
<pre><code>老板 $a$ 成为老板 $b$ 的下属(不再是老板)，
给定员工 $c$ ，我们应该通过他的多少个上级才能找到老板？
</code></pre>
<p>在第二种类型的查询中，如果 $c$ 是老板，则答案为 $0$，否则答案为某个正整数&ndash;员工的 &ldquo;深度&rdquo;。</p>
<p>请编写一个处理查询的程序。</p>
<h4 id="参考思路-90">参考思路</h4>
<p>带权并查集，维护到祖先的路径长度，路径压缩时记得更新新的路径长度。</p>
<h4 id="参考代码-83">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    std::vector&lt;int&gt; val;
    DSU(int n) : F(n), val(n, 0) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        if (F[x] == x) return x;

        int fx = F[x];//暂存父节点，同时处理好父节点的权值更新
        F[x] = find(fx);

        val[x] += val[fx];

        return F[x];
    }
    bool join(int x, int y) {//x -&gt; y
        int fx = find(x);
        int fy = find(y);

        if (fx != fy) {
            F[fx] = fy;
            val[fx]++;
        }

        return !(fx == fy);
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    DSU dsu(n + 1);

    while (m--) {
        int op;
        std::cin &gt;&gt; op;


        if (op == 1) {
            int x, y;
            std::cin &gt;&gt; x &gt;&gt; y;

            dsu.join(x, y);
        } else {
            int p;
            std::cin &gt;&gt; p;

            dsu.find(p);

            std::cout &lt;&lt; dsu.val[p] &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="e-spanning-treehttpscodeforcescomeducourse2lesson72practicecontest289391probleme"><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/E">E. Spanning Tree</a></h3>
<h4 id="题意-91">题意</h4>
<p>对于给定的连通无向加权图，找出权重最小的生成树。</p>
<h4 id="参考思路-91">参考思路</h4>
<p>最小生成树板子，不讲思路。</p>
<h4 id="参考代码-84">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        F[find(x)] = find(y);
        return !ok;
    }
};

i64 kruskal(std::vector&lt;std::array&lt;int, 3&gt;&gt; edgs, int n) {
    std::sort(edgs.begin(), edgs.end());
    DSU dsu(n);

    i64 sum = 0;
    //std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt; edg(n);//连边
    for (auto &amp;[w, u, v] : edgs) {
        int fu = dsu.find(u);
        int fv = dsu.find(v);
        if (fu != fv) {
            //edg[u].push_back({v, w});
            //edg[v].push_back({u, w});
            dsu.join(u, v);
            sum += w;
        }
    }

    return sum;
}

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;std::array&lt;int, 3&gt;&gt; edgs(m);
    for (auto &amp;[w, x, y] : edgs) (std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w), x--, y--;

    std::cout &lt;&lt; kruskal(edgs, n);
}
</code></pre>
<h3 id="f-dense-spanning-treehttpscodeforcescomeducourse2lesson72practicecontest289391problemf"><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/F">F. Dense spanning tree</a></h3>
<h4 id="题意-92">题意</h4>
<p>您需要在图中找到一棵生成树，使最大边和最小边之间的差值最小。</p>
<h4 id="参考思路-92">参考思路</h4>
<p>将边按权值排序后，双指针从小到大判断给定区间的边权是否存在生成树，双指针过程中记录答案，时间复杂度 $O(mlogm + nm)$。</p>
<h4 id="参考代码-85">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        F[find(x)] = find(y);
        return !ok;
    }
};

bool kruskal(std::vector&lt;std::array&lt;int, 3&gt;&gt; &amp;edgs, int n, int l, int r) {
    //std::sort(edgs.begin(), edgs.end());
    DSU dsu(n);
    int cnt = n;

    //std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt; edg(n);//连边
    //for (auto &amp;[w, u, v] : edgs) {
    for (int i = l; i &lt; std::min&lt;int&gt;(edgs.size(), r + 1); i++) {
        auto &amp;[w, u, v] = edgs[i];

        int fu = dsu.find(u);
        int fv = dsu.find(v);
        if (fu != fv) {
            //edg[u].push_back({v, w});
            //edg[v].push_back({u, w});
            dsu.join(u, v);

            cnt--;
        }
    }

    return (cnt == 1);
}

void solve() {
    int ans = 2e9 + 1;

    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;std::array&lt;int, 3&gt;&gt; edgs(m);
    for (auto &amp;[w, x, y] : edgs) (std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w), x--, y--;

    std::sort(edgs.begin(), edgs.end());

    bool ok = 0;
    int l = 0, r = n - 2;
    do {
        ok = 0;

        while (r + 1 &lt; m &amp;&amp; (edgs[r][0] == edgs[r + 1][0] || r - l + 1 &lt; n - 1)) r++, ok = 1;

        if (kruskal(edgs, n, l, r)) {
            ans = std::min(ans, edgs[r][0] - edgs[l][0]);

            while (l + 1 &lt; m &amp;&amp; edgs[l][0] == edgs[l + 1][0]) l++, ok = 1;
            if (l + 1 &lt; m) l++, ok = 1;            
        } else {
            while (r + 1 &lt; m &amp;&amp; edgs[r][0] == edgs[r + 1][0]) r++, ok = 1;
            if (r + 1 &lt; m) r++, ok = 1;
        }
    } while (ok);

    if (ans == 2e9 + 1) {
        std::cout &lt;&lt; &quot;NO&quot;;
    } else {
        std::cout &lt;&lt; &quot;YES\n&quot;;
        std::cout &lt;&lt; ans;
    }
}
</code></pre>
<h3 id="g-no-refuelhttpscodeforcescomeducourse2lesson72practicecontest289391problemg"><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/G">G. No refuel</a></h3>
<h4 id="题意-93">题意</h4>
<p>城市之间有多条道路 $1, 2, &hellip;, n$ 。每条道路的长度已知。道路网络是连通的，即任何一对城市之间都有一条道路。加油站只位于城市中。你必须计算出汽车要在城市间顺利行驶所能通过的最大距离。</p>
<h4 id="参考思路-93">参考思路</h4>
<p>跑最小生成树，求最大边权即可。</p>
<h4 id="参考代码-86">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        F[find(x)] = find(y);
        return !ok;
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;std::array&lt;int, 3&gt;&gt; edgs(m);
    for (auto &amp;[w, x, y] : edgs) std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;

    std::sort(edgs.begin(), edgs.end());

    DSU dsu(n + 1);

    int cnt = n;
    for (auto &amp;[w, x, y] : edgs) {
        if (dsu.join(x, y)) cnt--;
        if (cnt == 1) {
            std::cout &lt;&lt; w;
            return;
        }
    }
}
</code></pre>
<h3 id="h-oil-businesshttpscodeforcescomeducourse2lesson72practicecontest289391problemh"><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/H">H. Oil business</a></h3>
<h4 id="题意-94">题意</h4>
<p>给你一个无向连通图，图中有 $n$ 个顶点和 $m$ 条边。您知道每条边的删除成本。您希望删除尽可能多的边，使图形保持连通，且删除边的总成本不超过 $s$。</p>
<h4 id="参考思路-94">参考思路</h4>
<p>考虑最大生成树，筛选出剩下未删的边，然后按权值从小到大选，一直选到第一次不满足总删除成本小于 $s$ 为止。</p>
<h4 id="参考代码-87">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        F[find(x)] = find(y);
        return !ok;
    }
};

void solve() {
    int n, m;
    i64 s;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;

    std::vector&lt;std::array&lt;int, 4&gt;&gt; edgs(m);
    for (auto &amp;[w, x, y, id] : edgs) (std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w), x--, y--;
    for (int i = 0; i &lt; m; i++) {
        edgs[i][3] = i + 1;
    }

    std::sort(edgs.rbegin(), edgs.rend());

    DSU dsu(n);

    std::vector&lt;std::pair&lt;int, int&gt;&gt; res, ans;

    for (auto &amp;[w, x, y, id] : edgs) {
        if (!dsu.join(x, y)) {
            res.push_back({w, id});
        }
    }

    std::sort(res.begin(), res.end());

    i64 sum = 0;
    for (auto &amp;[w, i] : res) {
        if (sum + w &lt;= s) {
            sum += w;
            ans.push_back({i, w});
        } else {
            break;
        }
    }

    std::cout &lt;&lt; ans.size() &lt;&lt; &quot;\n&quot;;
    for (auto &amp;[i, w] : ans) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
}
</code></pre>
<h3 id="i-bipartite-graphhttpscodeforcescomeducourse2lesson72practicecontest289391problemi"><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/I">I. Bipartite Graph</a></h3>
<h4 id="题意-95">题意</h4>
<p>给你一个由 $n$ 个顶点组成的空无向图。每个顶点在任何时刻都有 $0$ 或 $1$ 两种颜色，因此每条边都连接着不同颜色的顶点。</p>
<p>查询有两种类型：</p>
<ul>
<li>给您来自不同连接组件的两个顶点 $x$ 和 $y$ ：在图中添加一条边 $(x, y)$ ，并改变颜色以满足条件。</li>
<li>给您来自一个相连组件的两个顶点 $x$ 和 $y$ ：回答它们的颜色是否相同。</li>
</ul>
<p>最初的图形是空的。</p>
<h4 id="参考思路-95">参考思路</h4>
<p>考虑扩展域并查集，维护两点间颜色是否不能相同。</p>
<h4 id="参考代码-88">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        F[find(x)] = find(y);
        return !ok;
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    int shift = 0;
    DSU dsu(2 * n);

    while (m--) {
        int op, a, b;
        std::cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;
        a = (a + shift) % n;
        b = (b + shift) % n;

        if (op) {//
            bool ok = !(dsu.find(a) == dsu.find(b + n) || dsu.find(a + n) == dsu.find(b));

            std::cout &lt;&lt; (ok ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\n&quot;;

            if (ok) shift = (shift + 1) % n;
        } else {
            assert(dsu.find(a) != dsu.find(b));

            dsu.join(a, b + n);
            dsu.join(a + n, b);
        }
    }
}
</code></pre>
<h3 id="j-first-non-bipartite-edgehttpscodeforcescomeducourse2lesson72practicecontest289391problemj"><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/J">J. First Non-Bipartite Edge</a></h3>
<h4 id="题意-96">题意</h4>
<p>双向图是一种无向图，可以将其顶点分成两部分，这样，边只能连接不同部分的顶点。</p>
<p>在本题中，$m$ 条边被逐一添加到最初的空图中，该图有 $n$ 个顶点。您的任务是确定第一条边的索引，使得添加后的图形不是二方图。</p>
<p>由 $n$ 个顶点组成的空图是一个包含 $n$ 个顶点且没有边的图。</p>
<h4 id="参考思路-96">参考思路</h4>
<p>和上题类似，扩展域并查集维护两点间颜色是否能够相同，找到第一次发生冲突的位置即可。</p>
<h4 id="参考代码-89">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        F[find(x)] = find(y);
        return !ok;
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    DSU dsu(2 * n), part(n);

    for (int i = 1; i &lt;= m; i++) {
        int a, b;
        std::cin &gt;&gt; a &gt;&gt; b;
        a--; b--;

        if (part.find(a) == part.find(b) &amp;&amp; !(dsu.find(a) == dsu.find(b + n) || dsu.find(a + n) == dsu.find(b))) {
            std::cout &lt;&lt; i;
            return;
        } else {
            dsu.join(a, b + n);
            dsu.join(a + n, b);
            part.join(a, b);
        }
    }

    std::cout &lt;&lt; -1;
}
</code></pre>
<h2 id="step-3-5">Step 3</h2>
<h3 id="a-dsu-with-rollbackhttpscodeforcescomeducourse2lesson73practicecontest289392problema"><a href="https://codeforces.com/edu/course/2/lesson/7/3/practice/contest/289392/problem/A">A. DSU with rollback</a></h3>
<h4 id="题意-97">题意</h4>
<p>在这个问题中，你必须实现带有回滚功能的 DSU。该数据结构应支持三种操作：</p>
<ul>
<li>联合 $u$ $v$ &quot; - 将包含 $u$ 和 $v$ 的两个集合联合起来，并输出当前不相交集合的数量。</li>
<li>persist&rdquo; - 创建一个检查点，结构体可以回滚到该检查点。</li>
<li>回滚&rdquo;&ndash;回滚到最新的检查点，删除该点，并输出当前不相交集合的个数。</li>
</ul>
<h4 id="参考思路-97">参考思路</h4>
<p>回滚并查集板子，在普通并查集中添加一个栈来记录历史信息即可。</p>
<h4 id="参考代码-90">参考代码</h4>
<pre><code class="language-cpp">struct DSU_maintain {
    std::vector&lt;int&gt; F, siz;
    
    int cnt;
    std::stack&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt; stk;//有效操作
    //                               fx，fy

    DSU(int n) : F(n), cnt(n), siz(n, 1) {
        std::iota(F.begin(), F.end(), 0);
        stk.push(std::vector&lt;std::pair&lt;int, int&gt;&gt;());
    }
    int find(int x) {
        while (x != F[x]) {
            x = F[x];
        }

        return x;
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        int fx = find(x);
        int fy = find(y);

        if (siz[fx] &gt; siz[fy]) {//siz 小的连到 siz 大的上
            std::swap(fx, fy);
        }

        if (!ok) {
            cnt--;
            stk.top().push_back({fx, fy});
            F[fx] = fy;
            siz[fy] += siz[fx];
        }
        
        return !ok;
    }

    void maintain() {
        stk.push(std::vector&lt;std::pair&lt;int, int&gt;&gt;());
    }

    void rollback() {
        assert(stk.size());

        for (auto &amp;[x, y] : stk.top()) {
            cnt++;
            siz[y] -= siz[x];
            F[x] = x; F[y] = y;
        }

        stk.pop();
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    DSU_maintain dsu(n);
    while (m--) {
        std::string s;
        std::cin &gt;&gt; s;

        if (s[0] == 'p') {
            dsu.maintain();
        } else if (s[0] == 'u') {
            int x, y;
            std::cin &gt;&gt; x &gt;&gt; y;
            x--; y--;
            dsu.join(x, y);

            std::cout &lt;&lt; dsu.cnt &lt;&lt; &quot;\n&quot;;
        } else {
            dsu.rollback();

            std::cout &lt;&lt; dsu.cnt &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="b-number-of-connected-components-on-segmentshttpscodeforcescomeducourse2lesson73practicecontest289392problemb"><a href="https://codeforces.com/edu/course/2/lesson/7/3/practice/contest/289392/problem/B">B. Number of Connected Components on Segments</a></h3>
<h4 id="题意-98">题意</h4>
<p>给你一个有 $n$ 个顶点和 $m$ 条不定向边的图。请编写一个程序来处理形式为 $(l_j, r_j)$ 的 $k$ 查询： $j$ -th 查询的答案是，如果我们删除图中所有的边，但不包括索引为 $l_j$ 至 $r_j$ 的边，则连通部分的数量为多少。</p>
<p>这些查询应独立回答。换句话说，要回答 $j$ -th 查询，应该考虑一个有 $n$ 个顶点和 $r_j-l_j+1$ 条边的图。</p>
<h4 id="参考思路-98">参考思路</h4>
<p>考虑莫队分块，将询问离线下来，以左端点为准划分到 $\sqrt m$ 个块中，对于每个块的询问，按右端点排序后，用可持久化并查集维护。</p>
<p>设当前块的左右下标 id 为 $[Block_l_i, Block_r_i)$</p>
<p>如果询问的左右端点都在当前块内，那么并查集设置检查点后暴力加边再统计，最后直接回滚，复杂度是 $O(\sqrt m)$ 的。</p>
<p>如果询问的右端点不在当前块内，那么我们先将 $[Block_r_i, r_j)$ （如果该询问是这个块的第一个，右端点不在当前块的询问）或 $[r_{j - 1}, r_j)$ （如果该询问不是当前块的第一个，右端点不在当前块的询问）中的边全部补充到并查集中，然后设置检查点，暴力添加完 $[l_j, Block_l_i)$ 中的边并统计后再回滚，复杂度也是 $O(\sqrt m)$ 的。</p>
<p>每个块内，排序，处理查询的总时间复杂度为 $O(n_i\log n_i + \sqrt m + n)$，总时间复杂度即为 $O(n\log n + m + n\sqrt m)$。</p>
<h4 id="参考代码-91">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F, siz, rnk;
    
    int cnt;
    std::stack&lt;std::vector&lt;std::array&lt;int, 6&gt;&gt;&gt; stk;//有效操作
    //                     fx，fy，siz[fx]，siz[fy], rnk[fx], rnk[fy]

    DSU(int n) : F(n), cnt(n), siz(n, 1), rnk(n, 0) {
        std::iota(F.begin(), F.end(), 0);
        stk.push(std::vector&lt;std::array&lt;int, 6&gt;&gt;());
    }
    int find(int x) {
        while (x != F[x]) {
            x = F[x];
        }

        return x;
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        int fx = find(x);
        int fy = find(y);

        if (siz[fx] &gt; siz[fy]) {//siz 小的连到 siz 大的上
            std::swap(fx, fy);
        }
        // if (rnk[fx] &gt; rnk[fy]) {//按rank合并
        //     std::swap(fx, fy);
        // }

        if (!ok) {
            cnt--;
            stk.top().push_back({fx, fy, siz[fx], siz[fy], rnk[fx], rnk[fy]});
            F[fx] = fy;
            siz[fy] += siz[fx];
            if (rnk[fx] == rnk[fy]) rnk[fy]++;
        }
        
        return !ok;
    }

    void check() {
        stk.push(std::vector&lt;std::array&lt;int, 6&gt;&gt;());
    }

    void rollback() {//回滚要逆序回滚
        assert(stk.size());

        std::reverse(stk.top().begin(), stk.top().end());

        for (auto &amp;[x, y, sizx, sizy, rnkx, rnky] : stk.top()) {
            cnt++;
            F[x] = x; F[y] = y;
            siz[x] = sizx; siz[y] = sizy;
            rnk[x] = rnkx; rnk[y] = rnky;
        }

        stk.pop();
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;std::pair&lt;int, int&gt;&gt; edg(m);
    for (auto &amp;[x, y] : edg) (std::cin &gt;&gt; x &gt;&gt; y), x--, y--;

    int m_ = std::sqrt(m);

    //                          [l, r, idx]
    std::vector&lt;std::vector&lt;std::array&lt;int, 3&gt;&gt;&gt; qry(m / m_);

    int q;
    std::cin &gt;&gt; q;
    for (int i = 0; i &lt; q; i++) {
        int l, r;
        std::cin &gt;&gt; l &gt;&gt; r;
        l--; r--;

        while (l / m_ &gt;= qry.size()) qry.push_back(std::vector&lt;std::array&lt;int, 3&gt;&gt;());
        
        qry[l / m_].push_back({l, r, i});
    }

    std::vector&lt;int&gt; ans(q, -1);

    for (int blk = 0; blk &lt; qry.size(); blk++) {
        DSU dsu(n);

        std::sort(qry[blk].begin(), qry[blk].end(), [&amp;](const auto&amp; a, const auto&amp; b) {
            return a[1] &lt; b[1];
        });

        int R = (blk + 1) * m_ - 1;

        for (auto &amp;[l, r, idx] : qry[blk]) {
            if (r &lt; (blk + 1) * m_) {//暴力算完，直接回滚
                dsu.check();
                for (int i = l; i &lt;= r; i++) dsu.join(edg[i].first, edg[i].second);

                ans[idx] = dsu.cnt;

                dsu.rollback();
            } else {//一直从blk * m_ 开始向右push，直到 R = r
                while (R &lt; r) R++, dsu.join(edg[R].first, edg[R].second);
                dsu.check();

                int L = (blk + 1) * m_;
                while (L &gt; l) L--, dsu.join(edg[L].first, edg[L].second);
                ans[idx] = dsu.cnt;

                dsu.rollback();
            }
        }
    }

    for (auto &amp;i : ans) {
        assert(i != -1);
        std::cout &lt;&lt; i &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="c-dynamic-connectivity-offlinehttpscodeforcescomeducourse2lesson73practicecontest289392problemc"><a href="https://codeforces.com/edu/course/2/lesson/7/3/practice/contest/289392/problem/C">C. Dynamic Connectivity Offline</a></h3>
<h4 id="题意-99">题意</h4>
<p>给您一个空无向图，其中有 n 个顶点。您必须回答三种类型的查询：</p>
<pre><code>&quot;+ $u$&quot; -- 在图中添加一条无向边 $u$ - $v$。
&quot;- $u$ $v$&quot; -- 从图形中删除一条无向边 $u$ - $v$。
&quot;?&quot; - 计算图中相连组件的数量。
</code></pre>
<h4 id="参考思路-99">参考思路</h4>
<p>考虑将所有询问离线下来，对于每条边，以时间段的形式记录其在整个时间轴上出现的时间。然后用线段树分治处理每个时间点处的联通性，处理询问即可。</p>
<h4 id="参考代码-92">参考代码</h4>
<pre><code class="language-cpp">struct DSU_maintain {
    std::vector&lt;int&gt; F, siz, rnk;
    
    int cnt;
    std::stack&lt;std::vector&lt;std::array&lt;int, 6&gt;&gt;&gt; stk;//有效操作
    //                     fx，fy，siz[fx]，siz[fy], rnk[fx], rnk[fy]
    DSU_maintain() {}
    DSU_maintain(int n) : F(n), siz(n, 1), rnk(n, 0), cnt(n) {
        std::iota(F.begin(), F.end(), 0);
        stk.push(std::vector&lt;std::array&lt;int, 6&gt;&gt;());
    }
    int find(int x) {
        while (x != F[x]) {
            x = F[x];
        }

        return x;
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        int fx = find(x);
        int fy = find(y);

        // if (siz[fx] &gt; siz[fy]) {//siz 小的连到 siz 大的上
        //     std::swap(fx, fy);
        // }
        if (rnk[fx] &gt; rnk[fy]) {//按rank合并
            std::swap(fx, fy);
        }

        if (!ok) {
            cnt--;
            stk.top().push_back({fx, fy, siz[fx], siz[fy], rnk[fx], rnk[fy]});
            F[fx] = fy;
            siz[fy] += siz[fx];
            if (rnk[fx] == rnk[fy]) rnk[fy]++;
        }
        
        return !ok;
    }

    void maintain() {
        stk.push(std::vector&lt;std::array&lt;int, 6&gt;&gt;());
    }

    void rollback() {//回滚要逆序回滚
        if (stk.size() == 0) {
            1 / stk.size();
        }
        //assert(stk.size());

        std::reverse(stk.top().begin(), stk.top().end());

        for (auto &amp;[x, y, sizx, sizy, rnkx, rnky] : stk.top()) {
            cnt++;
            F[x] = x; F[y] = y;
            siz[x] = sizx; siz[y] = sizy;
            rnk[x] = rnkx; rnk[y] = rnky;
        }

        stk.pop();
    }
};

struct SGT_conquer {
    #define lson (p&lt;&lt;1)
    #define rson (p&lt;&lt;1|1)
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt; edg;
    std::set&lt;int&gt; qry;

    std::vector&lt;int&gt; ans;
    int n, m;
    DSU_maintain dsu;

    SGT_conquer(int n, int m) : n(n), m(m), dsu(m) {//时间为n，节点有m个
        edg.resize(4 &lt;&lt; std::__lg(n));
    }
    //在时间点处添加询问
    void modify_qry(int p, int l, int r, int x) {
        if (x &lt; l || x &gt;= r) return;

        if (r - l == 1) {
            qry.insert(p);
            return;
        }

        int m = (l + r) &gt;&gt; 1;
        if (x &lt; m) modify_qry(lson, l, m, x);
        else       modify_qry(rson, m, r, x);
    }
    //在时间段中添加边
    void modify_edg(int p, int l, int r, int x, int y, std::pair&lt;int, int&gt; k) {
        if (x &gt;= y) return;
        if (l &gt;= y || r &lt;= x) return;

        if (x &lt;= l &amp;&amp; r &lt;= y) {
            edg[p].push_back(k);
            return;
        }

        int m = (l + r) &gt;&gt; 1;
        if (x &lt; m) modify_edg(lson, l, m, x, y, k);
        if (y &gt; m) modify_edg(rson, m, r, x, y, k);
    }

    void conquer(int p, int l, int r) {
        if (l &gt;= r) return;

        if (r - l == 1) {
            dsu.maintain();
            for (auto &amp;[x, y] : edg[p]) {
                dsu.join(x, y);
            }

            if (qry.count(p)) {
                ans.push_back(dsu.cnt);
            }

            dsu.rollback();
            return;
        }

        dsu.maintain();

        for (auto &amp;[x, y] : edg[p]) {
            dsu.join(x, y);
        }

        int m = (l + r) &gt;&gt; 1;
        conquer(lson, l, m);
        conquer(rson, m, r);

        dsu.rollback();
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    //if (m == 0) return;

    std::map&lt;std::pair&lt;int, int&gt;, int&gt; mpL;//记录起始时间 
    std::set&lt;std::array&lt;int, 5&gt;&gt; qry;//[l, r, op, x, y]，实际上存的是 [l, r)
    for (int i = 0; i &lt; m; i++) {
        char op;
        std::cin &gt;&gt; op;
        if (op == '?') {
            qry.insert({i, i + 1, 0, -10, -10});
        } else if (op == '+') {
            int x, y; std::cin &gt;&gt; x &gt;&gt; y; x--; y--; if (x &gt; y) std::swap(x, y);

            mpL[{x, y}] = i;
        } else {
            int x, y; std::cin &gt;&gt; x &gt;&gt; y; x--; y--; if (x &gt; y) std::swap(x, y);

            qry.insert({mpL[{x, y}], i + 1, 1, x, y});

            mpL.erase({x, y});
        }
    }

    for (auto &amp;[p, t] : mpL) {
        auto &amp;[x, y] = p;
        qry.insert({t, m, 1, x, y});
    }

    SGT_conquer sgt(m, n);//时间，点集大小

    for (auto &amp;[l, r, op, x, y] : qry) {
        if (op == 1) {
            sgt.modify_edg(1, 0, m, l, r, std::make_pair(x, y));
        } else {
            sgt.modify_qry(1, 0, m, l);
        }
    }

    sgt.conquer(1, 0, m);

    for (auto &amp;i : sgt.ans) std::cout &lt;&lt; i &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h1 id="introduction-to-graphic-theory">Introduction to Graphic Theory</h1>
<h2 id="step-1-6">Step 1</h2>
<h3 id="a-undirected-graphhttpscodeforcescomeducourse2lesson81practicecontest290939problemalocaleen"><a href="https://codeforces.com/edu/course/2/lesson/8/1/practice/contest/290939/problem/A?locale=en">A. Undirected Graph?</a></h3>
<h4 id="题意-100">题意</h4>
<p>给你两个数字 $n$ 和 $m$ 以及一个由 $m$ 对整数组成的列表（一对整数中的两个元素都在 $1$ 和 $n$ 之间）。检查给定的整数对列表是否是某个无向图的正确边列表（图中不应有循环或多条边）。</p>
<h4 id="参考思路-100">参考思路</h4>
<p>直接将所有非自环边全部按小标号在前的顺序存到 set 中，再判断 set 大小是否等于 $m$ 即可。</p>
<h4 id="参考代码-93">参考代码</h4>
<pre><code>void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::set&lt;std::pair&lt;int, int&gt;&gt; s;

    for (int i = 0; i &lt; m; i++) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        if (x != y) {
            if (x &gt; y) std::swap(x, y);
            s.insert({x, y});
        }
    }

    std::cout &lt;&lt; (s.size() == m ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="b-vertex-degreeshttpscodeforcescomeducourse2lesson81practicecontest290939problemb"><a href="https://codeforces.com/edu/course/2/lesson/8/1/practice/contest/290939/problem/B">B. Vertex Degrees</a></h3>
<h4 id="题意-101">题意</h4>
<p>给你一个无向图，并列出了它的边。请找出图中所有顶点的度数。</p>
<h4 id="参考思路-101">参考思路</h4>
<p>直接开一个度数数组，然后每次加边，直接将对应节点的度数加一即可。</p>
<h4 id="参考代码-94">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;int&gt; d(n);
    while (m--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        x--; y--;
        d[x]++; d[y]++;
    }

    for (auto &amp;i : d) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; std::cout &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="c-type-of-subsequencehttpscodeforcescomeducourse2lesson81practicecontest290939problemc"><a href="https://codeforces.com/edu/course/2/lesson/8/1/practice/contest/290939/problem/C">C. Type of Subsequence</a></h3>
<h4 id="题意-102">题意</h4>
<p>给你一个无向图和一系列顶点。该图由其边的列表给出。请判断给定的顶点序列是否是：</p>
<ul>
<li>一个简单循环、</li>
<li>一个循环</li>
<li>简单路径</li>
<li>一条路径</li>
<li>或都不是。</li>
</ul>
<h4 id="参考思路-102">参考思路</h4>
<p>很无聊的定义题，注意特判只有一个点的图是 &ldquo;none&rdquo;。</p>
<h4 id="参考代码-95">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m, k;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;

    std::vector&lt;int&gt; seq(k);
    for (auto &amp;i : seq) (std::cin &gt;&gt; i), i--;

    std::vector edg(n, std::set&lt;int&gt;());
    while (m--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        x--; y--;
        edg[x].insert(y);
        edg[y].insert(x);
    }

    if (k == 2 &amp;&amp; (seq.front() == seq.back())) {
        //assert(0);
        std::cout &lt;&lt; &quot;none\n&quot;;
        return;
    }

    for (int i = 0; i &lt; k - 1; i++) {//如果不连通
        if (!edg[seq[i]].contains(seq[i + 1])) {
            std::cout &lt;&lt; &quot;none\n&quot;;
            return;
        }
    }

    std::set&lt;int&gt; d;
    for (auto &amp;i : seq) d.insert(i);

    if (seq.front() == seq.back()) {//是环
        if (d.size() == k - 1) std::cout &lt;&lt; &quot;simple &quot;;
        std::cout &lt;&lt; &quot;cycle\n&quot;;
    } else {
        if (d.size() == k) std::cout &lt;&lt; &quot;simple &quot;;
        std::cout &lt;&lt; &quot;path\n&quot;;
    }
}
</code></pre>
<h3 id="d-connectivity-componentshttpscodeforcescomeducourse2lesson81practicecontest290939problemd"><a href="https://codeforces.com/edu/course/2/lesson/8/1/practice/contest/290939/problem/D">D. Connectivity Components?</a></h3>
<h4 id="题意-103">题意</h4>
<p>给你一个无向图，图中有一个边列表和一组顶点。请检查给定的顶点是否正好构成给定图形的一个或多个连通部分。换句话说，给定的顶点必须是某个连接部分子集的顶点。</p>
<h4 id="参考思路-103">参考思路</h4>
<p>问你，给定点集是否恰好是 原始图的几个联通分量的并集。</p>
<p>考虑用带权并查集维护联通块大小，然后将点集涉及的联通分量全存入 set 中去重，最后判断 set 中的联通分量大小和是否为 $k$即可。</p>
<h4 id="参考代码-96">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F, siz;
    DSU(int n) : F(n), siz(n, 1) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        
        int fx = find(x);
        int fy = find(y);

        if (fx ^ fy) {
            F[fx] = fy;
            siz[fy] += siz[fx];
        }

        return !ok;
    }
};

void solve() {
    int n, m, k;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;

    DSU dsu(n + 1);
    std::vector&lt;int&gt; a(k);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    while (m--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        dsu.join(x, y);
    }

    std::set&lt;int&gt; s;
    for (auto &amp;i : a) s.insert(dsu.find(i));

    int cnt = 0;
    for (auto &amp;i : s) cnt += dsu.siz[i];

    std::cout &lt;&lt; (cnt == k ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="e-tree-degreeshttpscodeforcescomeducourse2lesson81practicecontest290939probleme"><a href="https://codeforces.com/edu/course/2/lesson/8/1/practice/contest/290939/problem/E">E. Tree Degrees</a></h3>
<h4 id="题意-104">题意</h4>
<p>给你一个由 $n$ 个元素组成的数组 $d$ 。请检查是否存在一棵树，它的度数数组与数组 $d$ 匹配。</p>
<p>度数数组 - 这样的数组 $d$ ，其中每个顶点 $u$ 的 $d_u$ 值等于顶点 $u$ 的度数。</p>
<h4 id="参考思路-104">参考思路</h4>
<p>分类讨论</p>
<ul>
<li>当 $n = 1$ 时，判断 $d[0] == 0$ 即可；</li>
<li>当 $n \ne 1$ 时，先判断度数和是否等于， $2(n - 1)$ 再判断度数序列中是否存在 0 度数节点即可。</li>
</ul>
<h4 id="参考代码-97">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; d(n);
    for (auto &amp;i : d) std::cin &gt;&gt; i;

    if (n == 1) {
        std::cout &lt;&lt; (d[0] == 0 ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\n&quot;;
        return;
    }

    if (std::accumulate(d.begin(), d.end(), 0ll) != 2 * (n - 1)) {
        std::cout &lt;&lt; &quot;NO\n&quot;;
        return;
    }

    for (auto &amp;i : d) if (!i) {
        std::cout &lt;&lt; &quot;NO\n&quot;;
        return;
    }

    std::cout &lt;&lt; &quot;YES\n&quot;;
}
</code></pre>
<h3 id="f-graph-by-array-of-degreeshttpscodeforcescomeducourse2lesson81practicecontest290939problemf"><a href="https://codeforces.com/edu/course/2/lesson/8/1/practice/contest/290939/problem/F">F. Graph by Array of Degrees</a></h3>
<h4 id="题意-105">题意</h4>
<p>给您一个数组，其中包含某个无向图的度数。用给定数组构建任意无向图。</p>
<p><strong>图中不能有循环或多条边。</strong></p>
<p><strong>图中的顶点从 $1$ 开始编号。</strong></p>
<h4 id="参考思路-105">参考思路</h4>
<p>暴力模拟，将度数从大到小排序放入优先队列中，每次取出一个节点后，暴力向后取出 $d[i]$ 个节点，并连边，连完边后将 $d[j] &gt; 0$ 的点加回队列中。时间复杂度 $O(n^2)$</p>
<h4 id="参考代码-98">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; d(n);
    for (auto &amp;i : d) std::cin &gt;&gt; i;

    std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; q;

    std::cout &lt;&lt; std::accumulate(d.begin(), d.end(), 0ll) / 2 &lt;&lt; &quot;\n&quot;;

    for (int i = 0; i &lt; n; i++) {
        if (d[i]) q.push({d[i], i + 1});
    }

    while (q.size()) {
        auto [d_, now] = q.top(); q.pop();
        std::vector&lt;Z&gt; res;

        while (d_--) {
            auto [d__, nxt] = q.top(); q.pop();
            
            std::cout &lt;&lt; now &lt;&lt; &quot; &quot; &lt;&lt; nxt &lt;&lt; &quot;\n&quot;;

            if (--d__) {
                res.push_back({d__, nxt});
            }
        }

        for (auto &amp;p : res) q.push(p);
    }
}
</code></pre>
<h3 id="g-graph-by-set-of-degreeshttpscodeforcescomeducourse2lesson81practicecontest290939problemglocaleen"><a href="https://codeforces.com/edu/course/2/lesson/8/1/practice/contest/290939/problem/G?locale=en">G. Graph by Set of Degrees</a></h3>
<h4 id="题意-106">题意</h4>
<p>给出了一个无向图的度集。从给定的集合构造一个顶点数最少的无向图。</p>
<p>图表中不能有循环或多边</p>
<p>图的顶点从一开始编号</p>
<h4 id="参考思路-106">参考思路</h4>
<p>考虑先想办法构造一个合法度数序列，不难发现一定有解，比如说由 $n$ 个完全图取并集，但是题目要求点数最少，所以不能直接这样构造。</p>
<p>手玩样例后我们不难发现，最少的点数似乎就是最大数字加一。考虑下面这种构造方式：</p>
<p>将度数序列从大到小排序后，设三个指针，一个（$i$）指向原度数集数组的头元素，一个（$j$）指向尾元素，再设一个初始值均为 $0$ 的，长为 $\max a_i + 1$ 的度数数组，用一个指针（$k$）指向数组的头元素。</p>
<p>当左指针指向 $x$，右指针指向 $y$ 时，将度数数组中，$[k, k + y - 1]$ 区间的元素均加上 $x$，将 $[k + y, k + x]$ 区间的元素均加上 $y$，然后 $i$ 指针右移一位，$j$ 指针左移一位，$k$ 指针右移 $y$ 位，知道 $i &gt; j$ 时停止构造。</p>
<p>此时构造出来的度数序列就是一个合法的，点数最小的度数序列。接着再利用这个度数序列直接暴力 $O(n^2\log n)$ 构造相应的图即可。</p>
<p>时间复杂度：$O(n^2\log n)$</p>
<h4 id="参考代码-99">参考代码</h4>
<pre><code class="language-cpp">using Z = std::pair&lt;int, int&gt;;

void solve() {
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;
    
    std::sort(a.rbegin(), a.rend());
    
    std::vector&lt;int&gt; d(a[0] + 1);
    int i = 0, j = n - 1, k = 0;
    while (i &lt;= j) {
        while (a[j]) {
            for (int l = k + 1; l &lt;= k + a[i]; l++) d[l]++;
            for (int l = i + 1; l &lt;= j; l++) a[l]--;
            d[k++] += a[i];
            a[i]--;
        }
        a[i] = 0;
        while (i &lt; n &amp;&amp; !a[i]) i++;
        while (j &gt;= 0 &amp;&amp; !a[j]) j--;
        
        //for (auto &amp;i : d) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\n';
    }
    
    //for (auto &amp;i : d) std::cout &lt;&lt; i &lt;&lt; ' ';
    
    n = d.size();// F 题代码照搬即可
    std::priority_queue&lt;Z&gt; q;

    std::cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; std::accumulate(d.begin(), d.end(), 0ll) / 2 &lt;&lt; &quot;\n&quot;;

    for (int i = 0; i &lt; n; i++) {
        if (d[i]) q.push({d[i], i + 1});
    }

    while (q.size()) {
        auto [d_, now] = q.top(); q.pop();
        std::vector&lt;Z&gt; res;

        while (d_--) {
            auto [d__, nxt] = q.top(); q.pop();
            
            std::cout &lt;&lt; now &lt;&lt; &quot; &quot; &lt;&lt; nxt &lt;&lt; &quot;\n&quot;;

            if (--d__) {
                res.push_back({d__, nxt});
            }
        }

        for (auto &amp;p : res) q.push(p);
    }
}
</code></pre>
<h2 id="step-2-6">Step 2</h2>
<h3 id="a-number-of-verticeshttpscodeforcescomeducourse2lesson82practicecontest290940problema"><a href="https://codeforces.com/edu/course/2/lesson/8/2/practice/contest/290940/problem/A">A. Number of Vertices</a></h3>
<h4 id="题意-107">题意</h4>
<p>您将获得一个非负整数 $m$ 。打印无向图中具有精确 $m$ 边的最小顶点数。</p>
<h4 id="参考思路-107">参考思路</h4>
<p>定义题，用完全图贪心二分即可。</p>
<h4 id="参考代码-100">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n;
    std::cin &gt;&gt; n;

    i64 l = 0, r = n + 1;
    while (l &lt;= r) {
        i64 mid = (l + r) / 2;
        if (mid * (mid - 1) / 2 &gt;= n) r = mid - 1;
        else l = mid + 1;
    }

    std::cout &lt;&lt; r + 1 &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="b-regular-graphhttpscodeforcescomeducourse2lesson82practicecontest290940problemb"><a href="https://codeforces.com/edu/course/2/lesson/8/2/practice/contest/290940/problem/B">B. Regular Graph</a></h3>
<h4 id="题意-108">题意</h4>
<p>给定两个整数 $n$ 和 $k$ 。构建一个具有 $n$ 顶点的 $k$ - 正则无向图，或者说它不存在。</p>
<h4 id="参考思路-108">参考思路</h4>
<p>定义题，$k$-正则图，即每个点度数均为 $k$ 的图，先特判 $nk$ 是否为偶数，以及 $n$ 是否大于 $k$。（定义）</p>
<p>如果均满足以上条件，那么一定存在 $k$-正则图。</p>
<p>当 $k = 1$ 时，直接构造 $n$ 元环并输出即可。</p>
<p>当 $k \ne 1$ 时，分奇偶两类构造即可。当 $k$ 为偶数时，考虑类似 $n$ 元环的构造，每隔 $0$ 个节点连一次边，每隔 $1$ 个节点连一次边，&hellip;，每隔 $\frac{k}{2} - 1$ 个节点连一次边，即可保证最终每个点的度数均为 $k$；当 $k$ 为 奇数时，$n$ 必为偶数，在上述构造方法中，添加一种 每隔 $\frac{n}{2} - 1$ 个节点连一次边（对位连边）的连边方式即可。</p>
<h4 id="参考代码-101">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;

    if (n * k &amp; 1 || k &gt;= n) {
        std::cout &lt;&lt; &quot;NO\n&quot;;
        return;
    }

    std::set&lt;std::pair&lt;int, int&gt;&gt; edg;
    auto insert = [&amp;](int x, int y) {
        if (x &gt; y) std::swap(x, y);
        edg.insert({x, y});
    };

    if (k == 1) {
        for (int i = 0; i &lt; n; i += 2) {
            insert(i, i + 1);
        }
    } else {
        if (k &amp; 1) {
            for (int i = 1; i &lt;= k / 2; i++) {
                for (int j = 0; j &lt; n; j++) {
                    insert(j, (j + i) % n);
                }
            }
            for (int i = 0; i &lt; n; i++) {
                insert(i, (i + n / 2) % n);
            }
        } else {//偶数
            for (int i = 1; i &lt;= k / 2; i++) {
                for (int j = 0; j &lt; n; j++) {
                    insert(j, (j + i) % n);
                }
            }
        }
    }

    std::vector&lt;int&gt; d(n);
    for (auto &amp;[x, y] : edg) {
        d[x]++; d[y]++;
    }
    std::set&lt;int&gt; ds;
    for (auto &amp;i : d) ds.insert(i);
    assert(ds.size() == 1 &amp;&amp; *ds.begin() == k);

    std::cout &lt;&lt; &quot;YES\n&quot;;
    std::cout &lt;&lt; edg.size() &lt;&lt; &quot;\n&quot;;
    for (auto &amp;[x, y] : edg) {
        std::cout &lt;&lt; x + 1 &lt;&lt; &quot; &quot; &lt;&lt; y + 1 &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="c-empty-and-completehttpscodeforcescomeducourse2lesson82practicecontest290940problemc"><a href="https://codeforces.com/edu/course/2/lesson/8/2/practice/contest/290940/problem/C">C. Empty and Complete</a></h3>
<h4 id="题意-109">题意</h4>
<p>通过给出一个无向图的边列表，可以得到一个无向图。检查给定的图是最多一个空图和最多一个完整图的并。</p>
<h4 id="参考思路-109">参考思路</h4>
<p>非常抽象的定义题，在此题中，空图的定义为，不包含任何边的图，所以只给一个点集也是空图。</p>
<p>因此，我们只需要判断原图中联通块大小不为 1 的数量是否小于等于 1，等于 1 时，通过那个联通块中的边数和点数，判断是否是一个完全图即可。</p>
<h4 id="参考代码-102">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F, siz, val;
    int cnt;
    DSU(int n) : F(n), siz(n, 1), val(n, 0), cnt(n) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        int fx = find(x), fy = find(y);

        if (fx ^ fy) {
            F[fx] = fy;
            siz[fy] += siz[fx];
            val[fy] += val[fx];
            cnt--;
        }

        val[fy]++;

        return !ok;
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    DSU dsu(n);
    while (m--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        x--; y--;
        dsu.join(x, y);
    }

    int cnt = 0;//计数空点
    for (int i = 0; i &lt; n; i++) {
        cnt += (dsu.siz[dsu.find(i)] == 1);
    }

    if (dsu.cnt - cnt &gt; 1) {
        std::cout &lt;&lt; &quot;NO\n&quot;;
    } else if (dsu.cnt - cnt == 0) {
        std::cout &lt;&lt; &quot;YES\n&quot;;
    } else {
        bool ok = 0;
        for (int i = 0; i &lt; n; i++) {
            int u = dsu.find(i);
            if (dsu.siz[u] != 1) {
                ok = (dsu.val[u] == (1ll * dsu.siz[u] * (dsu.siz[u] - 1) / 2));
                break;
            }
        }

        std::cout &lt;&lt; (ok ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="d-complete-componentshttpscodeforcescomeducourse2lesson82practicecontest290940problemd"><a href="https://codeforces.com/edu/course/2/lesson/8/2/practice/contest/290940/problem/D">D. Complete Components</a></h3>
<h4 id="题意-110">题意</h4>
<p>给出一个由 $n$ 个顶点和 $m$ 个边组成的无向图。给定图的每个连接元件 (图论) 都是一个完整的子图。在给定的图中查找连接组件的数目。</p>
<h4 id="参考思路-110">参考思路</h4>
<p>并查集直接做即可。</p>
<h4 id="参考代码-103">参考代码</h4>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; F;
    DSU(int n) : F(n + 1) {
        std::iota(F.begin(), F.end(), 0);
    }
    int find(int x) {
        return F[x] == x ? F[x] : F[x] = find(F[x]);
    }
    bool join(int x, int y) {
        bool ok = (find(x) == find(y));
        F[find(x)] = find(y);
        return !ok;
    }
};

void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    DSU dsu(n);
    while (m--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        x--; y--;
        n -= dsu.join(x, y);
    }

    std::cout &lt;&lt; n &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h2 id="step-3-6">Step 3</h2>
<h3 id="a-sources-and-sinkshttpscodeforcescomeducourse2lesson83practicecontest290941problema"><a href="https://codeforces.com/edu/course/2/lesson/8/3/practice/contest/290941/problem/A">A. Sources and Sinks</a></h3>
<h4 id="题意-111">题意</h4>
<p>通过弧列表给出一个有向图。</p>
<p>有向图的源是一个顶点 $u$ ，其中没有顶点 $v$ ，因此 $v$ 与 $u$ 相邻 (在 $u$ 中没有进入的弧)。</p>
<p>有向图的汇是一个顶点 $u$ ，该顶点没有顶点 $v$ ，因此 $u$ 与 $v$ 相邻 (从 $u$ 出没有弧)。</p>
<p>计算给定图的源和汇的数目。</p>
<h4 id="参考思路-111">参考思路</h4>
<p>按照题意统计出度和入度，统计出度为 0 的点以及入度为 0 的点数即可。</p>
<h4 id="参考代码-104">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;int&gt; in(n), out(n);
    while (m--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        x--; y--;
        out[x]++; in[y]++;
    }

    int sou = 0, sin = 0;
    for (auto &amp;i : in) sou += (i == 0);
    for (auto &amp;i : out) sin += (i == 0);

    std::cout &lt;&lt; sou &lt;&lt; &quot; &quot; &lt;&lt; sin &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="b-functional-graphhttpscodeforcescomeducourse2lesson83practicecontest290941problemb"><a href="https://codeforces.com/edu/course/2/lesson/8/3/practice/contest/290941/problem/B">B. Functional Graph</a></h3>
<h4 id="题意-112">题意</h4>
<p>通过弧列表给出一个有向图。在一个步骤中，您可以在图表中添加或删除任何弧。</p>
<p>如果每个顶点的输出度为 $1$ ，则图称为泛函图。</p>
<p>找出从给定的图中得到一个函数图所需的最小移动次数。</p>
<h4 id="参考思路-112">参考思路</h4>
<p>按照题意记录点出度，贪心删边即可。</p>
<h4 id="参考代码-105">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; out(n);
    
    int cnt = n;
    while (m--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        x--; y--;
        if (out[x]) cnt++;
        else out[x] = 1, cnt--;
    }

    std::cout &lt;&lt; cnt &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="c-equal-degreeshttpscodeforcescomeducourse2lesson83practicecontest290941problemc"><a href="https://codeforces.com/edu/course/2/lesson/8/3/practice/contest/290941/problem/C">C. Equal Degrees</a></h3>
<h4 id="题意-113">题意</h4>
<p>给定两个整数 $d_1$ 和 $d_2$ 。根据弧的个数，构造一个最小的非空有向图，使得每个顶点的传出度为 $d_1$ ，传入度为 $d_2$ 。</p>
<h4 id="参考思路-113">参考思路</h4>
<p>直接贪心构造一个邻接矩阵全 1 的有向图即可。</p>
<h4 id="参考代码-106">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int a, b;
    std::cin &gt;&gt; a &gt;&gt; b;
    if (a ^ b) {
        std::cout &lt;&lt; &quot;NO\n&quot;;
        return;
    }
    std::cout &lt;&lt; &quot;YES\n&quot;;

    std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; a * a &lt;&lt; &quot;\n&quot;;
    for (int i = 1; i &lt;= a; i++) {
        for (int j = 1; j &lt;= a; j++) {
            std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
<h3 id="d-second-neighborshttpscodeforcescomeducourse2lesson83practicecontest290941problemd"><a href="https://codeforces.com/edu/course/2/lesson/8/3/practice/contest/290941/problem/D">D. Second Neighbors</a></h3>
<h4 id="题意-114">题意</h4>
<p>通过弧列表给出一个有向图。对于每个顶点 $v$ 按升序输出与至少一个与 $v$ 相邻的顶点相邻的所有顶点。</p>
<h4 id="参考思路-114">参考思路</h4>
<p>复杂度够，直接按题意模拟即可。</p>
<h4 id="参考代码-107">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector edg(n, std::vector&lt;int&gt;());
    while (m--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        x--; y--;
        edg[x].push_back(y);
    }

    for (int i = 0; i &lt; n; i++) {
        std::set&lt;int&gt; s;
        for (auto &amp;nxt : edg[i]) {
            for (auto &amp;nnxt : edg[nxt]) {
                //if (nnxt == i) continue;
                s.insert(nnxt);
            }
        }

        for (auto &amp;j : s) std::cout &lt;&lt; j + 1 &lt;&lt; &quot; &quot;;
        std::cout &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h2 id="step-4-5">Step 4</h2>
<h3 id="a-adjacency-matrixhttpscodeforcescomeducourse2lesson84practicecontest290943problema"><a href="https://codeforces.com/edu/course/2/lesson/8/4/practice/contest/290943/problem/A">A. Adjacency Matrix</a></h3>
<h4 id="题意-115">题意</h4>
<p>你通过一个无向图的边列表得到一个无向图，构造给定图的邻接矩阵。</p>
<h4 id="参考思路-115">参考思路</h4>
<p>直接按题意模拟即可。</p>
<h4 id="参考代码-108">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector edg(n, std::vector&lt;int&gt;(n));
    while (m--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        x--; y--;
        edg[x][y] = edg[y][x] = 1;
    }

    for (auto &amp;v : edg) {
        for (auto &amp;i : v) {
            std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
        }
        std::cout &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="b-adjacency-matrixhttpscodeforcescomeducourse2lesson84practicecontest290943problemb"><a href="https://codeforces.com/edu/course/2/lesson/8/4/practice/contest/290943/problem/B">B. Adjacency Matrix?</a></h3>
<h4 id="题意-116">题意</h4>
<p>您将得到一个数字 $n$ 和一个大小为 $n \times n$ 的二进制 (由零和一组成) 矩阵。检查给定的矩阵是否是某个无向图的邻接矩阵，如果是，输出这个图的顶点度数。</p>
<h4 id="参考思路-116">参考思路</h4>
<p>判断矩阵是否对称，且主对角线均为 0 即可。输出度数时，输出矩阵每行的和即可。</p>
<h4 id="参考代码-109">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n;
    std::cin &gt;&gt; n;
    std::vector edg(n, std::vector&lt;int&gt;(n));
    for (auto &amp;v : edg) {
        for (auto &amp;i : v) {
            std::cin &gt;&gt; i;
        }
    }

    bool ok = 1;
    for (int i = 0; i &lt; n; i++) {
        ok &amp;= (!edg[i][i]);
        for (int j = i + 1; j &lt; n; j++) {
            ok &amp;= (edg[i][j] == edg[j][i]);
        }
    }

    if (!ok) {
        std::cout &lt;&lt; &quot;NO\n&quot;;
        return;
    }

    std::cout &lt;&lt; &quot;YES\n&quot;;
    for (auto &amp;v : edg) std::cout &lt;&lt; std::accumulate(v.begin(), v.end(), 0) &lt;&lt; &quot; &quot;;
    std::cout &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="c-adjacency-listshttpscodeforcescomeducourse2lesson84practicecontest290943problemc"><a href="https://codeforces.com/edu/course/2/lesson/8/4/practice/contest/290943/problem/C">C. Adjacency Lists</a></h3>
<h4 id="题意-117">题意</h4>
<p>给你一个无向图的邻接矩阵，根据给定的矩阵建立邻接列表。</p>
<h4 id="参考思路-117">参考思路</h4>
<p>按照题意模拟即可。</p>
<h4 id="参考代码-110">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n;
    std::cin &gt;&gt; n;
    std::vector edg(n, std::vector&lt;int&gt;(n));

    for (auto &amp;v : edg) {
        for (auto &amp;i : v) {
            std::cin &gt;&gt; i;
        }
    }

    for (auto &amp;v : edg) {
        for (int i = 0; i &lt; n; i++) {
            if (v[i]) std::cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;;
        }
        std::cout &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h3 id="d-two-edgeshttpscodeforcescomeducourse2lesson84practicecontest290943problemd"><a href="https://codeforces.com/edu/course/2/lesson/8/4/practice/contest/290943/problem/D">D. Two Edges</a></h3>
<h4 id="题意-118">题意</h4>
<p>通过给出一个无向图的边列表，可以得到一个无向图。查找图中具有一个共同端点的边对数，并且其他两个端点之间的距离正好为 $2$ 。</p>
<p>如果在第一个选项中存在一个边，但在第二个选项中没有，则认为两个选项是不同的。</p>
<h4 id="参考思路-118">参考思路</h4>
<p>考虑每个点，如果不限制与其相邻的两点间是否有连边，那么以每个点为中心，共有 $ans = \sum \frac{d_i(d_i - 1)}{2}$ 种方案。不难发现需要剔除的不合法方案是三元环，所以只需再跑一遍无向图三元环计数，算出三元环数量 $cnt$ 后，$ans - 3cnt$ 即为所求答案。</p>
<p>时间复杂度：$O(m\sqrt m)$</p>
<h4 id="参考代码-111">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;int&gt; d(n);

    std::vector edg(n, std::vector&lt;int&gt;());
    while (m--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        x--; y--;
        edg[x].push_back(y);
        edg[y].push_back(x);
        d[x]++; d[y]++;
    }

    i64 ans = 0;
    for (auto &amp;i : d) {
        ans += 1ll * i * (i - 1) / 2;
    }

    std::vector redg(n, std::vector&lt;int&gt;());
    for (int i = 0; i &lt; n; i++) {
        for (auto &amp;nxt : edg[i]) {
            if (d[i] &gt; d[nxt]) {
                redg[i].push_back(nxt);
            } else if (d[i] &lt; d[nxt]) {
                redg[nxt].push_back(i);
            } else if (i &gt; nxt) {
                redg[i].push_back(nxt);
            } else {
                redg[nxt].push_back(i);
            }
        }
    }

    for (auto &amp;v : redg) {
        std::sort(v.begin(), v.end());
        v.erase(std::unique(v.begin(), v.end()), v.end());
    }

    int cnt = 0;

    std::vector&lt;int&gt; vis(n, -1);

    for (int u = 0; u &lt; n; u++) {
        for (auto &amp;v : redg[u]) {
            vis[v] = u;
        }
        for (auto &amp;v : redg[u]) {
            for (auto &amp;w : redg[v]) {
                cnt += (vis[w] == u);
            }
        }
    }

    std::cout &lt;&lt; ans - 3 * cnt &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h3 id="e-complete-subgraphshttpscodeforcescomeducourse2lesson84practicecontest290943probleme"><a href="https://codeforces.com/edu/course/2/lesson/8/4/practice/contest/290943/problem/E">E. Complete Subgraphs</a></h3>
<h4 id="题意-119">题意</h4>
<p>通过给出一个无向图的边列表，可以得到一个无向图。查找选择形成 $K_4$ 的四个顶点的方法数。</p>
<p>如果有这样一个顶点存在于第一种方式中，但不存在于第二种方式中，则有两种方式被认为是不同的。</p>
<h4 id="参考思路-119">参考思路</h4>
<p>直接无向图三元环计数，在找到三元环后，通过 bitset 暴力统计与当前三个点间均有连边的点数即可。</p>
<p>时间复杂度：$O(\frac{nm\sqrt m}{64})$</p>
<h4 id="参考代码-112">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    if (m &lt; 6) {
        while (m--) {
            int x, y;
            std::cin &gt;&gt; x &gt;&gt; y;
        }
        std::cout &lt;&lt; 0 &lt;&lt; &quot;\n&quot;;
        return;
    }

    std::vector&lt;int&gt; d(n);

    std::vector&lt;std::bitset&lt;4000&gt;&gt; adj(n);

    std::vector edg(n, std::vector&lt;int&gt;());
    while (m--) {
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        x--; y--;
        edg[x].push_back(y);

        adj[x][y] = adj[y][x] = 1;
        d[x]++; d[y]++;
    }

    std::vector redg(n, std::vector&lt;int&gt;());
    for (int i = 0; i &lt; n; i++) {
        for (auto &amp;nxt : edg[i]) {
            if (d[i] &gt; d[nxt]) {
                redg[i].push_back(nxt);
            } else if (d[i] &lt; d[nxt]) {
                redg[nxt].push_back(i);
            } else if (i &gt; nxt) {
                redg[i].push_back(nxt);
            } else {
                redg[nxt].push_back(i);
            }
        }
    }

    i64 cnt = 0;

    std::vector&lt;int&gt; vis(n, -1);
    for (int u = 0; u &lt; n; u++) {
        for (auto &amp;v : redg[u]) {
            vis[v] = u;
        }
        for (auto &amp;v : redg[u]) {
            for (auto &amp;w : redg[v]) {
                if (vis[w] == u) {
                    cnt += (adj[u] &amp; adj[v] &amp; adj[w]).count();
                }
            }
        }
    }

    std::cout &lt;&lt; cnt / 4 &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h1 id="two-pointers-method">Two Pointers Method</h1>
<h2 id="step-1-7">Step 1</h2>
<h3 id="a-merging-arrayshttpscodeforcescomeducourse2lesson91practicecontest307092problema"><a href="https://codeforces.com/edu/course/2/lesson/9/1/practice/contest/307092/problem/A">A. Merging Arrays</a></h3>
<h4 id="题意-120">题意</h4>
<p>给你两个数组，按非递减顺序排序。将它们合并成一个排序的数组。</p>
<h4 id="参考思路-120">参考思路</h4>
<p>双指针，当两边指针均未到达数组尾部时，对比两个指针所指向的数的大小，选择输出最小的数即可。</p>
<h4 id="参考代码-113">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;int&gt; a(n), b(m);

    for (auto &amp;i : a) std::cin &gt;&gt; i;
    for (auto &amp;i : b) std::cin &gt;&gt; i;

    int i = 0, j = 0;
    while (i != n || j != m) {
        if (i == n || j == m) {
            if (i == n) std::cout &lt;&lt; b[j++] &lt;&lt; &quot; &quot;;
            else        std::cout &lt;&lt; a[i++] &lt;&lt; &quot; &quot;;            
        } else {
            if (a[i] &lt; b[j])    std::cout &lt;&lt; a[i++] &lt;&lt; &quot; &quot;;
            else                std::cout &lt;&lt; b[j++] &lt;&lt; &quot; &quot;;
        }
    }
}
</code></pre>
<h3 id="b-number-of-smallerhttpscodeforcescomeducourse2lesson91practicecontest307092problemb"><a href="https://codeforces.com/edu/course/2/lesson/9/1/practice/contest/307092/problem/B">B. Number of Smaller</a></h3>
<h4 id="题意-121">题意</h4>
<p>给您两个数组，按非递减顺序排序。对于第二个数组中的每个元素，找到第一个数组中严格小于它的元素数。</p>
<h4 id="参考思路-121">参考思路</h4>
<p>双指针维护，对于第二个数组中的每个元素，找到第一个大于等于其的数的下标，输出即可。</p>
<h4 id="参考代码-114">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; a(n), b(m);

    for (auto &amp;i : a) std::cin &gt;&gt; i;
    for (auto &amp;i : b) std::cin &gt;&gt; i;

    int i = 0, j = 0;
    while (j &lt; m) {
        while (i &lt; n &amp;&amp; a[i] &lt; b[j]) i++;
        std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
        j++;
    }
}
</code></pre>
<h3 id="c-number-of-equalhttpscodeforcescomeducourse2lesson91practicecontest307092problemc"><a href="https://codeforces.com/edu/course/2/lesson/9/1/practice/contest/307092/problem/C">C. Number of Equal</a></h3>
<h4 id="题意-122">题意</h4>
<p>给您两个数组 $a$ 和 $b$ ，按非递减顺序排序。查找其中 $a_i = b_j$ 的对 $(i, j)$ 的数目。</p>
<h4 id="参考思路-122">参考思路</h4>
<p>双指针维护统计，具体实现细节看代码吧。</p>
<h4 id="参考代码-115">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;int&gt; a(n), b(m);
    for (auto &amp;i : a) std::cin &gt;&gt; i;
    for (auto &amp;i : b) std::cin &gt;&gt; i;

    i64 sum = 0;

    int i = 0, j = 0;
    while (i &lt; n &amp;&amp; j &lt; m) {
        while (i &lt; n &amp;&amp; j &lt; m &amp;&amp; a[i] != b[j]) {
            while (j &lt; m &amp;&amp; i &lt; n &amp;&amp; a[i] &lt; b[j]) i++;
            while (i &lt; n &amp;&amp; j &lt; m &amp;&amp; a[i] &gt; b[j]) j++;
        }
        
        if (!(i &lt; n &amp;&amp; j &lt; m)) break;

        int res = a[i];
        int cnta = 0, cntb = 0;
        while (i &lt; n &amp;&amp; a[i] == res) cnta++, i++;
        while (j &lt; m &amp;&amp; b[j] == res) cntb++, j++;

        sum += 1ll * cnta * cntb;
    }

    std::cout &lt;&lt; sum;
}
</code></pre>
<h2 id="step-2-7">Step 2</h2>
<h3 id="a-segment-with-small-sumhttpscodeforcescomeducourse2lesson92practicecontest307093problema"><a href="https://codeforces.com/edu/course/2/lesson/9/2/practice/contest/307093/problem/A">A. Segment with Small Sum</a></h3>
<h4 id="题意-123">题意</h4>
<p>给定一个由 $n$ 个整数 $a_i$ 组成的数组。如果数组中 $a[l..r]$ ( $1\le l\le r\le n$ )段的元素之和最多为 $s$ ，那么这段数组就是好数组。你的任务是找出最长的良好线段。</p>
<h4 id="参考思路-123">参考思路</h4>
<p>直接双指针滑动窗口，维护区间和小于 $s$ 的最长段即可。</p>
<h4 id="参考代码-116">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, s;
    std::cin &gt;&gt; n &gt;&gt; s;
    std::vector&lt;i64&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    int i = 0;
    i64 sum = 0, ans = 0;
    for (int j = 0; j &lt; n; j++) {
        sum += a[j];
        while (sum &gt; s) sum -= a[i++];
        ans = std::max&lt;int&gt;(ans, j - i + 1);
    }

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="b-segment-with-big-sumhttpscodeforcescomeducourse2lesson92practicecontest307093problemb"><a href="https://codeforces.com/edu/course/2/lesson/9/2/practice/contest/307093/problem/B">B. Segment with Big Sum</a></h3>
<h4 id="题意-124">题意</h4>
<p>给定一个由 $n$ 个整数 $a_i$ 组成的数组。假设该数组的 $a[l..r]$ 段（ $1\le l\le r\le n$ ）中的元素之和至少为 $s$ ，那么该段就是好数组。( $1\le l\le r\le n$ )，如果这段上的元素之和至少为 $s$ ，那么这段就是好的。你的任务是找出最短的良好线段。</p>
<h4 id="参考思路-124">参考思路</h4>
<p>和上题类似，双指针滑动窗口，维护区间和大于等于 $s$ 的最小段长度即可。</p>
<h4 id="参考代码-117">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, s;
    std::cin &gt;&gt; n &gt;&gt; s;

    std::vector&lt;i64&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    int i = 0, ans = n + 1;
    i64 sum = 0;
    for (int j = 0; j &lt; n; j++) {
        sum += a[j];
        while (sum - a[i] &gt;= s) sum -= a[i++];

        if (sum &gt;= s) ans = std::min(ans, j - i + 1);
    }

    std::cout &lt;&lt; (ans == n + 1 ? -1 : ans);
}
</code></pre>
<h3 id="c-number-of-segments-with-small-sumhttpscodeforcescomeducourse2lesson92practicecontest307093problemc"><a href="https://codeforces.com/edu/course/2/lesson/9/2/practice/contest/307093/problem/C">C. Number of Segments with Small Sum</a></h3>
<h4 id="题意-125">题意</h4>
<p>给定一个由 $n$ 个整数 $a_i$ 组成的数组。假设数组 $a[l..r]$ ( $1\le l\le r\le n$ )中的元素之和最多为 $s$ ，那么这个数组中的 $a[l..r]$ ( $1\le l\le r\le n$ )就是好数组。你的任务是找出好线段的数量。</p>
<h4 id="参考思路-125">参考思路</h4>
<p>和上题类似，双指针滑动窗口，维护区间和小于等于 $s$，每新增一个元素，维护完左端点后，直接在答案中增加区间长度即可（可以理解为，以当前元素为右端点，向左共有 $r - l + 1$ 个区间，均满足要求）</p>
<h4 id="参考代码-118">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, s;
    std::cin &gt;&gt; n &gt;&gt; s;

    std::vector&lt;i64&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    i64 cnt = 0;

    i64 sum = 0;
    int i = 0;
    for (int j = 0; j &lt; n; j++) {
        sum += a[j];
        while (sum &gt; s) sum -= a[i++];

        cnt += (j - i + 1);
    }

    std::cout &lt;&lt; cnt;
}
</code></pre>
<h3 id="d-number-of-segments-with-big-sumhttpscodeforcescomeducourse2lesson92practicecontest307093problemd"><a href="https://codeforces.com/edu/course/2/lesson/9/2/practice/contest/307093/problem/D">D. Number of Segments with Big Sum</a></h3>
<h4 id="题意-126">题意</h4>
<p>给定一个由 $n$ 个整数 $a_i$ 组成的数组。假设数组 $a[l..r]$ ( $1\le l\le r\le n$ )的元素之和至少为 $s$ ，那么这个数组的 $a[l..r]$ ( $1\le l\le r\le n$ ) 段就是好数段。你的任务是找出好线段的数量。</p>
<h4 id="参考思路-126">参考思路</h4>
<p>和上题类似，只不过统计答案时，修改的贡献变成 左端点的下标（即，以当前位置为右端点，区间左端点以前的任何点作为右端点均可行）。</p>
<h4 id="参考代码-119">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, s;
    std::cin &gt;&gt; n &gt;&gt; s;

    std::vector&lt;i64&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    i64 cnt = 0;

    i64 sum = 0;
    int i = 0;
    for (int j = 0; j &lt; n; j++) {
        sum += a[j];
        while (sum &gt;= s) sum -= a[i++];

        cnt += i;
    }

    std::cout &lt;&lt; cnt;
}
</code></pre>
<h3 id="e-segments-with-small-sethttpscodeforcescomeducourse2lesson92practicecontest307093probleme"><a href="https://codeforces.com/edu/course/2/lesson/9/2/practice/contest/307093/problem/E">E. Segments with Small Set</a></h3>
<h4 id="题意-127">题意</h4>
<p>给定一个由 $n$ 个整数 $a_i$ 组成的数组。我们假设，如果数组 $a[l..r]$ ( $1\le l\le r\le n$ ) 的某一段上的唯一元素不超过 $k$ ，那么这段就是好数组。你的任务是找出不同的好线段的数量。</p>
<h4 id="参考思路-127">参考思路</h4>
<p>双指针滑动窗口，开个map维护统计区间本质不同数的数量即可。</p>
<h4 id="参考代码-120">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    
    std::vector&lt;int&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    std::map&lt;int, int&gt; cnt;

    i64 ans = 0;

    int i = 0;
    for (int j = 0; j &lt; n; j++) {
        cnt[a[j]]++;
        while (cnt.size() &gt; k) if (--cnt[a[i++]] == 0) cnt.erase(a[i - 1]);
        
        ans += (j - i + 1);
    }

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="f-segments-with-small-spreadhttpscodeforcescomeducourse2lesson92practicecontest307093problemf"><a href="https://codeforces.com/edu/course/2/lesson/9/2/practice/contest/307093/problem/F">F. Segments with Small Spread</a></h3>
<h4 id="题意-128">题意</h4>
<p>给定一个由 $n$ 个整数 $a_i$ 组成的数组。假设数组 $a[l..r]$ 中的一段（ $1\le l\le r\le n$ ）是好的。( $1\le l\le r\le n$ )，如果这段数组中最大元素和最小元素的差最多为 $k$ ，那么这段数组就是好数组。你的任务是找出不同良好线段的数量。</p>
<h4 id="参考思路-128">参考思路</h4>
<p>和上题类似，用map维护区间极差小于等于 $k$ 即可。</p>
<h4 id="参考代码-121">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, k;
    std::cin &gt;&gt; n &gt;&gt; k;

    std::vector&lt;i64&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    i64 ans = 0;

    int i = 0;
    std::multiset&lt;i64&gt; s;
    for (int j = 0; j &lt; n; j++) {
        s.insert(a[j]);
        while (*s.rbegin() - *s.begin() &gt; k) s.extract(a[i++]);

        ans += (j - i + 1);
    }

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="g-coprime-segmenthttpscodeforcescomeducourse2lesson92practicecontest307093problemg"><a href="https://codeforces.com/edu/course/2/lesson/9/2/practice/contest/307093/problem/G">G. Coprime Segment</a></h3>
<h4 id="题意-129">题意</h4>
<p>给定一个由 $n$ 个整数 $a_i$ 组成的数组。如果数组 $a[l..r]$ ( $1\le l\le r\le n$ )中所有数字的 GCD 都是 $1$ ，那么这个数组中的一段 $a[l..r]$ ( $1\le l\le r\le n$ ) 就是好数组。你的任务是找出最短的良好数段。</p>
<h4 id="参考思路-129">参考思路</h4>
<p>和上题类似，用ST表维护区间gcd即可。</p>
<h4 id="参考代码-122">参考代码</h4>
<pre><code class="language-cpp">struct ST {//静态RMQ
    int n;
    std::vector&lt;std::vector&lt;i64&gt;&gt; f;
    void load(std::vector&lt;i64&gt; &amp;a) {
        n = a.size();
        f = std::vector&lt;std::vector&lt;i64&gt;&gt;(n, std::vector&lt;i64&gt;(std::log2(n) + 2));
        for (int i = 0; i &lt; n; i++) f[i][0] = a[i];
    }
    void work() {
        for (int j = 1; j &lt; std::log2(n) + 1; j++) {
            for (int i = 0; i &lt; n - (1 &lt;&lt; j) + 1; i++) {
                f[i][j] = std::gcd(f[i][j - 1], f[i + (1 &lt;&lt; j - 1)][j - 1]);
            }
        }
    }
    i64 query(int l, int r) {//左闭右开
        r--;
        if (l &gt; r) return 0;//一般用不到
        int s = std::log2(r - l + 1);
        return std::gcd(f[l][s], f[r - (1 &lt;&lt; s) + 1][s]);
    }
};

void solve() {
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;i64&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    ST st;
    st.load(a);
    st.work();

    int ans = n + 1;

    int i = 0;
    for (int j = 0; j &lt; n; j++) {
        while (st.query(i + 1, j + 1) == 1) i++;
        if (st.query(i, j + 1) == 1) ans = std::min(ans, j - i + 1);
    }

    std::cout &lt;&lt; (ans == n + 1 ? -1 : ans);
}
</code></pre>
<h2 id="step-3-7">Step 3</h2>
<h3 id="a-looped-playlisthttpscodeforcescomeducourse2lesson93practicecontest307094problema"><a href="https://codeforces.com/edu/course/2/lesson/9/3/practice/contest/307094/problem/A">A. Looped Playlist</a></h3>
<h4 id="题意-130">题意</h4>
<p>米沙通过播放器听音乐，他的播放列表由 $n$ 首歌组成，这些歌曲按照特定顺序播放。最后一首歌结束后，第一首歌开始播放。每首歌都有自己的特点，积极性 $a_i$ ，由整数给出。听完 $i_th$ 歌曲后，米莎的情绪上升了 $a_i$ 。</p>
<p>米沙可以开始聆听任意一首歌曲，也可以连续聆听任意数量的歌曲，同时他可以多次聆听某些歌曲。</p>
<p>如果米沙听完歌曲后心情至少增加了 $p$ ，他就会感到开心。他希望听的歌曲越少越好。帮助他选择要开始听的歌和要听的歌曲数量，让他感到快乐。</p>
<h4 id="参考思路-130">参考思路</h4>
<p>考虑到可能存在，即使全部听完，也不可能达到 $p$ 的情况，即答案可能需要经过多次循环播放，我们需要预处理权值总和，判断至少需要循环几次。然后再将权值数组复制一份，拼接到原数组后面求一遍前缀和，最后跑一遍 $n^2$ 的双指针暴力统计最短的剩余所需区间长度，更新答案即可。</p>
<h4 id="参考代码-123">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, s;
    std::cin &gt;&gt; n &gt;&gt; s;

    std::vector&lt;i64&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    std::vector&lt;i64&gt; pre(2 * n + 1);

    i64 sum = std::accumulate(a.begin(), a.end(), 0ll);

    for (int i = 1; i &lt;= n; i++) {
        pre[i] = pre[i - 1] + a[i - 1];
    }

    for (int i = 1; i &lt;= n; i++) {
        pre[i + n] = pre[i - 1 + n] + a[i - 1]; 
    }

    i64 ans = s / sum * n;
    s %= sum;

    if (s == 0) {
        std::cout &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; ans;
        return;
    }

    int mi = 2 * n;
    int idx = 1; 

    for (int i = 1; i &lt;= n; i++) {
        for (int j = i; j &lt;= 2 * n; j++) {
            if (pre[j] - pre[i - 1] &gt;= s) {
                if (mi &gt; j - i + 1) {
                    mi = j - i + 1;
                    idx = i;
                }
                break;
            }
        }
    }

    std::cout &lt;&lt; idx &lt;&lt; &quot; &quot; &lt;&lt; ans + mi;
}
</code></pre>
<h3 id="b-total-lengthhttpscodeforcescomeducourse2lesson93practicecontest307094problemb"><a href="https://codeforces.com/edu/course/2/lesson/9/3/practice/contest/307094/problem/B">B. Total Length</a></h3>
<h4 id="题意-131">题意</h4>
<p>给定一个由 $n$ 个整数 $a_i$ 组成的数组。如果数组 $a[l..r]$ ( $1\le l\le r\le n$ )中的元素之和最多为 $s$ ，那么这个数组的 $a[l..r]$ ( $1\le l\le r\le n$ )段就是好数段。你的任务是找出所有好线段的长度之和。</p>
<h4 id="参考思路-131">参考思路</h4>
<p>和前面某题类似，不过要求长度和，所以我们只需在双指针滑动窗口的维护过程中，将答案更新方式改成，加上 $\frac{(r - l + 1)(r - l)}{2}$ 即可。</p>
<h4 id="参考代码-124">参考代码</h4>
<pre><code class="language-cpp">i64 calc(int x) {
    return 1ll * x * (x + 1) / 2;
}

void solve() {
    i64 n, s;
    std::cin &gt;&gt; n &gt;&gt; s;

    std::vector&lt;i64&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    i64 ans = 0;

    i64 sum = 0;
    int i = 0;
    for (int j = 0; j &lt; n; j++) {
        sum += a[j];
        while (sum &gt; s) sum -= a[i++];
        //std::cout &lt;&lt; i &lt;&lt; &quot;&lt;-&gt;&quot; &lt;&lt; j &lt;&lt; &quot;] : &quot; &lt;&lt; j - i + 1 &lt;&lt; &quot;\n&quot;;

        ans += calc(j - i + 1);
    }

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="c-che-cityhttpscodeforcescomeducourse2lesson93practicecontest307094problemc"><a href="https://codeforces.com/edu/course/2/lesson/9/3/practice/contest/307094/problem/C">C. Che city</a></h3>
<h4 id="题意-132">题意</h4>
<p>这是 2013 年俄罗斯高中团队编程竞赛中的一个问题</p>
<p>在车城市中心有一条步行街，是城市居民最喜欢散步的地方之一。这条街非常适合散步，因为沿街都是 $n$ 有趣的纪念碑。</p>
<p>车城的女孩玛莎喜欢学校里的两个男孩，她无法在他们之间做出选择。为了做出最后的决定，她决定同时和两个男孩约会。玛莎想在步行街上选择两个纪念碑，男孩们会在附近等她。同时，她还想选择这样的纪念碑，这样男孩子们就不会看到彼此了。玛莎知道，由于有雾，男孩们只有在距离不超过 $r$ 米的地方才能看到对方。玛莎感兴趣的是，有多少种方法可以选择两个不同的纪念碑来组织约会。</p>
<h4 id="参考思路-132">参考思路</h4>
<p>考虑双指针滑动窗口维护所有 “能够互相看到对方” 的方案数 $cnt$，答案即为 $\frac{n(n - 1)}{2} - cnt$。</p>
<h4 id="参考代码-125">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, s;
    std::cin &gt;&gt; n &gt;&gt; s;

    std::vector&lt;i64&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    i64 ans = 0;
    int i = 0;
    for (int j = 0; j &lt; n; j++) {
        while (a[j] - a[i] &gt; s) i++;
        //ans += 1ll * i * (n - j);
        ans += j - i + 1;
    }

    std::cout &lt;&lt; n * (n + 1) / 2 - ans;
}
</code></pre>
<h3 id="d-stylish-clotheshttpscodeforcescomeducourse2lesson93practicecontest307094problemd"><a href="https://codeforces.com/edu/course/2/lesson/9/3/practice/contest/307094/problem/D">D. Stylish clothes</a></h3>
<h4 id="题意-133">题意</h4>
<p>格列布喜欢购物。有一次，他想出了一个主意，那就是选择帽子、衬衫、裤子和鞋子，使它们看起来尽可能时尚。在格列布的理解中，当衣服各元素的颜色差异很小时，衣服就会更时尚。</p>
<p>有 $n_1$ 顶帽子、 $n_2$ 件衬衫、 $n_3$ 条裤子和 $n_4$ 双鞋子($1 \le n_i \le 100,000$)。每个衣服元素都有自己的颜色(从 $1$ 到 $100, 000$ 的整数)。一组衣服包括一顶帽子、一件衬衫、一条裤子和一双靴子。每套衣服的特征是任意两个元素之间的最大差异。请帮助格列布选择最时尚的套装，即色差最小的套装。</p>
<h4 id="参考思路-133">参考思路</h4>
<p>将四种数据均输入，排序后，四指针动态维护答案即可。具体实现细节看代码吧。</p>
<h4 id="参考代码-126">参考代码</h4>
<pre><code class="language-cpp">using Z = std::array&lt;int, 3&gt;;

void solve() {
    std::vector a(4, std::vector&lt;int&gt;());
    
    for (int i = 0; i &lt; 4; i++) {
        int n;
        std::cin &gt;&gt; n;
        a[i].resize(n);
        for (auto &amp;j : a[i]) std::cin &gt;&gt; j;

        std::sort(a[i].begin(), a[i].end());
    }

    std::set&lt;Z&gt; s;

    std::vector&lt;int&gt; i(4);
    std::priority_queue&lt;Z, std::vector&lt;Z&gt;, std::greater&lt;Z&gt;&gt; q;
    for (int j = 0; j &lt; 4; j++) {
        if (i[j] != a[j].size() - 1) q.push({a[j][i[j]], i[j], j});
        s.insert({a[j][i[j]], i[j], j});
    }

    int midiff = (*s.rbegin())[0] - (*s.begin())[0];
    std::vector&lt;int&gt; ans(4);
    for (auto &amp;[v, idx, i_] : s) {
        ans[i_] = v;
    }

    while (q.size()) {
        auto [_, idx, i_] = q.top(); q.pop();

        s.erase({_, idx, i_});

        idx++;
        s.insert({a[i_][idx], idx, i_});
        if (idx != a[i_].size() - 1) {
            q.push({a[i_][idx], idx, i_});
        }

        if ((*s.rbegin())[0] - (*s.begin())[0] &lt; midiff) {
            midiff = (*s.rbegin())[0] - (*s.begin())[0];
            for (auto &amp;[v, idx, i_] : s) {
                ans[i_] = v;
            }
        }
    }

    for (auto &amp;j : ans) std::cout &lt;&lt; j &lt;&lt; &quot; &quot;;
}
</code></pre>
<h3 id="e-knapsack-on-a-segmenthttpscodeforcescomeducourse2lesson93practicecontest307094probleme"><a href="https://codeforces.com/edu/course/2/lesson/9/3/practice/contest/307094/problem/E">E. Knapsack on a Segment</a></h3>
<h4 id="题意-134">题意</h4>
<p>给定一个由 $n$ 项组成的数组，每个项的权重为 $w_i$ ，成本为 $c_i$ 。您需要选择此数组的 <strong>一连续段</strong> ，该数组的总权重不大于 $s$ ，并且总成本为最大值。</p>
<h4 id="参考思路-134">参考思路</h4>
<p>考虑双指针滑动窗口，维护区间对权重求和小于等于 $s$，同时动态更新成本和的最大值即可。</p>
<h4 id="参考代码-127">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, s;
    std::cin &gt;&gt; n &gt;&gt; s;

    std::vector&lt;i64&gt; w(n), c(n);
    for (auto &amp;i : w) std::cin &gt;&gt; i;
    for (auto &amp;i : c) std::cin &gt;&gt; i;

    int i = 0;
    i64 sum_w = 0, sum_c = 0;

    i64 ans = 0;
    for (int j = 0; j &lt; n; j++) {
        sum_w += w[j];
        sum_c += c[j];
        while (sum_w &gt; s) sum_w -= w[i], sum_c -= c[i++];

        ans = std::max(ans, sum_c);
    }

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="f-card-substringshttpscodeforcescomeducourse2lesson93practicecontest307094problemf"><a href="https://codeforces.com/edu/course/2/lesson/9/3/practice/contest/307094/problem/F">F. Card Substrings</a></h3>
<h4 id="题意-135">题意</h4>
<p>给定字符串 $s$ 和 $m$ 带字母的卡片。您的任务是计算字符串 $s$ 的子字符串的数量，这些字符串可以由这些卡片生成。</p>
<p>例如，如果 $s = $ “aaab”，并且有三张卡片上有字母 “a”、“a” 和 “b”，那么您可以创建三个子字符串 “a”、子字符串 “b”、两个子字符串 “aa”、子字符串 “ab” 和 “aab”。您不能使子字符串为 “aaa” 和 “aaab”，因为只有两张卡片带有字母 “a”。</p>
<h4 id="参考思路-135">参考思路</h4>
<p>双指针维护区间各种元素数量和不超指定限制即可。</p>
<h4 id="参考代码-128">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::string s, t;
    std::cin &gt;&gt; s &gt;&gt; t;

    std::vector&lt;int&gt; cnt(26), zcnt(26);
    for (auto &amp;c : t) cnt[c - 'a']++;

    int i = 0;
    i64 ans = 0;
    for (int j = 0; j &lt; n; j++) {
        zcnt[s[j] - 'a']++;
        while (zcnt[s[j] - 'a'] &gt; cnt[s[j] - 'a']) zcnt[s[i++] - 'a']--;
        ans += j - i + 1;
    }

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="g-not-very-rude-substringhttpscodeforcescomeducourse2lesson93practicecontest307094problemg"><a href="https://codeforces.com/edu/course/2/lesson/9/3/practice/contest/307094/problem/G">G. Not Very Rude Substring</a></h3>
<h4 id="题意-136">题意</h4>
<p>您收到一个字符串 $s$ ，由 $n$ 小写英文字母组成。</p>
<p>长度为 $k$ 的字符串 $t$ 的粗糙度是 $(i, j)$ 的整数对数，其中 $1 \le i &lt; j \le k$ ，其中 $t_i = $ “a” 和 $t_j = $ “b”。换句话说，字符串的粗鲁之处在于除了两个字符以外删除所有字符的方法的数量，以便字符串 “ab” 保留下来。</p>
<p>您的任务是查找最大长度的子字符串 $s_l s_{l + 1} \dots s_r$ ，其粗鲁程度不超过 $c$ 。</p>
<h4 id="参考思路-136">参考思路</h4>
<p>根据题目定义，双指针维护区间子串的 rude 不超 $c$ 时更新答案即可。具体实现细节看代码吧。</p>
<h4 id="参考代码-129">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    i64 n, c;
    std::cin &gt;&gt; n &gt;&gt; c;

    std::string s;
    std::cin &gt;&gt; s;

    int i = 0;
    int ans = 0;
    i64 r = 0;
    std::vector&lt;int&gt; cnt(2);
    for (int j = 0; j &lt; n; j++) {
        int k = s[j] - 'a';
        
        if (k &lt;= 1) {
            if (k == 1) r += cnt[0];
            cnt[k]++;

            while (r &gt; c) {
                int k_ = s[i++] - 'a';
                if (k_ &gt; 1) continue;

                if (k_ == 0) r -= cnt[1];
                cnt[k_]--;
            }            
        }

        ans = std::max(ans, j - i + 1);
    }

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="h-a-b-knapsackhttpscodeforcescomeducourse2lesson93practicecontest307094problemh"><a href="https://codeforces.com/edu/course/2/lesson/9/3/practice/contest/307094/problem/H">H. A-B Knapsack</a></h3>
<h4 id="题意-137">题意</h4>
<p>给定 $n$ 件，重量为 $A$ ，成本为 $a_1, &hellip;, a_n$ ； $m$ 件，重量为 $B$ ，成本为 $b_1, &hellip;, b_m$ 。</p>
<p>这些物品装满了一个背包，该背包可承受的重量不超过 $s$ 。求背包中物品的最大总成本。</p>
<h4 id="参考思路-137">参考思路</h4>
<p>一看是背包问题，但实际上权值是固定的，我们先把重量大的物品装满背包，然后一个个取出物品时，双指针添加另一个重量较小，权值较大的物品，动态更新答案即可。</p>
<h4 id="参考代码-130">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, m;
    i64 s, A, B;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; A &gt;&gt; B;

    std::vector&lt;i64&gt; a(n), b(m);
    for (auto &amp;i : a) std::cin &gt;&gt; i;
    for (auto &amp;i : b) std::cin &gt;&gt; i;

    std::sort(a.rbegin(), a.rend());
    std::sort(b.rbegin(), b.rend());

    if (A &gt; B) {
        std::swap(A, B);
        std::swap(a, b);
        std::swap(n, m);
    }

    i64 sum = 0;
    i64 sum_w = 0;
    int i = 0;
    for (; i &lt; n; i++) {
        if (sum_w + A &gt; s) break;
        sum += a[i];
        sum_w += A;
    }

    i64 ans = sum;

    for (int j = 0; j &lt; m; j++) {
        sum += b[j];
        sum_w += B;
        while (i &amp;&amp; sum_w &gt; s) sum_w -= A, sum -= a[--i];

        if (sum_w &gt; s) break;
        //std::cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; &quot;: &quot; &lt;&lt; sum &lt;&lt; &quot;]\n&quot;;
        ans = std::max(ans, sum);
    }

    std::cout &lt;&lt; ans;
}
</code></pre>
<h3 id="i-segment-with-the-required-subsethttpscodeforcescomeducourse2lesson93practicecontest307094problemi"><a href="https://codeforces.com/edu/course/2/lesson/9/3/practice/contest/307094/problem/I">I. Segment with the Required Subset</a></h3>
<h4 id="题意-138">题意</h4>
<p>给定一个由 $n$ 个整数 $a_i$ 组成的数组。如果在这个数组的某一段 $a[l..r]$ 上可以选择一组和等于 $s$ 的数，那么这个数组的某一段 $a[l..r]$ 就是好数组。你的任务是找出最短的好线段。</p>
<h4 id="参考思路-138">参考思路</h4>
<p>考虑 dp，设 dp[i][j] 表示 到 i 位置为止，使得能够选一些数，让 sum 为 j，的最近的最大下标。</p>
<p><em>这跟双指针有关嘛？</em></p>
<h4 id="参考代码-131">参考代码</h4>
<pre><code class="language-cpp">void solve() {
    int n, s;
    std::cin &gt;&gt; n &gt;&gt; s;

    std::vector dp(n, std::vector&lt;int&gt;(s + 1, -1));
    std::vector&lt;int&gt; a(n);
    for (auto &amp;i : a) std::cin &gt;&gt; i;

    for (int i = 0; i &lt; n; i++) {
        dp[i][a[i]] = i;
    }

    int ans = n + 1;
    if (a[0] == s) ans = 1;

    for (int i = 1; i &lt; n; i++) {
        for (int j = 0; j &lt;= s; j++) {
            dp[i][j] = std::max(dp[i][j], dp[i - 1][j]);
        }
        for (int j = a[i]; j &lt;= s; j++) {
            dp[i][j] = std::max(dp[i][j], dp[i - 1][j - a[i]]);
        }

        //std::cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; &quot;]\n&quot;;
        if (dp[i][s] != -1) {
            ans = std::min(ans, i - dp[i][s] + 1);
        }
    }

    std::cout &lt;&lt; (ans == n + 1 ? -1 : ans);
}
</code></pre>
              


            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://xiaoxiauwu.github.io/tags/%E9%A2%98%E8%A7%A3/">题解</a>

  <a class="tag tag--primary tag--small" href="https://xiaoxiauwu.github.io/tags/cf/">CF</a>

                  </div>
                
              
            
            
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://xiaoxiauwu.github.io/post/algorithm/range_set/" data-tooltip="一种用于维护不交区间的STL科技" aria-label="PREVIOUS: 一种用于维护不交区间的STL科技">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--disabled">
          
              <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
  
  
    <li class="post-action">
      <a class="post-action-btn btn btn--default" href="#disqus_thread" aria-label="Leave a comment">
        <i class="far fa-comment"></i>
      </a>
    </li>
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


            
  
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
    <script type="text/javascript">
      var disqus_config = function() {
        this.page.url = 'https:\/\/xiaoxiauwu.github.io\/post\/solution\/edu_all\/';
        
          this.page.identifier = '\/post\/solution\/edu_all\/'
        
      };
      (function() {
        
        
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
          document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
          return;
        }
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'hugo-tranquilpeak-theme';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
  


          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2025 XiaoXia. All Rights Reserved
  </span>


<div class="busuanzi-footer">
  <span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span id="busuanzi_container_site_uv">
    本站访客数<span id="busuanzi_value_site_uv"></span>人次
  </span>
</div></footer>
      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://xiaoxiauwu.github.io/post/algorithm/range_set/" data-tooltip="一种用于维护不交区间的STL科技" aria-label="PREVIOUS: 一种用于维护不交区间的STL科技">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--disabled">
          
              <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
  
  
    <li class="post-action">
      <a class="post-action-btn btn btn--default" href="#disqus_thread" aria-label="Leave a comment">
        <i class="far fa-comment"></i>
      </a>
    </li>
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


      </div>
      

    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-times"></i>
    </div>
    
      <img id="about-card-picture" src="https://xiaoxiauwu.github.io/images/avatar.jpg" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">XiaoXia</h4>
    
      <div id="about-card-bio">憧憬着未来却虚度着当下，到头来自己也只是一片空虚吧<strong>LIVE IN THE MOMENT</strong></div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        学生
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker-alt"></i>
        <br/>
        华南理工大学
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://xiaoxiauwu.github.io/images/cover_.jpg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js" integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script src="https://xiaoxiauwu.github.io/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js"></script>


  
    <script async crossorigin="anonymous" defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js"></script>
  

  
    <script src="https://xiaoxiauwu.github.io/js/click.js"></script>
  

  
    <script src="https://xiaoxiauwu.github.io/js/sakura.js"></script>
  


<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>




    
  </body>
</html>

